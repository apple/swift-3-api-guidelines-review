

/*!
 * @function vImageAlphaBlend_Planar8
 * @abstract Composite two non-premultiplied planar 8-bit images, to produce a non-premultiplied result.
 * @discussion
 *
 *      For each color channel:
 * <pre>@textblock
 *          float destColor = (  srcTopColor * srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha * srcBottomColor ) / alpha
 * @/textblock </pre>
 *      alpha (the new alpha value for that pixel) is calculated as:
 * <pre>@textblock
 *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
 * @/textblock </pre>
 *      For planar data, you need to calculate alpha yourself ahead of time and provide that as an argument to this function.
 *      This can be done using: 
 * <pre>@textblock
 *          vImagePremultipliedAlphaBlend_Planar8( srcTopAlpha, srcTopAlpha, srcBottomAlpha, alpha, kvImageNoFlags );
 * @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The ARGB versions work for all 4 channel 8-bit / channel image formats with alpha first in memory.
 *
 * @param srcTop        The color image that is composited on top of the bottom image
 * @param srcTopAlpha   The alpha channel corresponding to the srcTop image
 * @param srcBottom     The color image that is below the srcTop image, into which it is blended
 * @param srcBottomAlpha The alpha channel corresponding to the srcBottom image
 * @param alpha         The alpha channel for the destination image. You need to calculate this ahead of time as:
 * <pre>@textblock
 *          vImagePremultipliedAlphaBlend_Planar8( srcTopAlpha, srcTopAlpha, srcBottomAlpha, alpha, kvImageNoFlags );
 * @/textblock </pre>
 * @oaram dest          The non-premultiplied result will be written here.
 *
 * @param flags         The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags          Default operation
 *
 *          kvImageDoNotTile        Disables internal multithreading. This may be useful if you are writing your own multithreaded tiling engine.
 *  @/textblock</pre>
 * @result              The following result codes may be returned:
 *  <pre>@textblock
 *          kvImageNoError                      Success!
 *          
 *          kvImageRoiLargerThanInputBuffer     The destination buffer must be no larger than srcTop, srcBottom, srcTopAlpha, srcBottomAlpha and alpha.
 *  @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageAlphaBlend_Planar8(srcTop: UnsafePointer<vImage_Buffer>, _ srcTopAlpha: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ srcBottomAlpha: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageAlphaBlend_PlanarF
 * @abstract Composite two non-premultiplied planar floating-point images, to produce a non-premultiplied result.
 * @discussion
 *
 *      For each color channel:
 * <pre>@textblock
 *          float destColor = (  srcTopColor * srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha * srcBottomColor ) / alpha
 * @/textblock </pre>
 *      alpha (the new alpha value for that pixel) is calculated as:
 * <pre>@textblock
 *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
 * @/textblock </pre>
 *      For planar data, you need to calculate alpha yourself ahead of time and provide that as an argument to this function.
 *      This can be done using:
 * <pre>@textblock
 *          vImagePremultipliedAlphaBlend_PlanarF( srcTopAlpha, srcTopAlpha, srcBottomAlpha, alpha, kvImageNoFlags );
 * @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The ARGB versions work for all 4 channel 8-bit / channel image formats with alpha first in memory.
 *
 * @param srcTop        The color image that is composited on top of the bottom image
 * @param srcTopAlpha   The alpha channel corresponding to the srcTop image
 * @param srcBottom     The color image that is below the srcTop image, into which it is blended
 * @param srcBottomAlpha The alpha channel corresponding to the srcBottom image
 * @param alpha         The alpha channel for the destination image. You need to calculate this ahead of time as:
 * <pre>@textblock
 *                          vImagePremultipliedAlphaBlend_PlanarF( srcTopAlpha, srcTopAlpha, srcBottomAlpha, alpha, kvImageNoFlags );
 * @/textblock </pre>
 * @oaram dest          The non-premultiplied result will be written here.
 *
 * @param flags         The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags          Default operation
 *
 *          kvImageDoNotTile        Disables internal multithreading. This may be useful if you are writing your own multithreaded tiling engine.
 *  @/textblock</pre>
 * @result              The following result codes may be returned:
 *  <pre>@textblock
 *          kvImageNoError                      Success!
 *
 *          kvImageRoiLargerThanInputBuffer     The destination buffer must be no larger than srcTop, srcBottom, srcTopAlpha, srcBottomAlpha and alpha.
 *  @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageAlphaBlend_PlanarF(srcTop: UnsafePointer<vImage_Buffer>, _ srcTopAlpha: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ srcBottomAlpha: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageAlphaBlend_ARGB8888
 * @abstract Composite two non-premultiplied ARGB8888 images, to produce a non-premultiplied result.
 * @discussion
 *
 *      For each color channel:
 * <pre>@textblock
 *          float destColor = (  srcTopColor * srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha * srcBottomColor ) / alpha
 * @/textblock </pre>
 *      alpha (the new alpha value for that pixel) is calculated as:
 * <pre>@textblock
 *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
 * @/textblock </pre>
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The ARGB versions work for all 4 channel 8-bit / channel image formats with alpha first in memory.
 *
 * @param srcTop        The image that is composited on top of the bottom image. The alpha channel must appear first.
 * @param srcBottom     The image that is below the srcTop image, into which it is blended. The alpha channel must appear first.
 * @oaram dest          The non-premultiplied result will be written here.
 *
 * @param flags         The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags          Default operation
 *
 *          kvImageDoNotTile        Disables internal multithreading. This may be useful if you are writing your own multithreaded tiling engine.
 *  @/textblock</pre>
 * @result              The following result codes may be returned:
 *  <pre>@textblock
 *          kvImageNoError                      Success!
 *
 *          kvImageRoiLargerThanInputBuffer     The destination buffer must be no larger than srcTop, srcBottom, srcTopAlpha, srcBottomAlpha and alpha.
 *  @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageAlphaBlend_ARGB8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageAlphaBlend_ARGBFFFF
 * @abstract Composite two non-premultiplied ARGBFFFF images, to produce a non-premultiplied result.
 * @discussion
 *
 *      For each color channel:
 * <pre>@textblock
 *          float destColor = (  srcTopColor * srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha * srcBottomColor ) / alpha
 * @/textblock </pre>
 *      alpha (the new alpha value for that pixel) is calculated as:
 * <pre>@textblock
 *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
 * @/textblock </pre>
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The ARGB versions work for all 4 channel float / channel image formats with alpha first in memory.
 *
 * @param srcTop        The image that is composited on top of the bottom image. The alpha channel must appear first.
 * @param srcBottom     The image that is below the srcTop image, into which it is blended. The alpha channel must appear first.
 * @oaram dest          The non-premultiplied result will be written here.
 *
 * @param flags         The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags          Default operation
 *
 *          kvImageDoNotTile        Disables internal multithreading. This may be useful if you are writing your own multithreaded tiling engine.
 *  @/textblock</pre>
 * @result              The following result codes may be returned:
 *  <pre>@textblock
 *          kvImageNoError                      Success!
 *
 *          kvImageRoiLargerThanInputBuffer     The destination buffer must be no larger than srcTop, srcBottom, srcTopAlpha, srcBottomAlpha and alpha.
 *  @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageAlphaBlend_ARGBFFFF(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlend_Planar8
 * @abstract blend two premultiplied Planar8 images to produce a premultiplied Planar8 result.
 * @discussion
 *      For each color channel:
 * <pre>@textblock
 *          uint8_t destColor = srcTopColor  + ((255 - srcTopAlpha) * srcBottomColor + 127)/255;
 * @/textblock</pre>
 *      Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0, 255].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 * @param srcTop            The top image
 * @param srcTopAlpha       The coverage component for the top image (alpha)
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.3, *)
func vImagePremultipliedAlphaBlend_Planar8(srcTop: UnsafePointer<vImage_Buffer>, _ srcTopAlpha: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlend_PlanarF
 * @abstract blend two premultiplied PlanarF images to produce a premultiplied PlanarF result.
 * @discussion
 *      For each color channel:
 * <pre>@textblock
 *          float destColor = srcTopColor  + (1.0 - srcTopAlpha) * srcBottomColor;
 * @/textblock</pre>
 *      Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0.0f, 1.0f].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 * @param srcTop            The top image
 * @param srcTopAlpha       The coverage component for the top image (alpha)
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.3, *)
func vImagePremultipliedAlphaBlend_PlanarF(srcTop: UnsafePointer<vImage_Buffer>, _ srcTopAlpha: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlend_ARGB8888
 * @abstract blend two premultiplied ARGB8888 images to produce a premultiplied ARGB8888 result.
 * @discussion
 *      For each color channel:
 * <pre>@textblock
 *          uint8_t destColor = srcTopColor  + ((255 - srcTopAlpha) * srcBottomColor + 127)/255;
 * @/textblock</pre>
 *      Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0, 255].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel 8-bit / channel image formats with alpha first in memory, not just ARGB.
 *
 * @param srcTop            The top image
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * @param flags             The following flags may be used:
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling 
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.3, *)
func vImagePremultipliedAlphaBlend_ARGB8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlend_BGRA8888
 * @abstract blend two premultiplied BGRA8888 images to produce a premultiplied BGRA8888 result.
 * @discussion
 *      For each color channel:
 * <pre>@textblock
 *          uint8_t destColor = srcTopColor  + ((255 - srcTopAlpha) * srcBottomColor + 127)/255;
 * @/textblock</pre>
 *      Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0, 255].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just BGRA.
 *      Also available as vImagePremultipliedAlphaBlend_RGBA8888().
 *
 * @param srcTop            The top image
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * @param flags             The following flags may be used:
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.6, *)
func vImagePremultipliedAlphaBlend_BGRA8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlend_ARGBFFFF
 * @abstract blend two premultiplied ARGBFFFF images to produce a premultiplied ARGBFFFF result.
 * @discussion
 * <pre>@textblock
 *          float destColor = srcTopColor  + (1.0 - srcTopAlpha) * srcBottomColor;
 * @/textblock</pre>
 *      Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0.0f, 1.0f].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel float / channel image formats with alpha first in memory, not just ARGB.
 *
 * @param srcTop            The top image
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * @param flags             The following flags may be used:
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.3, *)
func vImagePremultipliedAlphaBlend_ARGBFFFF(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlend_BGRAFFFF
 * @abstract blend two premultiplied ARGBFFFF images to produce a premultiplied BGRAFFFF result.
 * @discussion
 * <pre>@textblock
 *          float destColor = srcTopColor  + (1.0 - srcTopAlpha) * srcBottomColor;
 * @/textblock</pre>
 *      Similarly, the output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          float alpha =  srcTopAlpha + (1.0 - srcTopAlpha) * srcBottomAlpha
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0.0f, 1.0f].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel float / channel image formats with alpha first in memory, not just BGRA.
 *      Also available as vImagePremultipliedAlphaBlend_RGBAFFFF.
 *
 * @param srcTop            The top image
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * @param flags             The following flags may be used:
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.6, *)
func vImagePremultipliedAlphaBlend_BGRAFFFF(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlendWithPermute_ARGB8888
 * @abstract Reorder the channels of the top 8-bit 4 channel premultiplied image, blend into a bottom premultiplied ARGB8888 image.
 * @discussion
 *  This function does 3 things.
 * <pre>@textblock
 *      1. Changes the order of channels of srcTop according to permuteMap.
 *      2. A premultiplied alpha compositing.
 *      3. Set destA to 0xFF when makeDestAlphaOpaque is true.
 *
 *      permuteMap[i] = 0, 1, 2, or 3 to specify how we permute each channel in srcTop.
 *
 *      permuteMap[0] tells which channel in srcTop XXXX8888 will be used as A.
 *      permuteMap[1] tells which channel in srcTop XXXX8888 will be used as R.
 *      permuteMap[2] tells which channel in srcTop XXXX8888 will be used as G.
 *      permuteMap[3] tells which channel in srcTop XXXX8888 will be used as B.
 * @/textblock</pre>
 *
 *  This permuteMap lets us to cover any channel order for the top and bottom images.
 *  For example,
 * <pre>@textblock
 *      PremultipliedAlphaBlend(srcTop_ARGB8888, srcBottom_ARGB8888) -> dest_ARGB8888
 *                     will be covered by permuteMap[4] = {0, 1, 2, 3}
 *
 *      PremultipliedAlphaBlend(srcTop_RGBA8888, srcBottom_ARGB8888) -> dest_ARGB8888
 *                     will be covered by permuteMap[4] = {3, 0, 1, 2}
 *
 *      PremultipliedAlphaBlend(srcTop_ABGR8888, srcBottom_ARGB8888) -> dest_ARGB8888
 *                     will be covered by permuteMap[4] = {0, 3, 2, 1}
 *
 *      PremultipliedAlphaBlend(srcTop_BGRA8888, srcBottom_ARGB8888) -> dest_ARGB8888
 *                     will be covered by permuteMap[4] = {3, 2, 1, 0}
 * @/textblock</pre>
 *
 *  srcBottom will have the same pixel format (ARGB8888) as dest.
 *
 *
 *  The per-pixel operation is:
 *
 * <pre>@textblock
 *  uint8_t *srcTop, *srcBottom, *dest;
 *  uint8_t srcTopA, srcTopR, srcTopG, srcTopB;
 *  uint8_t srcBottomA, srcBottomR, srcBottomG, srcBottomB;
 *  uint8_t destA, destR, destG, destB;
 *
 *  srcTopA = srcTop[ permuteMap[0] ];
 *  srcTopR = srcTop[ permuteMap[1] ];
 *  srcTopG = srcTop[ permuteMap[2] ];
 *  srcTopB = srcTop[ permuteMap[3] ];
 *
 *  srcBottomA = srcBottom[ 0 ];
 *  srcBottomR = srcBottom[ 1 ];
 *  srcBottomG = srcBottom[ 2 ];
 *  srcBottomB = srcBottom[ 3 ];
 *
 *  destR = (srcTopR * 255 + (255 - srcTopA) * srcBottomR + 127) / 255;
 *  destG = (srcTopG * 255 + (255 - srcTopA) * srcBottomG + 127) / 255;
 *  destB = (srcTopB * 255 + (255 - srcTopA) * srcBottomB + 127) / 255;
 *
 *  if(makeDestAlphaOpaque)
 *  {
 *
 *      dest[0] = 0xFF;
 *      dest[1] = destR;
 *      dest[2] = destG;
 *      dest[3] = destB;
 *  }
 *  else
 *  {
 *      destA = (srcTopA * 255 + (255 - srcTopA) * srcBottomA + 127) / 255;
 *
 *      dest[0] = destA;
 *      dest[1] = destR;
 *      dest[2] = destG;
 *      dest[3] = destB;
 *  }
 * @/textblock</pre>
 *
 *  This function can work in place.
 *
 *  @param srcTop       A pointer to vImage_Buffer that references 8-bit XXXX interleaved source top image.
 *  @param srcBottom    A pointer to vImage_Buffer that references 8-bit ARGB interleaved source bottom image.
 *  @param dest         A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination image.
 *  @param permuteMap   Values that can be used to switch the channel order of the source top image.
 *  @param makeDestAlphaOpaque  A boolean to set destA into 0xFF when it's true.
 *  @param flags        The following flags are allowed:
 * <pre>@textblock
 *      kvImageGetTempBufferSize    Returns 0. Does no work.
 *      kvImageDoNotTile            Disables internal multithreading, if any.
 * @/textblock</pre>
 * @return The following error codes may be returned:
 * <pre>@textblock
 *      kvImageNoError                  Is returned when there was no error.
 *      kvImageRoiLargerThanInputBuffer The destination buffers are larger than the source buffer.
 *      kvImageBufferSizeMismatch       Is returned when there is a mismatch in width & height of srcTop and srcBottom.
 *      kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
 *      kvImageInvalidParameter         Is returned when the values in permuteMap[i] is not one of 0, 1, 2, or 3.
 * @/textblock</pre>
 *
 */
@available(OSX 10.9, *)
func vImagePremultipliedAlphaBlendWithPermute_ARGB8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ makeDestAlphaOpaque: Bool, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlendWithPermute_RGBA8888
 * @abstract Reorder the channels of the top 8-bit 4 channel premultiplied image, blend into a bottom premultiplied RGBA8888 image.
 * @discussion
 *  This function does 3 things.
 * <pre>@textblock
 *      1. Changes the order of channels of srcTop according to permuteMap.
 *      2. A premultiplied alpha compositing.
 *      3. Set destA to 0xFF when makeDestAlphaOpaque is true.
 *
 *      permuteMap[i] = 0, 1, 2, or 3 to specify how we permute each channel in srcTop.
 *
 *      permuteMap[0] tells which channel in srcTop XXXX8888 will be used as A.
 *      permuteMap[1] tells which channel in srcTop XXXX8888 will be used as R.
 *      permuteMap[2] tells which channel in srcTop XXXX8888 will be used as G.
 *      permuteMap[3] tells which channel in srcTop XXXX8888 will be used as B.
 * @/textblock</pre>
 *
 *  This permuteMap lets us to cover any channel order for the top and bottom images.
 *  For example,
 * <pre>@textblock
 *      PremultipliedAlphaBlend(srcTop_RGBA8888, srcBottom_RGBA8888) -> dest_RGBA8888
 *                     will be covered by permuteMap[4] = {0, 1, 2, 3}
 *
 *      PremultipliedAlphaBlend(srcTop_ARGB8888, srcBottom_RGBA8888) -> dest_RGBA8888
 *                     will be covered by permuteMap[4] = {1, 2, 3, 0}
 *
 *      PremultipliedAlphaBlend(srcTop_ABGR8888, srcBottom_RGBA8888) -> dest_RGBA8888
 *                     will be covered by permuteMap[4] = {3, 2, 1, 0}
 *
 *      PremultipliedAlphaBlend(srcTop_BGRA8888, srcBottom_RGBA8888) -> dest_RGBA8888
 *                     will be covered by permuteMap[4] = {2, 1, 0, 3}
 * @/textblock</pre>
 *
 *  srcBottom will have the same pixel format (RGBA8888) as dest.
 *
 *
 *  The per-pixel operation is:
 *
 * <pre>@textblock
 *  uint8_t *srcTop, *srcBottom, *dest;
 *  uint8_t srcTopA, srcTopR, srcTopG, srcTopB;
 *  uint8_t srcBottomA, srcBottomR, srcBottomG, srcBottomB;
 *  uint8_t destA, destR, destG, destB;
 *
 *  srcTopR = srcTop[ permuteMap[0] ];
 *  srcTopG = srcTop[ permuteMap[1] ];
 *  srcTopB = srcTop[ permuteMap[2] ];
 *  srcTopA = srcTop[ permuteMap[3] ];
 *
 *  srcBottomR = srcBottom[ 0 ];
 *  srcBottomG = srcBottom[ 1 ];
 *  srcBottomB = srcBottom[ 2 ];
 *  srcBottomA = srcBottom[ 3 ];
 *
 *  destR = (srcTopR * 255 + (255 - srcTopA) * srcBottomR + 127) / 255;
 *  destG = (srcTopG * 255 + (255 - srcTopA) * srcBottomG + 127) / 255;
 *  destB = (srcTopB * 255 + (255 - srcTopA) * srcBottomB + 127) / 255;
 *
 *  if(makeDestAlphaOpaque)
 *  {
 *
 *      dest[0] = 0xFF;
 *      dest[1] = destR;
 *      dest[2] = destG;
 *      dest[3] = destB;
 *  }
 *  else
 *  {
 *      destA = (srcTopA * 255 + (255 - srcTopA) * srcBottomA + 127) / 255;
 *
 *      dest[0] = destA;
 *      dest[1] = destR;
 *      dest[2] = destG;
 *      dest[3] = destB;
 *  }
 * @/textblock</pre>
 *
 *  This function can work in place.
 *
 *  @param srcTop       A pointer to vImage_Buffer that references 8-bit XXXX interleaved source top image.
 *  @param srcBottom    A pointer to vImage_Buffer that references 8-bit RGBA interleaved source bottom image.
 *  @param dest         A pointer to vImage_Buffer that references 8-bit RGBA interleaved destination image.
 *  @param permuteMap   Values that can be used to switch the channel order of the source top image.
 *  @param makeDestAlphaOpaque  A boolean to set destA into 0xFF when it's true.
 *  @param flags        The following flags are allowed:
 * <pre>@textblock
 *      kvImageGetTempBufferSize    Returns 0. Does no work.
 *      kvImageDoNotTile            Disables internal multithreading, if any.
 * @/textblock</pre>
 * @return The following error codes may be returned:
 * <pre>@textblock
 *      kvImageNoError                  Is returned when there was no error.
 *      kvImageRoiLargerThanInputBuffer The destination buffers are larger than the source buffer.
 *      kvImageBufferSizeMismatch       Is returned when there is a mismatch in width & height of srcTop and srcBottom.
 *      kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
 *      kvImageInvalidParameter         Is returned when the values in permuteMap[i] is not one of 0, 1, 2, or 3.
 * @/textblock</pre>
 *
 */
@available(OSX 10.9, *)
func vImagePremultipliedAlphaBlendWithPermute_RGBA8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ makeDestAlphaOpaque: Bool, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlendMultiply_RGBA8888
 * @abstract blend two premultiplied RGBA8888 images using the Multiply blend mode to produce a premultiplied RGBA8888 result.
 * @discussion
 *      For each color channel:
 * <pre>@textblock
 *          uint8_t destColor =((255 -    srcTopAlpha) * srcBottomColor +
 *                              (255 - srcBottomAlpha) * srcTopColor + 
 *                               srcTopColor * srcBottomColor + 127)/255;
 * @/textblock</pre>
 *      The output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0, 255].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just RGBA.
 *      This function corresponds to the multiply blend mode in feBlend in the SVG standard. http://www.w3.org/TR/SVG/filters.html)
 *
 * @param srcTop            The top image
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * @param flags             The following flags may be used:
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.11, *)
func vImagePremultipliedAlphaBlendMultiply_RGBA8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlendScreen_RGBA8888
 * @abstract blend two premultiplied RGBA8888 images using the Screen blend mode to produce a premultiplied RGBA8888 result.
 * @discussion
 *      For each color channel:
 * <pre>@textblock
 *          uint8_t destColor = CLAMP( srcTopColor + srcBottomcolor - (srcTopColor * srcBottomColor + 127)/255, 0, 255);
 * @/textblock</pre>
 *      The output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0, 255].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just RGBA.
 *      This function corresponds to the screen blend mode in feBlend in the SVG standard. http://www.w3.org/TR/SVG/filters.html)
 *
 * @param srcTop            The top image
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * @param flags             The following flags may be used:
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.11, *)
func vImagePremultipliedAlphaBlendScreen_RGBA8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlendDarken_RGBA8888
 * @abstract blend two premultiplied RGBA8888 images using the Darken blend mode to produce a premultiplied RGBA8888 result.
 * @discussion
 *      For each color channel:
 * <pre>@textblock
 *          uint8_t destColor = MIN( topColor +    ((255 - srcTopAlpha) *  srcBotomColor + 127) / 255,
 *                                   bottomColor + ((255 - srcBottomAlpha) * srcTopColor + 127) / 255);
 * @/textblock</pre>
 *      The output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0, 255].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just RGBA.
 *      This function corresponds to the darken blend mode in feBlend in the SVG standard. http://www.w3.org/TR/SVG/filters.html)
 *
 * @param srcTop            The top image
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * @param flags             The following flags may be used:
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 *
 */
@available(OSX 10.11, *)
func vImagePremultipliedAlphaBlendDarken_RGBA8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedAlphaBlendLighten_RGBA8888
 * @abstract blend two premultiplied RGBA8888 images using the Lighten blend mode to produce a premultiplied RGBA8888 result.
 * @discussion
 *      For each color channel:
 * <pre>@textblock
 *          uint8_t destColor = MAX( topColor +    ((255 - srcTopAlpha) *  srcBotomColor + 127) / 255,
 *                                   bottomColor + ((255 - srcBottomAlpha) * srcTopColor + 127) / 255);
 * @/textblock</pre>
 *      The output alpha channel (the new alpha value for that pixel) can be calculated as:
 * <pre>@textblock
 *          uint8_t alpha =  srcTopAlpha + ((255 - srcTopAlpha) * srcBottomAlpha + 127)/255;
 * @/textblock</pre>
 *      The alpha values are presumed to be normalized over the range [0, 255].
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel 8-bit / channel image formats with alpha last in memory, not just RGBA.
 *      This function corresponds to the lighten blend mode in feBlend in the SVG standard. http://www.w3.org/TR/SVG/filters.html)
 *
 * @param srcTop            The top image
 * @param srcBottom         The bottom image
 * @param dest              The result image is written here. This buffer must be preallocated before the function is called.
 * @param flags             The following flags may be used:
 * <pre>@textblock
 *      kvImageNoFlags      Default operation
 *
 *      kvImageDoNotTile    Disable internal multithreading. You might want to do that if you are calling
 *                          this in the context of your own multithreaded tiling engine.
 * @/textblock </pre>
 *
 * @result  The following error codes may occur:
 * <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     The height and width of the result must be less than or equal to each of the input buffers.
 * @/textblock</pre>
 */
@available(OSX 10.11, *)
func vImagePremultipliedAlphaBlendLighten_RGBA8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_Planar8
 *  @abstract Multiply a Planar8 color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.  
 *  <pre>@textblock
 *      For each color channel:
 *
 *          uint8_t destColor = (src * alpha + 127) / 255;
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *  @/textblock </pre>
 *
 *  @param src      The color data to multiply with alpha
 *  @param alpha    The alpha data to multiply against src
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already  multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding 
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImagePremultiplyData_Planar8(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_PlanarF
 *  @abstract Multiply a PlanarF color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *  <pre>@textblock
 *      For each color channel:
 *
 *          float destColor = src * alpha;
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *  @/textblock </pre>
 *
 *  @param src      The color data to multiply with alpha
 *  @param alpha    The alpha data to multiply against src
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already  multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImagePremultiplyData_PlanarF(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_ARGB8888
 *  @abstract Multiply a ARGB8888 color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *  <pre>@textblock
 *      For each color channel:
 *
 *          uint8_t destColor = (src * alpha + 127) / 255;
 *          uint8_t destAlpha = alpha;
 *
 *      This function can work in place provided the following are true:
 *          If src overlaps with dest, src->data must be equal to dest->data
 *          If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *                  (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
 *  @/textblock </pre>
 *
 *      This function will for all 4 channel 8-bit / channel image formats with alpha first in memory.
 *      It does not have to be ARGB.
 *
 *  @param src      The color data to multiply with alpha
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImagePremultiplyData_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_ARGBFFFF
 *  @abstract Multiply a ARGBFFFF color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *  <pre>@textblock
 *      For each color channel:
 *
 *          float destColor = src * alpha;
 *          float destAlpha = alpha;
 *
 *      This function can work in place provided the following are true:
 *          If src overlaps with dest, src->data must be equal to dest->data
 *          If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *                  (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
 *  @/textblock </pre>
 *
 *      This function will for all 4 channel float / channel image formats with alpha first in memory.
 *      It does not have to be ARGB.
 *
 *  @param src      The color data to multiply with alpha
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImagePremultiplyData_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_RGBA8888
 *  @abstract Multiply a RGBA8888 color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *  <pre>@textblock
 *      For each color channel:
 *
 *          uint8_t destColor = (src * alpha + 127) / 255;
 *          uint8_t destAlpha = alpha;
 *
 *      This function can work in place provided the following are true:
 *          If src overlaps with dest, src->data must be equal to dest->data
 *          If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *                  (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
 *  @/textblock </pre>
 *
 *      This function will for all 4 channel 8-bit / channel image formats with alpha last in memory.
 *      It does not have to be RGBA. Also available as vImagePremultiplyData_BGRA8888().
 *
 *  @param src      The color data to multiply with alpha
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.4, *)
func vImagePremultiplyData_RGBA8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_RGBAFFFF
 *  @abstract Multiply a RGBAFFFF color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *  <pre>@textblock
 *      For each color channel:
 *
 *          float destColor = src * alpha;
 *          float destAlpha = alpha;
 *
 *      This function can work in place provided the following are true:
 *          If src overlaps with dest, src->data must be equal to dest->data
 *          If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *                  (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
 *  @/textblock </pre>
 *
 *      This function will for all 4 channel float / channel image formats with alpha first in memory.
 *      It does not have to be RGBA. Also available as vImagePremultiplyData_BGRAFFFF().
 *
 *  @param src      The color data to multiply with alpha
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.4, *)
func vImagePremultiplyData_RGBAFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_ARGB16U
 *  @abstract Multiply a unsigned 16-bit ARGB color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *  <pre>@textblock
 *      For each color channel:
 *
 *          uint16_t destColor = (src * alpha + 32767) / 65535;
 *          uint16_t destAlpha = alpha;
 *
 *      This function can work in place provided the following are true:
 *          If src overlaps with dest, src->data must be equal to dest->data
 *          If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *                  (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
 *  @/textblock </pre>
 *
 *      This function will for all 4 channel uint16_t / channel image formats with alpha first in memory.
 *      It does not have to be ARGB.
 *
 *  @param src      The color data to multiply with alpha
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.8, *)
func vImagePremultiplyData_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_RGBA16U
 *  @abstract Multiply a unsigned 16-bit RGBA color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *  <pre>@textblock
 *      For each color channel:
 *
 *          uint16_t destColor = (src * alpha + 32767) / 65535;
 *          uint16_t destAlpha = alpha;
 *
 *      This function can work in place provided the following are true:
 *          If src overlaps with dest, src->data must be equal to dest->data
 *          If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *                  (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
 *  @/textblock </pre>
 *
 *      This function will for all 4 channel uint16_t / channel image formats with alpha last in memory.
 *      It does not have to be RGBA. Also available as vImagePremultiplyData_BGRA16U().
 *
 *  @param src      The color data to multiply with alpha
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.8, *)
func vImagePremultiplyData_RGBA16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_ARGB16Q12
 *  @abstract Multiply a signed 16Q12 fixed-point ARGB color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *      For each color in each pixel:
 *  <pre>@textblock
 *          int16_t destColor = CLAMP((src * alpha + 2048) / 4096, INT16_MIN, INT16_MAX);
 *          int16_t destAlpha = alpha;
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          If src overlaps with dest, src->data must be equal to dest->data
 *          If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *                  (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
 *
 *      This function will for other 4 channel 16Q12 / channel image formats with alpha first in memory.
 *      It does not have to be ARGB.
 *
 *  @param src      The color data to multiply with alpha
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.9, *)
func vImagePremultiplyData_ARGB16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImagePremultiplyData_RGBA16Q12
 *  @abstract Multiply a signed 16Q12 RGBA color channel by its corresponding alpha
 *  @discussion
 *  This function multiplies color channels by the alpha channel.
 *      For each color in each pixel:
 *  <pre>@textblock
 *          int16_t destColor = CLAMP((src * alpha + 2048) / 4096, INT16_MIN, INT16_MAX);
 *          int16_t destAlpha = alpha;
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          If src overlaps with dest, src->data must be equal to dest->data
 *          If src also has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *                  (It is not necessary to pass kvImageDoNotTile if src and dest do not overlap.)
 *
 *      This function will for all 4 channel 16Q12 / channel image formats with alpha last in memory.
 *      It does not have to be RGBA.
 *
 *  @param src      The color data to multiply with alpha
 *  @param dest     A preallocated vImage_Buffer where the results are written
 *  @param flags    The following flags are allowed:
 *  <pre>@textblock
 *          kvImageNoFlags                      Default operation
 *
 *          kvImageDoNotTile                    Turn off internal multithreading. This might be useful if you are already multithreading
 *                                              the work in your own tiling engine.
 *  @/textblock </pre>
 *  @result         The following result codes may occur:
 *  <pre>@textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and dest->height must be less than or equal to corresponding
 *                                              dimensions in src and alpha
 *  @/textblock</pre>
 */
@available(OSX 10.9, *)
func vImagePremultiplyData_RGBA16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_Planar8
 *  @abstract Divide alpha from a premultiplied Planar8 images
 *
 *  @discussion This function divides color channels by the alpha channel.
 *      For each color channel:
 *  <pre>@textblock
 *          uint8_t destColor = ( MIN(src_color, alpha) * 255 + alpha/2) / alpha;
 *  @/textblock </pre>
 *      ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
 *      In the division by zero case, the returned color value is 0.  
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data.
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *  @param src          The planar8 input color channel
 *  @param alpha        The planar8 input alpha channel
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageUnpremultiplyData_Planar8(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_PlanarF
 *  @abstract Divide alpha from a premultiplied PlanarF images
 *
 *  @discussion This function divides color channels by the alpha channel.
 *      For each color channel:
 *  <pre>@textblock
 *          float destColor = destColor / alpha;   // according to current rounding mode
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data.
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *  @param src          The planarF input color channel
 *  @param alpha        The planarF input alpha channel
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageUnpremultiplyData_PlanarF(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_ARGB8888
 *  @abstract Divide the alpha channel from the color channels in a ARGB8888 image
 *  @discussion
 *  This function divides color channels by the alpha channel.
 *      For each color channel:
 *      <pre>@textblock
 *          uint8_t destColor = ( MIN(src_color, alpha) * 255 + alpha/2) / alpha;
 *          uint8_t destAlpha = alpha;
 *      @/textblock </pre>
 *
 *      ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
 *      In the division by zero case, the returned color value is 0.  
 *
 *      The positioning of only the alpha channel is important for interleaved formats for these functions.
 *      This function will work with other channel orders that have alpha first.
 *
 *      This function can work in place provided the following are true:
 *          src->data must be equal to dest->data
 *          src->rowBytes must be equal to dest->rowBytes
 *
 *  @param src          The input inmage
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageUnpremultiplyData_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_RGBA8888
 *  @abstract Divide the alpha channel from the color channels in a RGBA8888 image
 *  @discussion
 *  This function divides color channels by the alpha channel.
 *      For each color channel:
 *      <pre>@textblock
 *          uint8_t destColor = ( MIN(src_color, alpha) * 255 + alpha/2) / alpha;
 *          uint8_t destAlpha = alpha;
 *      @/textblock </pre>
 *
 *      ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
 *      In the division by zero case, the returned color value is 0.
 *
 *      The positioning of only the alpha channel is important for interleaved formats for these functions.
 *      This function will work with other channel orders that have alpha last. The function is also available as vImageUnpremultiplyData_BGRA8888.
 *
 *      This function can work in place provided the following are true:
 *          src->data must be equal to dest->data
 *          src->rowBytes must be equal to dest->rowBytes
 *
 *  @param src          The input inmage
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageUnpremultiplyData_RGBA8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_ARGBFFFF
 *  @abstract Divide the alpha channel from the color channels in a ARGBFFFF image
 *  @discussion
 *  This function divides color channels by the alpha channel.
 *      For each color channel:
 *      <pre>@textblock
 *          float destColor = destColor / alpha;
 *          float destAlpha = alpha;
 *      @/textblock </pre>
 *
 *      The positioning of only the alpha channel is important for interleaved formats for these functions.
 *      This function will work with other channel orders that have alpha first.
 *
 *      This function can work in place provided the following are true:
 *          src->data must be equal to dest->data
 *          src->rowBytes must be equal to dest->rowBytes
 *
 *  @param src          The input inmage
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageUnpremultiplyData_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_RGBAFFFF
 *  @abstract Divide the alpha channel from the color channels in a RGBAFFFF image
 *  @discussion
 *  This function divides color channels by the alpha channel.
 *      For each color channel:
 *      <pre>@textblock
 *          float destColor = destColor / alpha;
 *          float destAlpha = alpha;
 *      @/textblock </pre>
 *
 *      The positioning of only the alpha channel is important for interleaved formats for these functions.
 *      This function will work with other channel orders that have alpha last. It is also available as vImageUnpremultiplyData_BGRAFFFF().
 *
 *      This function can work in place provided the following are true:
 *          src->data must be equal to dest->data
 *          src->rowBytes must be equal to dest->rowBytes
 *
 *  @param src          The input inmage
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageUnpremultiplyData_RGBAFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_ARGB16U
 *  @abstract Divide the alpha channel from the color channels in a ARGB16U image
 *  @discussion
 *  This function divides color channels by the alpha channel.
 *      For each color channel:
 *      <pre>@textblock
 *          uint16_t destColor = ( MIN(src_color, alpha) * 65535 + alpha/2) / alpha;
 *          uint16_t destAlpha = alpha;
 *      @/textblock </pre>
 *
 *      ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
 *      In the division by zero case, the returned color value is 0.
 *
 *      The positioning of only the alpha channel is important for interleaved formats for these functions.
 *      This function will work with other channel orders that have alpha first.
 *
 *      This function can work in place provided the following are true:
 *          src->data must be equal to dest->data
 *          src->rowBytes must be equal to dest->rowBytes
 *
 *  @param src          The input inmage
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.8, *)
func vImageUnpremultiplyData_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_RGBA16U
 *  @abstract Divide the alpha channel from the color channels in a RGBA16U image
 *  @discussion
 *  This function divides color channels by the alpha channel.
 *      For each color channel:
 *      <pre>@textblock
 *          uint16_t destColor = ( MIN(src_color, alpha) * 65535 + alpha/2) / alpha;
 *          uint16_t destAlpha = alpha;
 *      @/textblock </pre>
 *
 *      ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
 *      In the division by zero case, the returned color value is 0.
 *
 *      The positioning of only the alpha channel is important for interleaved formats for these functions.
 *      This function will work with other channel orders that have alpha last. The function is also available as vImageUnpremultiplyData_BGRA16U.
 *
 *      This function can work in place provided the following are true:
 *          src->data must be equal to dest->data
 *          src->rowBytes must be equal to dest->rowBytes
 *
 *  @param src          The input inmage
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.8, *)
func vImageUnpremultiplyData_RGBA16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_ARGB16Q12
 *  @abstract Divide the alpha channel from the color channels in a ARGB16Q12 image
 *  @discussion
 *  This function divides color channels by the alpha channel.
 *      For each color channel:
 *      <pre>@textblock
 *          int16_t destColor = ( MIN(src_color, alpha) * 4096 + alpha/2) / alpha;
 *          int16_t destAlpha = alpha;
 *      @/textblock </pre>
 *
 *      ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
 *      In the division by zero case, the returned color value is 0.
 *
 *      The positioning of only the alpha channel is important for interleaved formats for these functions.
 *      This function will work with other channel orders that have alpha first.
 *
 *      This function can work in place provided the following are true:
 *          src->data must be equal to dest->data
 *          src->rowBytes must be equal to dest->rowBytes
 *
 *  @param src          The input inmage
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.9, *)
func vImageUnpremultiplyData_ARGB16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageUnpremultiplyData_RGBA16Q12
 *  @abstract Divide the alpha channel from the color channels in a RGBA16Q12 image
 *  @discussion
 *  This function divides color channels by the alpha channel.
 *      For each color channel:
 *      <pre>@textblock
 *          int16_t destColor = ( MIN(src_color, alpha) * 4096 + alpha/2) / alpha;
 *          int16_t destAlpha = alpha;
 *      @/textblock </pre>
 *
 *      ...which is the nearest unpremultiplied result, with clamping to ensure no modulo overflow in cases where srcColor > srcAlpha.
 *      In the division by zero case, the returned color value is 0.
 *
 *      The positioning of only the alpha channel is important for interleaved formats for these functions.
 *      This function will work with other channel orders that have alpha last. 
 *
 *      This function can work in place provided the following are true:
 *          src->data must be equal to dest->data
 *          src->rowBytes must be equal to dest->rowBytes
 *
 *  @param src          The input inmage
 *  @param dest         A preallocated planar8 destination buffer into which the result will be written.'
 *  @param flags        The following flags are allowed:
 *      <pre>@textblock
 *                      kvImageNoFlags          Default operation
 *
 *                      kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *
 *  @result The following error codes may be returned:
 *      <pre>@textblock
 *                      kvImageNoError                      Success
 *
 *                      kvImageRoiLargerThanInputBuffer     dest->height or width is larger than the corresponding src or alpha dimension
 *      @/textblock </pre>
 */
@available(OSX 10.9, *)
func vImageUnpremultiplyData_RGBA16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedConstAlphaBlend_Planar8
 * @abstract Blend two Planar8 premultiplied images with an extra image-wide alpha for the top image
 * @discussion  This is a premultiplied alpha compositing function using a constant for alpha over the whole image.
 *  Color data from both images is presumed to be already premultiplied by its own per-pixel alpha.
 *      For calculations involving 8-bit integer data, the calculation is done with an additional rounding step
 *      followed by division by 255:
 * <pre>@textblock
 *          uint8_t destColor = (srcTopColor * constAlpha * 255  + (255*255 - srcTopAlpha * constAlpha) * srcBottomColor + 127*255) / (255*255);
 *          uint8_t destAlpha =  (srcTopAlpha * constAlpha * 255 + (255*255 - srcTopAlpha * constAlpha) * srcBottomAlpha + 127*255 ) / (255*255);
 * @/textblock</pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 * @param srcTop        The top image
 * @param constAlpha    An extra alpha to apply to the entire top image
 * @param srcTopAlpha   The alpha channel for the top image
 * @param srcBottom     The bottom image
 * @param dest          A preallocate vImage_Buffer where the result will be written
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageNoFlags          Default operation
 *
 *          kvImageDoNotTile        Turn off internal multithreading
 * @/textblock</pre>
 * @return The following error codes may be returned:
 * <pre>@textblock
 *          kvImageNoError                      Success
 *
 *          kvImageRoiLargerThanInputBuffer     The destination buffer height or width is larger than the corresponding dimension in
 *                                              srcTop, srcTopAlpha or srcBottom
 * @/textblock</pre>
 */
@available(OSX 10.4, *)
func vImagePremultipliedConstAlphaBlend_Planar8(srcTop: UnsafePointer<vImage_Buffer>, _ constAlpha: Pixel_8, _ srcTopAlpha: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedConstAlphaBlend_PlanarF
 * @abstract Blend two PlanarF premultiplied images with an extra image-wide alpha for the top image
 * @discussion  This is a premultiplied alpha compositing function using a constant for alpha over the whole image.
 *  Color data from both images is presumed to be already premultiplied by its own per-pixel alpha.
 * <pre>@textblock
 *          float destColor = srcTopColor * constAlpha  + (1.0 - srcTopAlpha  * constAlpha) * srcBottomColor;
 *          float alpha =  srcTopAlpha * constAlpha + (1.0 - srcTopAlpha * constAlpha) * srcBottomAlpha
 * @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 * @param srcTop        The top image
 * @param constAlpha    An extra alpha to apply to the entire top image
 * @param srcTopAlpha   The alpha channel for the top image
 * @param srcBottom     The bottom image
 * @param dest          A preallocate vImage_Buffer where the result will be written
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageNoFlags          Default operation
 *
 *          kvImageDoNotTile        Turn off internal multithreading
 * @/textblock</pre>
 * @return The following error codes may be returned:
 * <pre>@textblock
 *          kvImageNoError                      Success
 *
 *          kvImageRoiLargerThanInputBuffer     The destination buffer height or width is larger than the corresponding dimension in
 *                                              srcTop, srcTopAlpha or srcBottom
 * @/textblock</pre>
 */
@available(OSX 10.4, *)
func vImagePremultipliedConstAlphaBlend_PlanarF(srcTop: UnsafePointer<vImage_Buffer>, _ constAlpha: Pixel_F, _ srcTopAlpha: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedConstAlphaBlend_ARGB8888
 * @abstract Blend two ARGB8888 premultiplied images with an extra image-wide alpha for the top image
 * @discussion  This is a premultiplied alpha compositing function using a constant for alpha over the whole image.
 *  Color data from both images is presumed to be already premultiplied by its own per-pixel alpha.
 *      For calculations involving 8-bit integer data, the calculation is done with an additional rounding step
 *      followed by division by 255:
 * <pre>@textblock
 *          uint8_t destColor = (srcTopColor * constAlpha * 255  + (255*255 - srcTopAlpha * constAlpha) * srcBottomColor + 127*255) / (255*255);
 *          uint8_t destAlpha =  (srcTopAlpha * constAlpha * 255 + (255*255 - srcTopAlpha * constAlpha) * srcBottomAlpha + 127*255 ) / (255*255);
 * @/textblock</pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The  function will work for all 4 channel 8-bit / channel image formats with alpha first in memory, not just ARGB.
 * @param srcTop        The top image
 * @param constAlpha    An extra alpha to apply to the entire top image
 * @param srcBottom     The bottom image
 * @param dest          A preallocate vImage_Buffer where the result will be written
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageNoFlags          Default operation
 *
 *          kvImageDoNotTile        Turn off internal multithreading
 * @/textblock</pre>
 * @return The following error codes may be returned:
 * <pre>@textblock
 *          kvImageNoError                      Success
 *
 *          kvImageRoiLargerThanInputBuffer     The destination buffer height or width is larger than the corresponding dimension in
 *                                              srcTop, srcTopAlpha or srcBottom
 * @/textblock</pre>
 */
@available(OSX 10.4, *)
func vImagePremultipliedConstAlphaBlend_ARGB8888(srcTop: UnsafePointer<vImage_Buffer>, _ constAlpha: Pixel_8, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImagePremultipliedConstAlphaBlend_ARGBFFFF
 * @abstract Blend two ARGBFFFF premultiplied images with an extra image-wide alpha for the top image
 * @discussion  This is a premultiplied alpha compositing function using a constant for alpha over the whole image.
 *  Color data from both images is presumed to be already premultiplied by its own per-pixel alpha.
 *      For calculations involving 8-bit integer data, the calculation is done with an additional rounding step
 *      followed by division by 255:
 * <pre>@textblock
 *          float destColor = srcTopColor * constAlpha  + (1.0 - srcTopAlpha  * constAlpha) * srcBottomColor;
 *          float alpha =  srcTopAlpha * constAlpha + (1.0 - srcTopAlpha * constAlpha) * srcBottomAlpha
 * @/textblock</pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      The function will work for all 4 channel float / channel image formats with alpha first in memory, not just ARGB.
 * @param srcTop        The top image
 * @param constAlpha    An extra alpha to apply to the entire top image
 * @param srcBottom     The bottom image
 * @param dest          A preallocate vImage_Buffer where the result will be written
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageNoFlags          Default operation
 *
 *          kvImageDoNotTile        Turn off internal multithreading
 * @/textblock</pre>
 * @return The following error codes may be returned:
 * <pre>@textblock
 *          kvImageNoError                      Success
 *
 *          kvImageRoiLargerThanInputBuffer     The destination buffer height or width is larger than the corresponding dimension in
 *                                              srcTop, srcTopAlpha or srcBottom
 * @/textblock</pre>
 */
@available(OSX 10.4, *)
func vImagePremultipliedConstAlphaBlend_ARGBFFFF(srcTop: UnsafePointer<vImage_Buffer>, _ constAlpha: Pixel_F, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageAlphaBlend_NonpremultipliedToPremultiplied_Planar8
 * @abstract Blend a non-premultiplied top Planar8 image into a premultiplied Planar8 bottom image and return a premultiplied Planar8 result.
 * @discussion Top buffer is non-premultiplied. Bottom buffer is premultiplied. Dest buffer is premultiplied. Works in place.
 * <pre>@textblock
 *      result = (srcTop * srctopAlpha + (255 - srcTopAlpha) * bottomAlpha + 127 ) / 255;
 * @/textblock </pre>
 * This function will work in place as long as the src and dest buffer overlap exactly. 
 * The src buffers must be at least as large as the dest buffer in each dimension. (src.height >= dest.height && src.width >= dest.width)
 *
 *  To calculate the alpha result for the Planar cases, use 
 * <pre>@textblock
 *      vImagePremultipliedAlphaBlend_Planar8( srcTopAlpha, srcTopAlpha, srcBottomAlpha, dest, flags );
 * @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 * @param srcTop        Planar8 non-premultiplied color channel for top image
 * @param srcTopAlpha   Planar8 alpha channel for top image
 * @param srcBottom     Planar8 premultiplied color channel for bottom image
 * @param dest          Planar8 premultiplied result. Must be preallocated before the call is made.
 * @param flags         The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading. 
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageAlphaBlend_NonpremultipliedToPremultiplied_Planar8(srcTop: UnsafePointer<vImage_Buffer>, _ srcTopAlpha: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageAlphaBlend_NonpremultipliedToPremultiplied_PlanarF
 * @abstract Blend a non-premultiplied top PlanarF image into a premultiplied PlanarF bottom image and return a premultiplied PlanarF result.
 * @discussion Top buffer is non-premultiplied. Bottom buffer is premultiplied. Dest buffer is premultiplied. Works in place.
 * <pre>@textblock
 *      result = srcTop * srcTopAlpha + (1 - srcTopAlpha) * srcBottom
 * @/textblock </pre>
 * This function will work in place as long as the src and dest buffer overlap exactly.
 * The src buffers must be at least as large as the dest buffer in each dimension. (src.height >= dest.height && src.width >= dest.width)
 *
 *  To calculate the alpha result for the Planar cases, use
 * <pre>@textblock
 *      vImagePremultipliedAlphaBlend_PlanarF( srcTopAlpha, srcTopAlpha, srcBottomAlpha, dest, flags );
 * @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 * @param srcTop        Planar8 non-premultiplied color channel for top image
 * @param srcTopAlpha   Planar8 alpha channel for top image
 * @param srcBottom     Planar8 premultiplied color channel for bottom image
 * @param dest          Planar8 premultiplied result. Must be preallocated before the call is made.
 * @param flags         The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageAlphaBlend_NonpremultipliedToPremultiplied_PlanarF(srcTop: UnsafePointer<vImage_Buffer>, _ srcTopAlpha: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGB8888
 * @abstract Blend a non-premultiplied top ARGB8888 image into a premultiplied ARGB8888 bottom image and return a premultiplied ARGB8888 result.
 * @discussion Top buffer is non-premultiplied. Bottom buffer is premultiplied. Dest buffer is premultiplied. Works in place.
 * <pre>@textblock
 *      result = (srcTop * srctopAlpha + (255 - srcTopAlpha) * bottomAlpha + 127 ) / 255;
 * @/textblock </pre>
 * This function will work in place as long as the src and dest buffer overlap exactly.
 * The src buffers must be at least as large as the dest buffer in each dimension. (src.height >= dest.height && src.width >= dest.width)
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *  This function will work with any channel order with alpha first, not just ARGB.
 *
 * @param srcTop        Planar8 non-premultiplied color channel for top image
 * @param srcBottom     Planar8 premultiplied color channel for bottom image
 * @param dest          Planar8 premultiplied result. Must be preallocated before the call is made.
 * @param flags         The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGB8888(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGBFFFF
 * @abstract Blend a non-premultiplied top ARGBFFFF image into a premultiplied ARGBFFFF bottom image and return a premultiplied ARGBFFFF result.
 * @discussion Top buffer is non-premultiplied. Bottom buffer is premultiplied. Dest buffer is premultiplied. Works in place.
 * <pre>@textblock
 *      result = srcTop * srcTopAlpha + (1 - srcTopAlpha) * srcBottom
 * @/textblock </pre>
 * This function will work in place as long as the src and dest buffer overlap exactly.
 * The src buffers must be at least as large as the dest buffer in each dimension. (src.height >= dest.height && src.width >= dest.width)
 *
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *  This function will work with any channel order with alpha first, not just ARGB.
 *
 * @param srcTop        Planar8 non-premultiplied color channel for top image
 * @param srcBottom     Planar8 premultiplied color channel for bottom image
 * @param dest          Planar8 premultiplied result. Must be preallocated before the call is made.
 * @param flags         The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGBFFFF(srcTop: UnsafePointer<vImage_Buffer>, _ srcBottom: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageClipToAlpha_Planar8
 *  @abstract Clamp a Planar8 color buffer to be less than or equal to alpha
 *  @discussion
 *  For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel. 
 *  <pre>@textblock
 *          color_result = MIN( color, alpha )
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *  @param src      The color image to clip
 *  @param alpha    The alpha channel
 *  @param dest     A preallocated buffer to receive the results.
 *  @param flags    The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageClipToAlpha_Planar8(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageClipToAlpha_PlanarF
 *  @abstract Clamp a PlanarF color buffer to be less than or equal to alpha
 *  @discussion
 *  For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
 *  <pre>@textblock
 *          color_result = MIN( color, alpha )
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *  @param src      The color image to clip
 *  @param alpha    The alpha channel
 *  @param dest     A preallocated buffer to receive the results.
 *  @param flags    The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageClipToAlpha_PlanarF(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageClipToAlpha_ARGB8888
 *  @abstract Clamp a ARGB8888 color buffer to be less than or equal to alpha
 *  @discussion
 *  For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
 *  <pre>@textblock
 *          alpha_result = alpha
 *          color_result = MIN( color, alpha )
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      This function will work for any channel order with alpha first, not just ARGB.
 *
 *  @param src      The color image to clip
 *  @param dest     A preallocated buffer to receive the results.
 *  @param flags    The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageClipToAlpha_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageClipToAlpha_ARGBFFFF
 *  @abstract Clamp a ARGBFFFF color buffer to be less than or equal to alpha
 *  @discussion
 *  For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
 *  <pre>@textblock
 *          alpha_result = alpha
 *          color_result = MIN( color, alpha )
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      This function will work for any channel order with alpha first, not just ARGB.
 *
 *  @param src      The color image to clip
 *  @param dest     A preallocated buffer to receive the results.
 *  @param flags    The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageClipToAlpha_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageClipToAlpha_RGBA8888
 *  @abstract Clamp a RGBA8888 color buffer to be less than or equal to alpha
 *  @discussion
 *  For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
 *  <pre>@textblock
 *          alpha_result = alpha
 *          color_result = MIN( color, alpha )
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      This function will work for any channel order with alpha last, not just RGBA. Also available as vImageClipToAlpha_BGRA8888().
 *
 *  @param src      The color image to clip
 *  @param dest     A preallocated buffer to receive the results.
 *  @param flags    The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.8, *)
func vImageClipToAlpha_RGBA8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageClipToAlpha_RGBAFFFF
 *  @abstract Clamp a RGBAFFFF color buffer to be less than or equal to alpha
 *  @discussion
 *  For each pixel, each color channel shall be set to the smaller of the color channel or alpha value for that pixel.
 *  <pre>@textblock
 *          alpha_result = alpha
 *          color_result = MIN( color, alpha )
 *  @/textblock </pre>
 *      This function can work in place provided the following are true:
 *          For each buffer "buf" that overlaps with dest, buf->data must be equal to dest->data
 *          If an overlapping buffer has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *      This function will work for any channel order with alpha last, not just RGBA. Also available as vImageClipToAlpha_BGRAFFFF().
 *
 *  @param src      The color image to clip
 *  @param dest     A preallocated buffer to receive the results.
 *  @param flags    The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags          Default operation.
 *
 *          kvImageDoNotTile        Disable internal multithreading.
 *      @/textblock </pre>
 *  @result     The following error codes may occur:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->height and dest->width must be less than or equal to corresponding
 *                                              dimensions in srcTop, srcTopAlpha and srcBottom.
 *      @/textblock </pre>
 */
@available(OSX 10.8, *)
func vImageClipToAlpha_RGBAFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
var kvImage_PNG_FILTER_VALUE_NONE: Int { get }
var kvImage_PNG_FILTER_VALUE_SUB: Int { get }
var kvImage_PNG_FILTER_VALUE_UP: Int { get }
var kvImage_PNG_FILTER_VALUE_AVG: Int { get }
var kvImage_PNG_FILTER_VALUE_PAETH: Int { get }
@available(OSX 10.4, *)
func vImagePNGDecompressionFilter(buffer: UnsafePointer<vImage_Buffer>, _ startScanline: vImagePixelCount, _ scanlineCount: vImagePixelCount, _ bitsPerPixel: UInt32, _ filterMethodNumber: UInt32, _ filterType: UInt32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageClip_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: Pixel_F, _ minFloat: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_Planar8toPlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: Pixel_F, _ minFloat: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_PlanarFtoPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: Pixel_F, _ minFloat: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageConvert_PlanarFtoPlanar8_dithered
 *
 * @abstract Convert an array of floating point data to 8 bit integer data with dithering. 
 *
 * @discussion For each pixel, do the following:
 *
 *          <pre>
 *          @textblock
 *         uint8_t result = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel - minFloat ) / (maxFloat - minFloat) + random_float[0,1) );
 *          @/textblock
 *          </pre>
 *
 *         Caution: unlike vImageConvert_PlanarFtoPlanar8, vImageConvert_PlanarFtoPlanar8_dithered usually should not be used for 
 *                  multichannel data. Otherwise the dithering will occur in the chrominance dimensions and the noise will cause
 *                  grain with varying hue.
 *
 *      This function can work in place provided the following are true:
 *          if src overlaps with dest,
 *                  src->data must be equal to dest->data and src->rowBytes >= dest->rowBytes
 *          If an overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *
 *
 * @param src               A pointer to a valid and initialized vImage_Buffer struct, that points to a buffer containing the source pixels.
 *
 * @param dest              A pointer to a valid and initialized vImage_Buffer struct, that points to a allocated buffer to receive the result pixels.
 *
 * @param maxFloat          The encoding for 1.0 in the src buffer, full intensity. Typically, this is 1.0 for floating-point data in the range[0,1] but if your data is [0,65535] then you would pass 65535.0f here.
 *
 * @param minFloat          The encoding for 0.0 in the src buffer, no light.  Typically this is 0.0 for floating-point data in the range [0,1], but if your data is [-.5,0.5] then you would pass -0.5f here.
 *
 * @param dither            The type of random noise to use for the dither. The following values are accepted:
 *
 *          <pre>
 *          @textblock
 *                  kvImageConvert_DitherNone - Same as vImageConvert_PlanarFtoPlanar8().  Rounds to nearest.
 *
 *                  kvImageConvert_DitherOrdered - pre-computed blue noise is added to the image before rounding to the values in
 *                      the destination format.  The offset into this blue noise is randomized per-call to avoid visible artifacts
 *                      if you do your own tiling or call the function on sequential frames of video.
 *
 *                  kvImageConvert_DitherOrderedReproducible - pre-computed blue noise is added to the image before rounding to the
 *                      values in the destination format.  The offset into the blue noise is the same for every call to allow users
 *                      to get reproducible results. Fine for still images. For video kvImageConvert_DitherOrdered is a better choice.
 *          @/textblock
 *          </pre>
 *                  The ordered dither methods may be further influenced by shaping the distribution of the noise using the gaussian and uniform options below.
 *                  These options are OR-ed with kvImageConvert_DitherOrdered / kvImageConvert_DitherOrderedReproducible:
 *          <pre>
 *          @textblock
 *                  kvImageConvert_OrderedGaussianBlue - when using an ordered dither pattern, distribute the noise according to a gaussian
 *                      distribution. This generally gives more pleasing images --  less noisy and perhaps a little more saturated -- but color
 *                      fidelity can suffer. Its effect is between kvImageConvert_DitherNone and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
 *                      This is the default for kvImageConvert_DitherOrdered and kvImageConvert_DitherOrderedReproducible.
 *
 *                  kvImageConvert_OrderedUniformBlue - when using an ordered dither pattern, distribute the noise uniformly. This generally gives
 *                      best color fidelity, but the resulting image is noisier and more obviously dithered. This is usually the best choice when low
 *                      bitdepth content is drawn next to high bitdepth content and in other circumstances where subtle changes to color arising from the conversion
 *                      could be easily noticed. It may be a poor choice when the image is likely to be enlarged -- this would cause the noise to become
 *                      more evident-- and for very flat / synthetic content with little inherent noise. The enlargement problem may be avoided by enlarging
 *                      first at high bitdepth, then convert to lower bitdepth.
 *          @/textblock
 *          </pre>
 *
 *                  To clarify: "Blue" noise does not look blue, nor does it operate solely on the blue color channel. Blue noise is monochrome noise that is added to all color
 *                  channels equally. The name arises from blue light, which has a higher frequency than other colors of visible light. Thus, blue noise is noise which is
 *                  weighted heavily towards high frequencies. Low frequency noise tends to have visible shapes in it that would become apparent in an image if it was added in,
 *                  so it is excluded from the dither pattern.
 *
 * @param   flags       The following flags are honored:
 *          <pre>
 *          @textblock
 *                      kvImageNoFlags              Default operation
 *
 *                      kvImageDoNotTile            Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
 *                                                  
 *                      kvImageGetTempBufferSize    Returns 0.  Does no work. Does not touch data.
 *
 *          @/textblock
 *          </pre>
 *
 *
 * @return  The following error codes may be returned:
 *
 *          <pre>
 *          @textblock
 *              kvImageNoError                      Success
 *
 *              kvImageRoiLargerThanInputBuffer     The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
 *
 *              kvImageUnknownFlagsBit              Not all vImage flags are understood by this function. See description of flags parameter for supported flags. 
 *
 *              kvImageInvalidParameter             An unknown / unsupported dithering mode was requested.
 *          @/textblock
 *          </pre>
 *
 *
 * 
 */
@available(OSX 10.10, *)
func vImageConvert_PlanarFtoPlanar8_dithered(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: Pixel_F, _ minFloat: Pixel_F, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageConvert_RGBFFFtoRGB888_dithered
 *
 * @abstract Convert an array of floating point data to 8 bit integer data with dithering.
 *
 * @discussion For each pixel, do the following:
 *
 *          <pre>
 *          @textblock
 *          // convert to uint8_t
 *          result[0] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[0] - minFloat[0] ) / (maxFloat[0] - minFloat[0]) + random_float[0,1) );
 *          result[1] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[1] - minFloat[1] ) / (maxFloat[1] - minFloat[1]) + random_float[0,1) );
 *          result[2] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[2] - minFloat[2] ) / (maxFloat[2] - minFloat[2]) + random_float[0,1) );
 *
 *          @/textblock
 *          </pre>
 *
 *          This function will work for other channel orders, such as BGR, and other colorspaces such as L*a*b*.
 *          If you need to change channel orders, please see vImagePermuteChannels_RGB888().
 *
 *      This function can work in place provided the following are true:
 *          if src overlaps with dest,
 *                  src->data must be equal to dest->data and src->rowBytes >= dest->rowBytes
 *          If an overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *
 *
 * @param src               A pointer to a valid and initialized vImage_Buffer struct that points to a buffer containing the source pixels.
 *
 * @param dest              A pointer to a valid and initialized vImage_Buffer struct that points to a allocated buffer to receive the result pixels.
 *
 * @param maxFloat          The encoding for 1.0 in the src buffer, full intensity. Typically, this is 1.0 for floating-point data in the range[0,1] but if your data is [0,65535] then you would pass 65535.0f here.
 *                          A separate value is provided for each of the four channels.
 *
 * @param minFloat          The encoding for 0.0 in the src buffer, no light.  Typically this is 0.0 for floating-point data in the range [0,1], but if your data is [-.5,0.5] then you would pass -0.5f here.
 *                          A separate value is provided for each of the four channels.
 *
 * @param dither            The type of random noise to use for the dither. The following values are accepted:
 *
 *          <pre>
 *          @textblock
 *                  kvImageConvert_DitherNone - Rounds to nearest.
 *
 *                  kvImageConvert_DitherOrdered - pre-computed blue noise is added to the image before rounding to the values in
 *                      the destination format.  The offset into this blue noise is randomized per-call to avoid visible artifacts
 *                      if you do your own tiling or call the function on sequential frames of video.
 *
 *                  kvImageConvert_DitherOrderedReproducible - pre-computed blue noise is added to the image before rounding to the
 *                      values in the destination format.  The offset into the blue noise is the same for every call to allow users
 *                      to get reproducible results. Fine for still images. For video kvImageConvert_DitherOrdered is a better choice.
 *          @/textblock
 *          </pre>
 *                  The ordered dither methods may be further influenced by shaping the distribution of the noise using the gaussian and uniform options below.
 *                  These options are OR-ed with kvImageConvert_DitherOrdered / kvImageConvert_DitherOrderedReproducible:
 *          <pre>
 *          @textblock
 *                  kvImageConvert_OrderedGaussianBlue - when using an ordered dither pattern, distribute the noise according to a gaussian
 *                      distribution. This generally gives more pleasing images --  less noisy and perhaps a little more saturated -- but color
 *                      fidelity can suffer. Its effect is between kvImageConvert_DitherNone and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
 *                      This is the default for kvImageConvert_DitherOrdered and kvImageConvert_DitherOrderedReproducible.
 *
 *                  kvImageConvert_OrderedUniformBlue - when using an ordered dither pattern, distribute the noise uniformly. This generally gives
 *                      best color fidelity, but the resulting image is noisier and more obviously dithered. This is usually the best choice when low
 *                      bitdepth content is drawn next to high bitdepth content and in other circumstances where subtle changes to color arising from the conversion
 *                      could be easily noticed. It may be a poor choice when the image is likely to be enlarged -- this would cause the noise to become
 *                      more evident-- and for very flat / synthetic content with little inherent noise. The enlargement problem may be avoided by enlarging
 *                      first at high bitdepth, then convert to lower bitdepth.
 *          @/textblock
 *          </pre>
 *
 *                  To clarify: "Blue" noise does not look blue, nor does it operate solely on the blue color channel. Blue noise is monochrome noise that is added to all color
 *                  channels equally. The name arises from blue light, which has a higher frequency than other colors of visible light. Thus, blue noise is noise which is
 *                  weighted heavily towards high frequencies. Low frequency noise tends to have visible shapes in it that would become apparent in an image if it was added in,
 *                  so it is excluded from the dither pattern.
 *
 * @param   flags       The following flags are honored:
 *          <pre>
 *          @textblock
 *                      kvImageNoFlags              Default operation
 *
 *                      kvImageDoNotTile            Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
 *
 *                      kvImageGetTempBufferSize    Returns 0.  Does no work. Does not touch data.
 *
 *          @/textblock
 *          </pre>
 *
 *
 * @return  The following error codes may be returned:
 *
 *          <pre>
 *          @textblock
 *              kvImageNoError                      Success
 *
 *              kvImageRoiLargerThanInputBuffer     The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
 *
 *              kvImageUnknownFlagsBit              Not all vImage flags are understood by this function. See description of flags parameter for supported flags.
 *
 *              kvImageInvalidParameter             An unknown / unsupported dithering mode was requested.
 *          @/textblock
 *          </pre>
 *
 *
 * 
 */
@available(OSX 10.10, *)
func vImageConvert_RGBFFFtoRGB888_dithered(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Pixel_F>, _ minFloat: UnsafePointer<Pixel_F>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageConvert_ARGBFFFFtoARGB8888_dithered
 *
 * @abstract Convert an array of floating point data to 8 bit integer data with dithering.
 *
 * @discussion For each pixel, do the following:
 *
 *          <pre>
 *          @textblock
 *          // convert to uint8_t
 *          Pixel_8888 temp;
 *          temp[0] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[0] - minFloat[0] ) / (maxFloat[0] - minFloat[0]) + random_float[0,1) );
 *          temp[1] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[1] - minFloat[1] ) / (maxFloat[1] - minFloat[1]) + random_float[0,1) );
 *          temp[2] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[2] - minFloat[2] ) / (maxFloat[2] - minFloat[2]) + random_float[0,1) );
 *          temp[3] = SATURATED_CLIP_0_to_255( 255.0f * ( srcPixel[3] - minFloat[3] ) / (maxFloat[3] - minFloat[3]) + random_float[0,1) );
 *
 *          // place in requested output order
 *          Pixel_8888 result;
 *          result[0] = temp[permuteMap[0]];
 *          result[1] = temp[permuteMap[1]];
 *          result[2] = temp[permuteMap[2]];
 *          result[3] = temp[permuteMap[3]];
 *          @/textblock
 *          </pre>
 *
 *         This function will work for other channel orders, such as RGBA and BGRA.
 *
 *      This function can work in place provided the following are true:
 *          if src overlaps with dest,
 *                  src->data must be equal to dest->data and src->rowBytes >= dest->rowBytes
 *          If an overlapping src has a different rowBytes from dest, kvImageDoNotTile must be also passed in the flags
 *
 *
 *
 * @param src               A pointer to a valid and initialized vImage_Buffer struct that points to a buffer containing the source pixels.
 *
 * @param dest              A pointer to a valid and initialized vImage_Buffer struct that points to a allocated buffer to receive the result pixels.
 *
 * @param maxFloat          The encoding for 1.0 in the src buffer, full intensity. Typically, this is 1.0 for floating-point data in the range[0,1] but if your data is [0,65535] then you would pass 65535.0f here.
 *                          A separate value is provided for each of the four channels.
 *
 * @param minFloat          The encoding for 0.0 in the src buffer, no light.  Typically this is 0.0 for floating-point data in the range [0,1], but if your data is [-.5,0.5] then you would pass -0.5f here.
 *                          A separate value is provided for each of the four channels.
 *
 * @param dither            The type of random noise to use for the dither. The following values are accepted:
 *
 *          <pre>
 *          @textblock
 *                  kvImageConvert_DitherNone - Rounds to nearest.
 *
 *                  kvImageConvert_DitherOrdered - pre-computed blue noise is added to the image before rounding to the values in
 *                      the destination format.  The offset into this blue noise is randomized per-call to avoid visible artifacts
 *                      if you do your own tiling or call the function on sequential frames of video.
 *
 *                  kvImageConvert_DitherOrderedReproducible - pre-computed blue noise is added to the image before rounding to the
 *                      values in the destination format.  The offset into the blue noise is the same for every call to allow users
 *                      to get reproducible results. Fine for still images. For video kvImageConvert_DitherOrdered is a better choice.
 *          @/textblock
 *          </pre>
 *                  The ordered dither methods may be further influenced by shaping the distribution of the noise using the gaussian and uniform options below.
 *                  These options are OR-ed with kvImageConvert_DitherOrdered / kvImageConvert_DitherOrderedReproducible:
 *          <pre>
 *          @textblock
 *                  kvImageConvert_OrderedGaussianBlue - when using an ordered dither pattern, distribute the noise according to a gaussian
 *                      distribution. This generally gives more pleasing images --  less noisy and perhaps a little more saturated -- but color
 *                      fidelity can suffer. Its effect is between kvImageConvert_DitherNone and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
 *                      This is the default for kvImageConvert_DitherOrdered and kvImageConvert_DitherOrderedReproducible.
 *
 *                  kvImageConvert_OrderedUniformBlue - when using an ordered dither pattern, distribute the noise uniformly. This generally gives
 *                      best color fidelity, but the resulting image is noisier and more obviously dithered. This is usually the best choice when low
 *                      bitdepth content is drawn next to high bitdepth content and in other circumstances where subtle changes to color arising from the conversion
 *                      could be easily noticed. It may be a poor choice when the image is likely to be enlarged -- this would cause the noise to become
 *                      more evident-- and for very flat / synthetic content with little inherent noise. The enlargement problem may be avoided by enlarging
 *                      first at high bitdepth, then convert to lower bitdepth.
 *          @/textblock
 *          </pre>
 *
 *                  To clarify: "Blue" noise does not look blue, nor does it operate solely on the blue color channel. Blue noise is monochrome noise that is added to all color
 *                  channels equally. The name arises from blue light, which has a higher frequency than other colors of visible light. Thus, blue noise is noise which is
 *                  weighted heavily towards high frequencies. Low frequency noise tends to have visible shapes in it that would become apparent in an image if it was added in,
 *                  so it is excluded from the dither pattern.
 *
 * @param   permuteMap  A 4 element array giving the order of the result channels.  This allows you to convert a ARGB float buffer to a BGRA result buffer by providing the
 *                      order {3,2,1,0}.
 *
 * @param   flags       The following flags are honored:
 *          <pre>
 *          @textblock
 *                      kvImageNoFlags              Default operation
 *
 *                      kvImageDoNotTile            Disable internal multithreading.  You should use this if you are doing your own threading / tiling.
 *
 *                      kvImageGetTempBufferSize    Returns 0.  Does no work. Does not touch data.
 *
 *          @/textblock
 *          </pre>
 *
 *
 * @return  The following error codes may be returned:
 *
 *          <pre>
 *          @textblock
 *              kvImageNoError                      Success
 *
 *              kvImageRoiLargerThanInputBuffer     The height and width of the destination must be less than or equal to the height and width of the src buffer, respectively.
 *
 *              kvImageUnknownFlagsBit              Not all vImage flags are understood by this function. See description of flags parameter for supported flags.
 *
 *              kvImageInvalidParameter             An unknown / unsupported dithering mode was requested.
 *          @/textblock
 *          </pre>
 *
 *
 * 
 */
@available(OSX 10.10, *)
func vImageConvert_ARGBFFFFtoARGB8888_dithered(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ dither: Int32, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_Planar8toARGB8888(srcA: UnsafePointer<vImage_Buffer>, _ srcR: UnsafePointer<vImage_Buffer>, _ srcG: UnsafePointer<vImage_Buffer>, _ srcB: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_PlanarFtoARGBFFFF(srcA: UnsafePointer<vImage_Buffer>, _ srcR: UnsafePointer<vImage_Buffer>, _ srcG: UnsafePointer<vImage_Buffer>, _ srcB: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_ARGB8888toPlanar8(srcARGB: UnsafePointer<vImage_Buffer>, _ destA: UnsafePointer<vImage_Buffer>, _ destR: UnsafePointer<vImage_Buffer>, _ destG: UnsafePointer<vImage_Buffer>, _ destB: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_ARGBFFFFtoPlanarF(srcARGB: UnsafePointer<vImage_Buffer>, _ destA: UnsafePointer<vImage_Buffer>, _ destR: UnsafePointer<vImage_Buffer>, _ destG: UnsafePointer<vImage_Buffer>, _ destB: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_ChunkyToPlanar8(srcChannels: UnsafeMutablePointer<UnsafePointer<Void>>, _ destPlanarBuffers: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ channelCount: UInt32, _ srcStrideBytes: Int, _ srcWidth: vImagePixelCount, _ srcHeight: vImagePixelCount, _ srcRowBytes: Int, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_PlanarToChunky8(srcPlanarBuffers: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ destChannels: UnsafeMutablePointer<UnsafeMutablePointer<Void>>, _ channelCount: UInt32, _ destStrideBytes: Int, _ destWidth: vImagePixelCount, _ destHeight: vImagePixelCount, _ destRowBytes: Int, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_ChunkyToPlanarF(srcChannels: UnsafeMutablePointer<UnsafePointer<Void>>, _ destPlanarBuffers: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ channelCount: UInt32, _ srcStrideBytes: Int, _ srcWidth: vImagePixelCount, _ srcHeight: vImagePixelCount, _ srcRowBytes: Int, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_PlanarToChunkyF(srcPlanarBuffers: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ destChannels: UnsafeMutablePointer<UnsafeMutablePointer<Void>>, _ channelCount: UInt32, _ destStrideBytes: Int, _ destWidth: vImagePixelCount, _ destHeight: vImagePixelCount, _ destRowBytes: Int, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_16SToF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ offset: Float, _ scale: Float, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_16UToF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ offset: Float, _ scale: Float, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_FTo16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ offset: Float, _ scale: Float, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageConvert_FTo16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ offset: Float, _ scale: Float, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_16Uto16F(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_16Fto16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageTableLookUp_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ alphaTable: UnsafePointer<Pixel_8>, _ redTable: UnsafePointer<Pixel_8>, _ greenTable: UnsafePointer<Pixel_8>, _ blueTable: UnsafePointer<Pixel_8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageTableLookUp_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ table: UnsafePointer<Pixel_8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageOverwriteChannels_ARGB8888(newSrc: UnsafePointer<vImage_Buffer>, _ origSrc: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageOverwriteChannels_ARGBFFFF(newSrc: UnsafePointer<vImage_Buffer>, _ origSrc: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageOverwriteChannelsWithScalar_Planar8(scalar: Pixel_8, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageOverwriteChannelsWithScalar_PlanarF(scalar: Pixel_F, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageOverwriteChannelsWithScalar_Planar16S(scalar: Pixel_16S, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageOverwriteChannelsWithScalar_Planar16U(scalar: Pixel_16U, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageExtractChannel_ARGB8888
 *
 *  @abstract Extract one channel from a 4-channel interleaved 8-bit per component buffer
 *
 *  @discussion  This is the opposite operation from vImageOverwriteChannels_ARGB8888. It reads one component
 *               from the four channel 8-bit per component buffer and writes it into a Planar8 buffer.
 *
 *               <pre>@textblock
 *
 *                  for each pixel i in src:
 *
 *                      Pixel_8888 *src_pixel;
 *                      Pixel_8 *dest_pixel;
 *
 *                      dest_pixel[i] = src_pixel[i][channelIndex];
 *
 *               @/textblock </pre>
 *
 *
 *  @param       src        A valid pointer to a vImage_Buffer struct which describes a 8-bit per component, four channel buffer.
 *                          It does not have to be ARGB8888. It can be BGRA, RGBA, CMYK, etc.
 *
 *  @param       dest       A valid pointer to a vImage_Buffer struct which describes a 8-bit per component, one channel buffer.
 *                          The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the 
 *                          channels.  This function does work in place, so long as the rowBytes is the same for src and dest
 *                          images and the start address also matches.
 *
 *  @param       channelIndex   The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.
 *
 *  @param       flags      The following flags are allowed:  kvImageDoNotTile, kvImageGetTempBufferSize, kvImageNoFlags, kvImagePrintDiagnosticsToConsole
 *
 *  @result      The following errors may be returned:
 *
 *               <pre>@textblock
 *
 *                  kvImageNoError                      Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.
 *
 *                      0                               If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.
 *
 *                  kvImageRoiLargerThanInputBuffer     The destination height or width is larger than the src height or width, respectively.
 *
 *                  kvImageUnknownFlagsBit              A flag was used which was not among the approved set of flags. See flags param description above.
 *
 *                  kvImageInvalidParameter             channelIndex must be in the range [0,3]
 *
 *               @/textblock </pre>
 *
 * 
 */
@available(OSX 10.10, *)
func vImageExtractChannel_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ channelIndex: Int, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageExtractChannel_ARGB16U
 *
 *  @abstract Extract one channel from a 4-channel interleaved 16-bit per component buffer. 
 *
 *  @discussion  vImageExtractChannel_ARGB16U reads one component from the four channel 16-bit per component buffer 
 *                  and writes it into a Planar16U buffer.  Since this just copies data around, the data may be any 
 *                  16-bit per component data type, including signed 16 bit integers and half-precision floating point,
 *                  of any endianness. Likewise, the channel order does not need to be ARGB. RGBA, BGRA, CMYK, etc. all work.
 *
 *               <pre>@textblock
 *
 *                  for each pixel i in src:
 *
 *                      Pixel_ARGB_16U *src_pixel;
 *                      Pixel_16U *dest_pixel;
 *
 *                      dest_pixel[i] = src_pixel[i][channelIndex];
 *
 *               @/textblock </pre>
 *
 *
 *  @param       src        A valid pointer to a vImage_Buffer struct which describes a 16-bit per component, four channel buffer.
 *                          It does not have to be ARGB16U. It can be BGRA, RGBA, CMYK, etc. The data can be any 16-bit per component
 *                          type such as int16_t or half-precision floating-point. Data must be at least 2-byte aligned.
 *
 *  @param       dest       A valid pointer to a vImage_Buffer struct which describes a 16-bit per component, one channel buffer.
 *                          The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the
 *                          channels.  This function does work in place, so long as the rowBytes is the same for src and dest
 *                          images and the start address also matches. The data returned will be in the same format (uint16_t, 
 *                          int16_t, half-float, etc.) as the data provided in the src format, except that only a single channel
 *                          is present. Data must be at least 2-byte aligned.
 *
 *  @param       channelIndex   The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.
 *
 *  @param       flags      The following flags are allowed:  kvImageDoNotTile, kvImageGetTempBufferSize, kvImageNoFlags, kvImagePrintDiagnosticsToConsole
 *
 *  @result      The following errors may be returned:
 *
 *               <pre>@textblock
 *
 *                  kvImageNoError                      Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.
 *
 *                      0                               If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.
 *
 *                  kvImageRoiLargerThanInputBuffer     The destination height or width is larger than the src height or width, respectively.
 *
 *                  kvImageUnknownFlagsBit              A flag was used which was not among the approved set of flags. See flags param description above.
 *
 *                  kvImageInvalidParameter             channelIndex must be in the range [0,3]
 *
 *               @/textblock </pre>
 *
 * 
 */
@available(OSX 10.10, *)
func vImageExtractChannel_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ channelIndex: Int, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageExtractChannel_ARGBFFFF
 *
 *  @abstract Extract one channel from a 4-channel interleaved 32-bit per component buffer
 *
 *  @discussion  This is the opposite operation from vImageOverwriteChannels_ARGBFFFF. It reads one component
 *               from the four channel 32-bit per component buffer and writes it into a PlanarF buffer. NaNs and 
 *               and sNaNs are not modified. Sign of zero shall be preserved.
 *
 *               <pre>@textblock
 *
 *                  for each pixel i in src:
 *
 *                      Pixel_FFFF *src_pixel;
 *                      Pixel_F *dest_pixel;
 *
 *                      dest_pixel[i] = src_pixel[i][channelIndex];
 *
 *               @/textblock </pre>
 *
 *
 *  @param       src        A valid pointer to a vImage_Buffer struct which describes a 32-bit per component, four channel buffer.
 *                          It does not have to be ARGBFFFF. It can be BGRA, RGBA, CMYK, etc. of any endianness. Data must be at 
 *                          least 4-byte aligned.
 *
 *  @param       dest       A valid pointer to a vImage_Buffer struct which describes a 32-bit per component, one channel buffer.
 *                          The buffer pointed to by dest should be allocated by you. It will be overwritten with one of the
 *                          channels.  This function does work in place, so long as the rowBytes is the same for src and dest
 *                          images and the start address also matches. Data must be at least 4 byte aligned.
 *
 *  @param       channelIndex   The index of the channel to extract. For alpha in a ARGB image, this is 0.  For alpha in a BGRA image, this is 3.
 *
 *  @param       flags      The following flags are allowed:  kvImageDoNotTile, kvImageGetTempBufferSize, kvImageNoFlags, kvImagePrintDiagnosticsToConsole
 *
 *  @result      The following errors may be returned:
 *
 *               <pre>@textblock
 *
 *                  kvImageNoError                      Success. However, see also 0 below, if the kvImageGetTempBufferSize flag is passed.
 *
 *                      0                               If the kvImageGetTempBufferSize flag is passed, this function returns 0 and does no work.
 *
 *                  kvImageRoiLargerThanInputBuffer     The destination height or width is larger than the src height or width, respectively.
 *
 *                  kvImageUnknownFlagsBit              A flag was used which was not among the approved set of flags. See flags param description above.
 *
 *                  kvImageInvalidParameter             channelIndex must be in the range [0,3]
 *
 *               @/textblock </pre>
 *
 * 
 */
@available(OSX 10.10, *)
func vImageExtractChannel_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ channelIndex: Int, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageBufferFill_ARGB8888(dest: UnsafePointer<vImage_Buffer>, _ color: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageBufferFill_ARGB16U(dest: UnsafePointer<vImage_Buffer>, _ color: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageBufferFill_ARGB16S(dest: UnsafePointer<vImage_Buffer>, _ color: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageBufferFill_ARGBFFFF(dest: UnsafePointer<vImage_Buffer>, _ color: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageOverwriteChannelsWithScalar_ARGB8888(scalar: Pixel_8, _ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageOverwriteChannelsWithScalar_ARGBFFFF(scalar: Pixel_F, _ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImagePermuteChannels_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePermuteChannels_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImagePermuteChannels_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePermuteChannelsWithMaskedInsert_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ copyMask: UInt8, _ backgroundColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePermuteChannelsWithMaskedInsert_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ copyMask: UInt8, _ backgroundColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGB8888toPlanarF(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGBFFFFtoPlanar8(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGBFFFFtoRGBFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGBAFFFFtoRGBFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_BGRAFFFFtoRGBFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGBFFFtoARGBFFFF(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: Pixel_F, _: UnsafePointer<vImage_Buffer>, _: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGBFFFtoRGBAFFFF(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: Pixel_F, _: UnsafePointer<vImage_Buffer>, _: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGBFFFtoBGRAFFFF(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: Pixel_F, _: UnsafePointer<vImage_Buffer>, _: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_ARGB1555toPlanar8(src: UnsafePointer<vImage_Buffer>, _ destA: UnsafePointer<vImage_Buffer>, _ destR: UnsafePointer<vImage_Buffer>, _ destG: UnsafePointer<vImage_Buffer>, _ destB: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_ARGB1555toARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_Planar8toARGB1555(srcA: UnsafePointer<vImage_Buffer>, _ srcR: UnsafePointer<vImage_Buffer>, _ srcG: UnsafePointer<vImage_Buffer>, _ srcB: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_ARGB8888toARGB1555(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_RGB565toARGB8888(alpha: Pixel_8, _ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGB565toRGBA8888(alpha: Pixel_8, _ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGB565toBGRA8888(alpha: Pixel_8, _ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageConvert_RGB565toRGB888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_ARGB8888toRGB565(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGBA8888toRGB565(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_BGRA8888toRGB565(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_RGB565toPlanar8(src: UnsafePointer<vImage_Buffer>, _ destR: UnsafePointer<vImage_Buffer>, _ destG: UnsafePointer<vImage_Buffer>, _ destB: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_Planar8toRGB565(srcR: UnsafePointer<vImage_Buffer>, _ srcG: UnsafePointer<vImage_Buffer>, _ srcB: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageConvert_RGBA5551toRGB565
 * @abstract Convert from RGBA5551 to RGB565 image format
 * @discussion  Convert (with loss of alpha) from RGBA5551 to RGB565 format.
 *              If you need something fancier done with alpha first, such as unpremultiplication or flattening, convert to 8 bit per channel first. 
 *              Both RGB565 and RGBA5551 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
 *              little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
 *
 * @param src           A pointer to a vImage_Buffer struct which describes a memory region full of RGBA5551 pixels
 *
 * @param dest          A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGB565 pixels
 *
 * @param flags           The following flags are understood by this function:
 *
 *          <pre>
 *          @textblock
 *          kvImageNoFlags                      Default operation.
 *
 *          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
 *                                              many such operations going concurrently, and in cases where it is desirable to keep
 *                                              CPU utilization to a single core.
 *
 *          kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
 *          @/textblock
 *          </pre>
 *
 * @return 
 *          <pre>
 *          @textblock
 *          kvImageNoError                          Success
 *
 *          kvImageBufferSizeMismatch               dest->height > src->height OR dest->width > src->width.  There are not enough pixels to fill the destination buffer.
 *          @/textblock
 *          </pre>
 *
 * 
 */
@available(OSX 10.10, *)
func vImageConvert_RGBA5551toRGB565(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageConvert_ARGB1555toRGB565
 * @abstract Convert from ARGB1555 to RGB565 image format
 * @discussion  Convert (with loss of alpha) from ARGB1555 to RGB565 format.
 *              If you need something fancier done with alpha first, such as unpremultiplication or flattening, convert to 8 bit per channel first.
 *              Both RGB565 and ARGB1555 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
 *              little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
 *
 * @param src           A pointer to a vImage_Buffer struct which describes a memory region full of ARGB1555 pixels
 *
 * @param dest          A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGB565 pixels
 *
 * @param flags           The following flags are understood by this function:
 *
 *          <pre>
 *          @textblock
 *          kvImageNoFlags                      Default operation.
 *
 *          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
 *                                              many such operations going concurrently, and in cases where it is desirable to keep
 *                                              CPU utilization to a single core.
 *
 *          kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
 *          @/textblock
 *          </pre>
 *
 * @return
 *          <pre>
 *          @textblock
 *          kvImageNoError                          Success
 *
 *          kvImageBufferSizeMismatch               dest->height > src->height OR dest->width > src->width.  There are not enough pixels to fill the destination buffer.
 *          @/textblock
 *          </pre>
 *
 * 
 */
@available(OSX 10.10, *)
func vImageConvert_ARGB1555toRGB565(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageConvert_RGB565toRGBA5551
 * @abstract Convert from RGB565 to RGBA5551 image format
 * @discussion  Convert from RGB565 to RGBA5551 format.  The new alpha is set to 1.
 *              Both RGB565 and RGBA5551 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
 *              little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
 *
 * @param src           A pointer to a vImage_Buffer struct which describes a memory region full of RGB565 pixels
 *
 * @param dest          A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by RGBA5551 pixels
 *
 * @param dither        A dithering method for the green channel.   Options:
 *
 *                  kvImageConvert_DitherNone - apply no dithering; input values
 *                      are rounded to the nearest value representable in the
 *                      destination format.
 *                  kvImageConvert_DitherOrdered - pre-computed blue noise is
 *                      added to the image before rounding to the values in
 *                      the destination format.  The offset into this blue
 *                      noise is randomized per-call to avoid visible artifacts
 *                      if you do your own tiling or call the function on
 *                      sequential frames of video.
 *                  kvImageConvert_DitherOrderedReproducible - pre-computed
 *                      blue noise is added to the image before rounding to the
 *                      values in the destination format.  The offset into the
 *                      blue noise is the same for every call to allow users
 *                      to get reproducible results.
 *
 *                  The ordered dither methods may be further influenced by shaping the
 *                  distribution of the noise using the gaussian and uniform options below.
 *                  These options are OR-ed with kvImageConvert_DitherOrdered / kvImageCon-
 *                  vert_DitherOrderedReproducible:
 *
 *                  kvImageConvert_OrderedGaussianBlue - when using an ordered dither
 *                      pattern, distribute the noise according to a gaussian
 *                      distribution. This generally gives more pleasing images --
 *                      less noisy and perhaps a little more saturated -- but color
 *                      fidelity can suffer. Its effect is between kvImageConvert_DitherNone
 *                      and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
 *                      This is the default for kvImageConvert_DitherOrdered and
 *                      kvImageConvert_DitherOrderedReproducible.
 *
 *                  kvImageConvert_OrderedUniformBlue - when using an ordered dither
 *                      pattern, distribute the noise uniformly. This generally gives
 *                      best color fidelity, but the resulting image is noisier and more
 *                      obviously dithered. This is usually the best choice when low
 *                      bitdepth content is drawn next to high bitdepth content and in other
 *                      circumstances where subtle changes to color arising from the conversion
 *                      could be easily noticed. It may be a poor choice when the image
 *                      is likely to be enlarged -- this would cause the noise to become
 *                      more evident-- and for very flat / synthetic content with little
 *                      inherent noise. The enlargement problem may be avoided by enlarging
 *                      first at high bitdepth, then convert to lower bitdepth.
 *
 *                  To clarify: "Blue" noise is not blue, nor does it operate solely on the blue
 *                  color channel. Blue noise is monochrome noise that is added to all color
 *                  channels equally. The name arises from blue light, which has a higher frequency
 *                  than other colors of visible light. Thus, blue noise is noise which is
 *                  weighted heavily towards high frequencies. Low frequency noise tends to have
 *                  visible shapes in it that would become apparent in an image if it was added in,
 *                  so it is excluded from the dither pattern.
 *
 * @param flags           The following flags are understood by this function:
 *
 *          <pre>
 *          @textblock
 *          kvImageNoFlags                      Default operation.
 *
 *          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
 *                                              many such operations going concurrently, and in cases where it is desirable to keep
 *                                              CPU utilization to a single core.
 *
 *          kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
 *          @/textblock
 *          </pre>
 *
 * @return
 *          <pre>
 *          @textblock
 *          kvImageNoError                          Success
 *
 *          kvImageBufferSizeMismatch               dest->height > src->height OR dest->width > src->width.  There are not enough pixels to fill the destination buffer.
 *
 *          kvImageInvalidParameter                 Invalid / unknown dither value
 *          @/textblock
 *          </pre>
 *
 * 
 */
@available(OSX 10.10, *)
func vImageConvert_RGB565toRGBA5551(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageConvert_RGB565toARGB1555
 * @abstract Convert from RGB565 to ARGB1555 image format
 * @discussion  Convert from RGB565 to ARGB1555 format.  The new alpha is set to 1.
 *              Both RGB565 and ARGB1555 are defined by vImage to be host-endian formats. On Intel and ARM and other little endian systems, these are
 *              little endian uint16_t's in memory. On a big endian system, these are big endian uint16_t's.
 *
 * @param src           A pointer to a vImage_Buffer struct which describes a memory region full of RGB565 pixels
 *
 * @param dest          A pointer to a vImage_Buffer struct which describes a preallocated memory region to be overwritten by ARGB1555 pixels
 *
 * @param dither        A dithering method for the green channel.   Options:
 *
 *                  kvImageConvert_DitherNone - apply no dithering; input values
 *                      are rounded to the nearest value representable in the
 *                      destination format.
 *                  kvImageConvert_DitherOrdered - pre-computed blue noise is
 *                      added to the image before rounding to the values in
 *                      the destination format.  The offset into this blue
 *                      noise is randomized per-call to avoid visible artifacts
 *                      if you do your own tiling or call the function on
 *                      sequential frames of video.
 *                  kvImageConvert_DitherOrderedReproducible - pre-computed
 *                      blue noise is added to the image before rounding to the
 *                      values in the destination format.  The offset into the
 *                      blue noise is the same for every call to allow users
 *                      to get reproducible results.
 *
 *                  The ordered dither methods may be further influenced by shaping the
 *                  distribution of the noise using the gaussian and uniform options below.
 *                  These options are OR-ed with kvImageConvert_DitherOrdered / kvImageCon-
 *                  vert_DitherOrderedReproducible:
 *
 *                  kvImageConvert_OrderedGaussianBlue - when using an ordered dither
 *                      pattern, distribute the noise according to a gaussian
 *                      distribution. This generally gives more pleasing images --
 *                      less noisy and perhaps a little more saturated -- but color
 *                      fidelity can suffer. Its effect is between kvImageConvert_DitherNone
 *                      and kvImageConvert_DitherOrdered | kvImageConvert_DitherUniform.
 *                      This is the default for kvImageConvert_DitherOrdered and
 *                      kvImageConvert_DitherOrderedReproducible.
 *
 *                  kvImageConvert_OrderedUniformBlue - when using an ordered dither
 *                      pattern, distribute the noise uniformly. This generally gives
 *                      best color fidelity, but the resulting image is noisier and more
 *                      obviously dithered. This is usually the best choice when low
 *                      bitdepth content is drawn next to high bitdepth content and in other
 *                      circumstances where subtle changes to color arising from the conversion
 *                      could be easily noticed. It may be a poor choice when the image
 *                      is likely to be enlarged -- this would cause the noise to become
 *                      more evident-- and for very flat / synthetic content with little
 *                      inherent noise. The enlargement problem may be avoided by enlarging
 *                      first at high bitdepth, then convert to lower bitdepth.
 *
 *                  To clarify: "Blue" noise is not blue, nor does it operate solely on the blue
 *                  color channel. Blue noise is monochrome noise that is added to all color
 *                  channels equally. The name arises from blue light, which has a higher frequency
 *                  than other colors of visible light. Thus, blue noise is noise which is
 *                  weighted heavily towards high frequencies. Low frequency noise tends to have
 *                  visible shapes in it that would become apparent in an image if it was added in,
 *                  so it is excluded from the dither pattern.
 *
 * @param flags           The following flags are understood by this function:
 *
 *          <pre>
 *          @textblock
 *          kvImageNoFlags                      Default operation.
 *
 *          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
 *                                              many such operations going concurrently, and in cases where it is desirable to keep
 *                                              CPU utilization to a single core.
 *
 *          kvImageGetTempBufferSize            Returns 0.  Reads and writes no pixels.
 *          @/textblock
 *          </pre>
 *
 * @return
 *          <pre>
 *          @textblock
 *          kvImageNoError                          Success
 *
 *          kvImageBufferSizeMismatch               dest->height > src->height OR dest->width > src->width.  There are not enough pixels to fill the destination buffer.
 *
 *          kvImageInvalidParameter                 Invalid / unknown dither value
 *          @/textblock
 *          </pre>
 *
 * 
 */
@available(OSX 10.10, *)
func vImageConvert_RGB565toARGB1555(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_Planar16FtoPlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_PlanarFtoPlanar16F(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar8toPlanar16F(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar16FtoPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_16UToPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_Planar8To16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_RGB888toARGB8888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: Pixel_8, _: UnsafePointer<vImage_Buffer>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageConvert_RGB888toRGBA8888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: Pixel_8, _: UnsafePointer<vImage_Buffer>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageConvert_RGB888toBGRA8888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: Pixel_8, _: UnsafePointer<vImage_Buffer>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_ARGB8888toRGB888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGBA8888toRGB888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_BGRA8888toRGB888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageFlatten_ARGB8888ToRGB888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: UnsafePointer<UInt8>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageFlatten_ARGBFFFFToRGBFFF(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: UnsafePointer<Float>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageFlatten_RGBA8888ToRGB888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: UnsafePointer<UInt8>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageFlatten_RGBAFFFFToRGBFFF(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: UnsafePointer<Float>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageFlatten_BGRA8888ToRGB888(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: UnsafePointer<UInt8>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageFlatten_BGRAFFFFToRGBFFF(_: UnsafePointer<vImage_Buffer>, _: UnsafePointer<vImage_Buffer>, _: UnsafePointer<Float>, _: Bool, _: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_Planar8toRGB888(planarRed: UnsafePointer<vImage_Buffer>, _ planarGreen: UnsafePointer<vImage_Buffer>, _ planarBlue: UnsafePointer<vImage_Buffer>, _ rgbDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_PlanarFtoRGBFFF(planarRed: UnsafePointer<vImage_Buffer>, _ planarGreen: UnsafePointer<vImage_Buffer>, _ planarBlue: UnsafePointer<vImage_Buffer>, _ rgbDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_RGB888toPlanar8(rgbSrc: UnsafePointer<vImage_Buffer>, _ redDest: UnsafePointer<vImage_Buffer>, _ greenDest: UnsafePointer<vImage_Buffer>, _ blueDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageConvert_RGBFFFtoPlanarF(rgbSrc: UnsafePointer<vImage_Buffer>, _ redDest: UnsafePointer<vImage_Buffer>, _ greenDest: UnsafePointer<vImage_Buffer>, _ blueDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.5, *)
func vImageSelectChannels_ARGB8888(newSrc: UnsafePointer<vImage_Buffer>, _ origSrc: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.5, *)
func vImageSelectChannels_ARGBFFFF(newSrc: UnsafePointer<vImage_Buffer>, _ origSrc: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.5, *)
func vImageOverwriteChannelsWithPixel_ARGB8888(the_pixel: UnsafePointer<UInt8>, _ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageOverwriteChannelsWithPixel_ARGB16U(the_pixel: UnsafePointer<UInt16>, _ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.5, *)
func vImageOverwriteChannelsWithPixel_ARGBFFFF(the_pixel: UnsafePointer<Float>, _ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ copyMask: UInt8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_Planar8ToXRGB8888(alpha: Pixel_8, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_Planar8ToBGRX8888(blue: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ alpha: Pixel_8, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_PlanarFToXRGBFFFF(alpha: Pixel_F, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_PlanarFToBGRXFFFF(blue: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ alpha: Pixel_F, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_XRGB8888ToPlanar8(src: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_BGRX8888ToPlanar8(src: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_XRGBFFFFToPlanarF(src: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_BGRXFFFFToPlanarF(src: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_Planar8ToARGBFFFF(alpha: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_Planar8ToXRGBFFFF(alpha: Pixel_F, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_Planar8ToBGRXFFFF(blue: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ alpha: Pixel_F, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_PlanarFToARGB8888(alpha: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_PlanarFToXRGB8888(alpha: Pixel_8, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.6, *)
func vImageConvert_PlanarFToBGRX8888(blue: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ alpha: Pixel_8, _ dest: UnsafePointer<vImage_Buffer>, _ maxFloat: UnsafePointer<Float>, _ minFloat: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGB16UtoARGB16U(rgbSrc: UnsafePointer<vImage_Buffer>, _ aSrc: UnsafePointer<vImage_Buffer>, _ alpha: Pixel_16U, _ argbDest: UnsafePointer<vImage_Buffer>, _ premultiply: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGB16UtoRGBA16U(rgbSrc: UnsafePointer<vImage_Buffer>, _ aSrc: UnsafePointer<vImage_Buffer>, _ alpha: Pixel_16U, _ rgbaDest: UnsafePointer<vImage_Buffer>, _ premultiply: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGB16UtoBGRA16U(rgbSrc: UnsafePointer<vImage_Buffer>, _ aSrc: UnsafePointer<vImage_Buffer>, _ alpha: Pixel_16U, _ bgraDest: UnsafePointer<vImage_Buffer>, _ premultiply: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGB16UtoRGB16U(argbSrc: UnsafePointer<vImage_Buffer>, _ rgbDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGBA16UtoRGB16U(rgbaSrc: UnsafePointer<vImage_Buffer>, _ rgbDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_BGRA16UtoRGB16U(bgraSrc: UnsafePointer<vImage_Buffer>, _ rgbDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar16UtoARGB16U(aSrc: UnsafePointer<vImage_Buffer>, _ rSrc: UnsafePointer<vImage_Buffer>, _ gSrc: UnsafePointer<vImage_Buffer>, _ bSrc: UnsafePointer<vImage_Buffer>, _ argbDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGB16UtoPlanar16U(argbSrc: UnsafePointer<vImage_Buffer>, _ aDest: UnsafePointer<vImage_Buffer>, _ rDest: UnsafePointer<vImage_Buffer>, _ gDest: UnsafePointer<vImage_Buffer>, _ bDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar16UtoRGB16U(rSrc: UnsafePointer<vImage_Buffer>, _ gSrc: UnsafePointer<vImage_Buffer>, _ bSrc: UnsafePointer<vImage_Buffer>, _ rgbDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGB16UtoPlanar16U(rgbSrc: UnsafePointer<vImage_Buffer>, _ rDest: UnsafePointer<vImage_Buffer>, _ gDest: UnsafePointer<vImage_Buffer>, _ bDest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGB16UToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ copyMask: UInt8, _ backgroundColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGB8888ToARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ copyMask: UInt8, _ backgroundColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGB16UToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ copyMask: UInt8, _ backgroundColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGB8888ToRGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ copyMask: UInt8, _ backgroundColor: UnsafePointer<Pixel_16U>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageByteSwap_Planar16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageFlatten_ARGB8888(argbSrc: UnsafePointer<vImage_Buffer>, _ argbDst: UnsafePointer<vImage_Buffer>, _ argbBackgroundColorPtr: UnsafePointer<UInt8>, _ isImagePremultiplied: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageFlatten_RGBA8888(rgbaSrc: UnsafePointer<vImage_Buffer>, _ rgbaDst: UnsafePointer<vImage_Buffer>, _ rgbaBackgroundColorPtr: UnsafePointer<UInt8>, _ isImagePremultiplied: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageFlatten_ARGB16U(argbSrc: UnsafePointer<vImage_Buffer>, _ argbDst: UnsafePointer<vImage_Buffer>, _ argbBackgroundColorPtr: UnsafePointer<UInt16>, _ isImagePremultiplied: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageFlatten_RGBA16U(rgbaSrc: UnsafePointer<vImage_Buffer>, _ rgbaDst: UnsafePointer<vImage_Buffer>, _ rgbaBackgroundColorPtr: UnsafePointer<UInt16>, _ isImagePremultiplied: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageFlatten_ARGB16Q12(argbSrc: UnsafePointer<vImage_Buffer>, _ argbDst: UnsafePointer<vImage_Buffer>, _ argbBackgroundColorPtr: UnsafePointer<Int16>, _ isImagePremultiplied: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageFlatten_RGBA16Q12(argbSrc: UnsafePointer<vImage_Buffer>, _ argbDst: UnsafePointer<vImage_Buffer>, _ argbBackgroundColorPtr: UnsafePointer<Int16>, _ isImagePremultiplied: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageFlatten_ARGBFFFF(argbSrc: UnsafePointer<vImage_Buffer>, _ argbDst: UnsafePointer<vImage_Buffer>, _ argbBackgroundColorPtr: UnsafePointer<Float>, _ isImagePremultiplied: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageFlatten_RGBAFFFF(rgbaSrc: UnsafePointer<vImage_Buffer>, _ rgbaDst: UnsafePointer<vImage_Buffer>, _ rgbaBackgroundColorPtr: UnsafePointer<Float>, _ isImagePremultiplied: Bool, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar1toPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar2toPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar4toPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Indexed1toPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ colors: UnsafePointer<Pixel_8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Indexed2toPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ colors: UnsafePointer<Pixel_8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Indexed4toPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ colors: UnsafePointer<Pixel_8>, _ flags: vImage_Flags) -> vImage_Error
var kvImageConvert_DitherNone: UInt32 { get }
var kvImageConvert_DitherOrdered: UInt32 { get }
var kvImageConvert_DitherOrderedReproducible: UInt32 { get }
var kvImageConvert_DitherFloydSteinberg: UInt32 { get }
var kvImageConvert_DitherAtkinson: UInt32 { get }
var kvImageConvert_OrderedGaussianBlue: UInt32 { get }
var kvImageConvert_OrderedUniformBlue: UInt32 { get }
var kvImageConvert_OrderedNoiseShapeMask: UInt32 { get }
@available(OSX 10.9, *)
func vImageConvert_Planar8toPlanar1(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar8toPlanar2(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar8toPlanar4(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar8toIndexed1(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ colors: UnsafeMutablePointer<Pixel_8>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar8toIndexed2(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ colors: UnsafeMutablePointer<Pixel_8>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar8toIndexed4(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ colors: UnsafeMutablePointer<Pixel_8>, _ dither: Int32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_8to16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_RGB888toPlanar16Q12(src: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_ARGB8888toPlanar16Q12(src: UnsafePointer<vImage_Buffer>, _ alpha: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_16Q12to8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar16Q12toRGB888(red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Planar16Q12toARGB8888(alpha: UnsafePointer<vImage_Buffer>, _ red: UnsafePointer<vImage_Buffer>, _ green: UnsafePointer<vImage_Buffer>, _ blue: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_16Q12toF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_Fto16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_16Q12to16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageConvert_16Uto16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_YpCbCrToARGB_GenerateConversion
     
     @abstract Generates the conversion from a YpCbCr to a ARGB pixel format.
     
     @param matrix
     A pointer to vImage_YpCbCrToARGBMatrix that contains the matrix coefficients for the conversion
     from a YpCbCr to a ARGB pixel format.
 
     @param pixelRange
     A pointer to vImage_YpCbCrPixelRange that contains the pixel range information for the conversion
     from a YpCbCr to a ARGB pixel format.
 
     @param outInfo
     A pointer to vImage_YpCbCrToRGB will be initialized with the information for the conversion function
     will use later.
 
     @param inYpCbCrType
     A YpCbCrType to specify the input YpCbCr format.
     
     @param outARGBType
     A ARGBType to specify the output ARGB format.
 
     @param flags
     kvImagePrintDiagnosticsToConsole   Directs the function to print diagnostic information to the console in the event of failure.
 
     @discussion This function is used to create the vImage_YpCbCrToARGB conversion information necessary for all
     of YUV -> RGB conversion functions.
 
     For example, if we want to prepare for the conversion from 'yuvs' with ITU 601 video range to ARGB8888, then we
     need to do the following:
 
     <pre> @textblock
     vImage_Error err = kvImageNoError;
     vImage_Flags flags = kvImageNoFlags;
     vImage_YpCbCrPixelRange pixelRange;
     vImage_YpCbCrToARGB outInfo;
 
     pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' > 1.
     pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' < 0.
     pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr > 0.5
     pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr < -0.5
                                            //                ( pixelRange.CbCr_bias - (pixelRange.CbCrRangeMax - pixelRange.CbCr_bias) = 2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax )
 
     err = vImageConvert_YpCbCrToARGB_GenerateConversion(kvImageITU601_YpCbCrToARGBMatrix, &pixelRange, &outInfo, kvImage422YpCbYpCr8, kvImageARGB8888, flags);
     @/textblock </pre>
 
     If we want to define our own conversion coefficents, then we can do
 
 <pre> @textblock
     vImage_YpCbCrToARGBMatrix matrix;
     vImage_YpCbCrPixelRange pixelRange;
 
     matrix.Yp                  =  1.0f;
     matrix.Cb_G                = -0.3441f;
     matrix.Cb_B                =  1.772f;
     matrix.Cr_R                =  1.402f;
     matrix.Cr_G                = -0.7141f;
 
     pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' > 1.
     pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' < 0.
     pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr > 0.5
     pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr < -0.5
                                            //                ( pixelRange.CbCr_bias - (pixelRange.CbCrRangeMax - pixelRange.CbCr_bias) = 2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax )
 
     err = vImageConvert_YpCbCrToARGB_GenerateConversion(&matrix, &pixelRange, &outInfo, kvImage422YpCbYpCr8, kvImageARGB8888, flags).
 @/textblock </pre>
 
 
     vImage_YpCbCrToARGB created may be reused multiple times from multiple threads concurrently.
 
     Here are the conversions available currently.
 
 <pre>
 @textblock
             RGB8   RGB16Q12    RGB16
     YUV8     Y        N          N
     YUV10    Y        Y          N
     YUV12    Y        Y          N
     YUV14    Y        N          Y
     YUV16    Y        N          Y
 @/textblock
 </pre>
 
     @return  The following return codes may occur:
     <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageUnsupportedConversion    Is returned when there is no conversion in vImage for inYpCbCrType & outARGBType.
     @/textblock  </pre>
 
*/
@available(OSX 10.10, *)
func vImageConvert_YpCbCrToARGB_GenerateConversion(matrix: UnsafePointer<vImage_YpCbCrToARGBMatrix>, _ pixelRange: UnsafePointer<vImage_YpCbCrPixelRange>, _ outInfo: UnsafeMutablePointer<vImage_YpCbCrToARGB>, _ inYpCbCrType: vImageYpCbCrType, _ outARGBType: vImageARGBType, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGBToYpCbCr_GenerateConversion
     
     @abstract Generates the conversion from a ARGB to a YpCbCr pixel format.
     
     @param matrix
     A pointer to vImage_ARGBToYpCbCrMatrix that contains the matrix coefficients for the conversion
     from a ARGB to a YpCbCr pixel format.
 
     @param pixelRange
     A pointer to vImage_YpCbCrPixelRange that contains the pixel range information for the conversion
     from a ARGB to a YpCbCr pixel format.
 
     @param outInfo
     A pointer to vImage_ARGBToYpCbCr will be initialized with the information for the conversion function
     will use later.
 
     @param inARGBType
     A ARGBType to specify the output ARGB format.
 
     @param outYpCbCrType
     A YpCbCrType to specify the input YpCbCr format.
 
     @param flags
     kvImagePrintDiagnosticsToConsole   Directs the function to print diagnostic information to the console in the event of failure.
 
     @discussion This function is used to create the vImage_ARGBToYpCbCr conversion information necessary for all
     of RGB -> YUV conversion functions.
 
     For example, if we want to prepare for the conversion from ARGB8888 'yuvs' with ITU 601 video range, then we
     need to do the following:

     <pre> @textblock
     vImage_Error err = kvImageNoError;
     vImage_Flags flags = kvImageNoFlags;
     vImage_YpCbCrPixelRange pixelRange;
     vImage_ARGBToYpCbCr outInfo;
     
     pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' > 1.
     pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' < 0.
     pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr > 0.5
     pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr < -0.5
 
     err = vImageConvert_ARGBToYpCbCr_GenerateConversion(kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4, &pixelRange, &outInfo, kvImageARGB8888, kvImage422YpCbYpCr8, flags);
 
 
     If we want to define our own conversion coefficents, then we can do
 
     vImage_ARGBToYpCbCrMatrix matrix;;
     vImage_YpCbCrPixelRange pixelRange;
 
     matrix.R_Yp          =  0.2989f;
     matrix.G_Yp          =  0.5866f;
     matrix.B_Yp          =  0.1144f;
     matrix.R_Cb          = -0.1688f;
     matrix.G_Cb          = -0.3312f;
     matrix.B_Cb_R_Cr     =  0.5f;
     matrix.G_Cr          = -0.4183f;
     matrix.B_Cr          = -0.0816f;
     pixelRange.Yp_bias         =   16;     // encoding for Y' = 0.0
     pixelRange.CbCr_bias       =  128;     // encoding for CbCr = 0.0
     pixelRange.YpRangeMax      =  235;     // encoding for Y'= 1.0
     pixelRange.CbCrRangeMax    =  240;     // encoding for CbCr = 0.5
     pixelRange.YpMax           =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest. Use pixelRange.YpRangeMax if you don't want Y' > 1.
     pixelRange.YpMin           =    0;     // a clamping limit below which the value is not allowed to go. 0 is fastest. Use pixelRange.Yp_bias if you don't want Y' < 0.
     pixelRange.CbCrMax         =  255;     // a clamping limit above which the value is not allowed to go. 255 is fastest.  Use pixelRange.CbCrRangeMax, if you don't want CbCr > 0.5
     pixelRange.CbCrMin         =    0;     // a clamping limit above which the value is not allowed to go. 0 is fastest.  Use (2*pixelRange.CbCr_bias - pixelRange.CbCrRangeMax), if you don't want CbCr < -0.5
 
     err = vImageConvert_ARGBToYpCbCr_GenerateConversion(&matrix, &pixelRange, &outInfo, kvImageARGB8888, kvImage422YpCbYpCr8, flags);
 
 
     vImage_ARGBToYpCbCr created may be reused multiple times from multiple threads concurrently.
 
     Here are the conversions available currently.
     
             RGB8   RGB16Q12    RGB16
     YUV8     Y        N          N
     YUV10    Y        Y          N
     YUV12    Y        Y          N
     YUV14    Y        N          Y
     YUV16    Y        N          Y
 @/textblock </pre>
 
     @return
     <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageUnsupportedConversion    Is returned when there is no conversion in vImage for inARGBType & outYpCbCrType.
     @/textblock </pre>
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGBToYpCbCr_GenerateConversion(matrix: UnsafePointer<vImage_ARGBToYpCbCrMatrix>, _ pixelRange: UnsafePointer<vImage_YpCbCrPixelRange>, _ outInfo: UnsafeMutablePointer<vImage_ARGBToYpCbCr>, _ inARGBType: vImageARGBType, _ outYpCbCrType: vImageYpCbCrType, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_422YpCbYpCr8ToARGB8888
     
     @abstract Convert YUV 422YpCbYpCr8 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 422YpCbYpCr8 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
     
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
 
     @discussion Convert YUV 422YpCbYpCr8 format to ARGB8888
     
     
     Yp0 Cb0 Yp1 Cr0  =>  A0 R0 G0 B0  A1 R1 G1 B1
     
     
     YUV 422YpCbYpCr8 can be used for 'yuvs' and 'yuvf' that are defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert ARGB8888 to 'yuvs' with ITU 601 video range, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion().
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
 
     The per-pixel operation is:
     
     <pre>
     @textblock
     uint8_t *srcPixel = src.data;
     Yp0 = srcPixel[0];
     Cb0 = srcPixel[1];
     Yp1 = srcPixel[2];
     Cr0 = srcPixel[3];
     srcPixel += 4;
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     
     uint8_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;
     @/textblock
     </pre>
 
    @return
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_422YpCbYpCr8ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt8, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To422YpCbYpCr8
     
     @abstract Convert ARGB8888 to YUV 422YpCbYpCr8 format.
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 422YpCbYpCr8 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 422YpCbYpCr8 format
     
     A0 R0 G0 B0  A1 R1 G1 B1 => Yp0 Cb0 Yp1 Cr0
     
 
     YUV 422YpCbYpCr8 can be used for 'yuvs' and 'yuvf' that are defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB8888 to 'yuvs' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
     The per-pixel operation is:
     
 <pre>
 @textblock
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Yp0;
     destPixel[1] = Cb0;
     destPixel[2] = Yp1;
     destPixel[3] = Cr0;
     destPixel += 4;
 @/textblock
 </pre>

@return 
 <pre>
 @textblock
 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
@/textblock
 </pre>
 
     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To422YpCbYpCr8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_422CbYpCrYp8ToARGB8888
 
     @abstract Convert YUV 422CbYpCrYp8 format to ARGB8888
 
     @param src
     A pointer to vImage_Buffer that references YUV 422CbYpCrYp8 source pixels.
 
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
 
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 422CbYpCrYp8 format to ARGB8888
     
     
     Cb0 Yp0 Cr0 Yp1  =>  A0 R0 G0 B0  A1 R1 G1 B1
     
     
     YUV 422CbYpCrYp8 can be used for '2vuy' and '2vuf' that are defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert '2vuy' with ITU 601 video range to ARGB8888, then we need 
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
     
     The per-pixel operation is:
     
     <pre>
     @textblock
     uint8_t *srcPixel = src.data;
     Cb0 = srcPixel[0];
     Yp0 = srcPixel[1];
     Cr0 = srcPixel[2];
     Yp1 = srcPixel[3];
     srcPixel += 4;
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                            ), 255 )
     
     uint8_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;
 @/textblock
 </pre>
 
 @return
   <pre>
   @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
   @/textblock
   </pre>
 
     Note: Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_422CbYpCrYp8ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt8, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To422CbYpCrYp8
     
     @abstract Convert ARGB8888 to YUV 422CbYpCrYp8 format
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 422CbYpCrYp8 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once in the ordering.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 422CbYpCrYp8 format. Can be used for 2vuy.
     
     
     A0 R0 G0 B0  A1 R1 G1 B1 => Cb0 Yp0 Cr0 Yp1
     
     
     YUV 422CbYpCrYp8 can be used for '2vuy' and '2vuf' that are defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert ARGB8888 to '2vuy' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
 
     The per-pixel operation is:
     
 <pre>
 @textblock
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Cb0;
     destPixel[1] = Yp0;
     destPixel[2] = Cr0;
     destPixel[3] = Yp1;
     destPixel += 4;
 @/textblock
 </pre>
 
 @return
 <pre>
 @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
 @/textblock
 </pre>
 
     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To422CbYpCrYp8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_422CbYpCrYp8_AA8ToARGB8888
     
     @abstract Convert YUV 422CbYpCrYp8_AA8 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 422CbYpCrYp8_AA8 source pixels.
 
     @param srcA
     A pointer to vImage_Buffer that references 8-bit alpha source pixels.
 
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 422CbYpCrYp8_AA8 format to ARGB8888
     
     
     Cb0 Yp0 Cr0 Yp1  =>  A0 R0 G0 B0  A1 R1 G1 B1
 
     A0 A1
     
     
     YUV 422CbYpCrYp8_AA8 can be used for 'a2vy' that is defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert 'a2vy' with ITU 601 video range to ARGB8888, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
 
     The per-pixel operation is:
     
 <pre>
 @textblock
     uint8_t *srcPixel = src.data;
     Cb0 = srcPixel[0];
     Yp0 = srcPixel[1];
     Cr0 = srcPixel[2];
     Yp1 = srcPixel[3];
     srcPixel += 4;
 
     uint8_t *alpha = srcA.data;
     A0 = alpha[0];
     A1 = alpha[1];
     alpha += 2;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;
 @/textblock
 </pre>
 
 @return 
    <pre>
    @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock
    </pre>
 
    Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_422CbYpCrYp8_AA8ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ srcA: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To422CbYpCrYp8_AA8
     
     @abstract Convert ARGB8888 to YUV 422CbYpCrYp8_AA8 format
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 422CbYpCrYp8_AA8 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears exactly once.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 422CbYpCrYp8_AA8 format
     
     
     A0 R0 G0 B0  A1 R1 G1 B1 => Cb0 Yp0 Cr0 Yp1
 
                                 A0 A1
     
 
     For example, if we want to use this function to convert ARGB8888 to 'a2vy' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
     The per-pixel operation is:
     
     <pre>
     @textblock
 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Cb0;
     destPixel[1] = Yp0;
     destPixel[2] = Cr0;
     destPixel[3] = Yp1;
     destPixel += 4;
 
     uint8_t *alpha = destA.data;
     alpha[0] = A0;
     alpha[1] = A1;
     alpha += 2;
 
     @/textblock
     </pre>
     
    @return
     <pre>
     @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock
    <pre>
 
     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To422CbYpCrYp8_AA8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ destA: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_444AYpCbCr8ToARGB8888
     
     @abstract Convert YUV 444AYpCbCr8 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 444AYpCbCr8 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 444AYpCbCr8 format to ARGB8888
     
     
     A0 Yp0 Cb0 Cr0  =>  A0 R0 G0 B0
 
 
     YUV 444AYpCbCr8 can be used for 'r408' and 'y408' that are defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert 'y408' with ITU 601 video range to ARGB8888, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
 
     The per-pixel operation is:
     
    <pre>
    @textblock
 
     uint8_t *srcPixel = src.data;
     A0  = srcPixel[0];
     Yp0 = srcPixel[1];
     Cb0 = srcPixel[2];
     Cr0 = srcPixel[3];
     srcPixel += 4;
 
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
 
     uint8_t ARGB[4];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
 
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
     
    @/textblock
    <pre>
 
    @return
    <pre>
    @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock
    </pre>
 
     Results are guaranteed to be faithfully rounded.
     This function can work in place.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_444AYpCbCr8ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To444AYpCbCr8
     
     @abstract Convert ARGB8888 to YUV 444AYpCbCr8 format
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 444AYpCbCr8 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears exactly once.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 444AYpCbCr8 format
     
     
     A0 R0 G0 B0  =>  A0 Yp0 Cb0 Cr0
 
 
     YUV 444AYpCbCr8 can be used for 'r408' and 'y408' that are defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert ARGB8888 to 'y408' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
     The per-pixel operation is:
     
 <pre>
 @textblock
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
 
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
 
     uint8_t *destPixel = dest.data;
     destPixel[0] = A0;
     destPixel[1] = Yp0;
     destPixel[2] = Cb0;
     destPixel[3] = Cr0;
     destPixel += 4;
 @/textblock
 </pre>
 
 
 @return
   <pre>
   @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
   @/textblock
   <pre>
 
     Results are guaranteed to be faithfully rounded.
     This function can work in place.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To444AYpCbCr8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*! @functiongroup 444CbYpCrA8 ('v408') */
/*!
     @function vImageConvert_444CbYpCrA8ToARGB8888
     
     @abstract Convert YUV 444CbYpCrA8 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 444CbYpCrA8 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 444CbYpCrA8 format to ARGB8888
     
     
     Cb0 Yp0 Cr0 A0  =>  A0 R0 G0 B0
     
     
     YUV 444CbYpCrA8 can be used for 'v408' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert 'v408' with ITU 601 video range to ARGB8888, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
 
     The per-pixel operation is:
     
   <pre> @textblock
     uint8_t *srcPixel = src.data;
     Cb0 = srcPixel[0];
     Yp0 = srcPixel[1];
     Cr0 = srcPixel[2];
     A0  = srcPixel[3];
     srcPixel += 4;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[4];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
   @/textblock    </pre>
 
 
 @return
   <pre>
   @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
   @/textblock
   </pre>
 
     Results are guaranteed to be faithfully rounded.
     This function can work in place.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_444CbYpCrA8ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To444CbYpCrA8
     
     @abstract Convert ARGB8888 to YUV 444CbYpCrA8 format
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 444CbYpCrA8 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, provided that each channel appears only once.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 444CbYpCrA8 format
     
     
     A0 R0 G0 B0  =>  Cb0 Yp0 Cr0 A0
     
     
     YUV 444CbYpCrA8 can be used for 'v408' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB8888 to 'v408' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
     The per-pixel operation is:
     
 <pre> @textblock
    uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Cb0;
     destPixel[1] = Yp0;
     destPixel[2] = Cr0;
     destPixel[3] = A0;
     destPixel += 4;
 @/textblock </pre>
 
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
 @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
     This function can work in place.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To444CbYpCrA8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_444CrYpCb8ToARGB8888
     
     @abstract Convert YUV 444CrYpCb8 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 444CrYpCb8 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 444CrYpCb8 format to ARGB8888
     
     
     Cr0 Yp0 Cb0  =>  A0 R0 G0 B0
     
     
     YUV 444CrYpCb8 can be used for 'v308' that is defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert 'v308' with ITU 601 video range to ARGB8888, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
 
     The per-pixel operation is:
    <pre>
    @textblock
     
     uint8_t *srcPixel = src.data;
     Cr0 = srcPixel[0];
     Yp0 = srcPixel[1];
     Cb0 = srcPixel[2];
     srcPixel += 3;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[4];
     ARGB[0] = alpha;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
   @/textblock
   </pre>
 
 
   @return
    <pre>
    @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock
   </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_444CrYpCb8ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt8, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To444CrYpCb8
     
     @abstract Convert ARGB8888 to YUV 444CrYpCb8 format
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 444CrYpCb8 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, provided that each channel appears only once.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 444CrYpCb8 format
     
     
     A0 R0 G0 B0  =>  Cr0 Yp0 Cb0
     
     
     YUV 444CrYpCb8 can be used for 'v308' that is defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert ARGB8888 to 'v308' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
 
     The per-pixel operation is:
     
 <pre>
 @textblock
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = Cr0;
     destPixel[1] = Yp0;
     destPixel[2] = Cb0;
     destPixel += 3;
  @/textblock
  </pre>
     
  @return
 <pre>
 @textblock
 
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
 @/textblock
 </pre>
 
     Note: Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To444CrYpCb8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_420Yp8_Cb8_Cr8ToARGB8888
     
     @abstract Convert YUV 420Yp8_Cb8_Cr8 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 420Yp8_Cb8_Cr8 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 420Yp8_Cb8_Cr8 format to ARGB8888
     
     
     Ypt0 Ypt1  =>  At0 Rt0 Gt0 Bt0  At1 Rt1 Gt1 Bt1
 
     Ypb0 Ypb1      Ab0 Rb0 Gb0 Bb0  Ab1 Rb1 Gb1 Bb1
 
     Cb0
 
     Cr0
     
     
     YUV 420Yp8_Cb8_Cr8 can be used for 'y420' and 'f420' that are defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert 'y420' with ITU 601 video range to ARGB8888, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
 
     The per-pixel operation is:
  <pre>
  @textblock
     
     uint8_t *srcYtPixel = srcY.data;
     uint8_t *srcYbPixel = srcY.data + srcY.rowBytes;
     Ypt0 = srcYtPixel[0];
     Ypt1 = srcYtPixel[1];
     srcYtPixel += 2;
     Ypb0 = srcYbPixel[0];
     Ypb1 = srcYbPixel[1];
     srcYbPixel += 2;
 
     uint8_t *srcCbPixel = srcCb.data;
     uint8_t *srcCrPixel = srcCr.data;
     Cb0 = srcCbPixel[0];
     srcCbPixel += 1;
     Cr0 = srcCrPixel[0];
     srcCrPixel += 1;
     
     At0 = alpha
     Rt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 + Yp_bias) * Yp                               + (Cr0 + CbCr_bias) * Cr_R), 255 )
     Gt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_G + (Cr0 + CbCr_bias) * Cr_G), 255 )
     Bt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_B                              ), 255 )
     At1 = alpha
     Rt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 + Yp_bias) * Yp                               + (Cr0 + CbCr_bias) * Cr_R), 255 )
     Gt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_G + (Cr0 + CbCr_bias) * Cr_G), 255 )
     Bt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_B                              ), 255 )
     Ab0 = alpha
     Rb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 + Yp_bias) * Yp                               + (Cr0 + CbCr_bias) * Cr_R), 255 )
     Gb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_G + (Cr0 + CbCr_bias) * Cr_G), 255 )
     Bb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_B                              ), 255 )
     Ab1 = alpha
     Rb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 + Yp_bias) * Yp                               + (Cr0 + CbCr_bias) * Cr_R), 255 )
     Gb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_G + (Cr0 + CbCr_bias) * Cr_G), 255 )
     Bb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 + Yp_bias) * Yp + (Cb0 + CbCr_bias) * Cb_B                              ), 255 )
 
     uint8_t ARGB[16];
     ARGB[0]  = At0;
     ARGB[1]  = Rt0;
     ARGB[2]  = Gt0;
     ARGB[3]  = Bt0;
     ARGB[4]  = At1;
     ARGB[5]  = Rt1;
     ARGB[6]  = Gt1;
     ARGB[7]  = Bt1;
     ARGB[8]  = Ab0;
     ARGB[9]  = Rb0;
     ARGB[10] = Gb0;
     ARGB[11] = Bb0;
     ARGB[12] = Ab1;
     ARGB[13] = Rb1;
     ARGB[14] = Gb1;
     ARGB[15] = Bb1;
 
     uint8_t *destTPixel = dest.data;
     destTPixel[0]  = ARGB[permuteMap[0]];
     destTPixel[1]  = ARGB[permuteMap[1]];
     destTPixel[2]  = ARGB[permuteMap[2]];
     destTPixel[3]  = ARGB[permuteMap[3]];
     destTPixel[4]  = ARGB[permuteMap[0]+4];
     destTPixel[5]  = ARGB[permuteMap[1]+4];
     destTPixel[6]  = ARGB[permuteMap[2]+4];
     destTPixel[7]  = ARGB[permuteMap[3]+4];
     destTPixel += 8;
     uint8_t *destBPixel = dest.data + dest.rowBytes;
     destBPixel[0]  = ARGB[permuteMap[0]+8];
     destBPixel[1]  = ARGB[permuteMap[1]+8];
     destBPixel[2]  = ARGB[permuteMap[2]+8];
     destBPixel[3]  = ARGB[permuteMap[3]+8];
     destBPixel[4]  = ARGB[permuteMap[0]+12];
     destBPixel[5]  = ARGB[permuteMap[1]+12];
     destBPixel[6]  = ARGB[permuteMap[2]+12];
     destBPixel[7]  = ARGB[permuteMap[3]+12];
     destBPixel += 8;
 
   @/textblock
   </pre>
 
@return
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
 
     Note: Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_420Yp8_Cb8_Cr8ToARGB8888(srcYp: UnsafePointer<vImage_Buffer>, _ srcCb: UnsafePointer<vImage_Buffer>, _ srcCr: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt8, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To420Yp8_Cb8_Cr8
     
     @abstract Convert ARGB8888 to YUV 420Yp8_Cb8_Cr8 format.
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 420Yp8_Cb8_Cr8 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, provided that each channel appears only once.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 420Yp8_Cb8_Cr8 format
     
     
 <pre> @textblock
     At0 Rt0 Gt0 Bt0  At1 Rt1 Gt1 Bt1  =>  Ypt0 Ypt1
 
     Ab0 Rb0 Gb0 Bb0  Ab1 Rb1 Gb1 Bb1      Ypb0 Ypb1
 
                                           Cb0
 
                                           Cr0
 
   @/textblock </pre>

     YUV 420Yp8_Cb8_Cr8 can be used for 'y420' and 'f420' that are defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB8888 to 'y420' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
     The per-pixel operation is:
  <pre>
  @textblock
     uint8_t *srcTPixel = src.data;
     At0 = srcTPixel[permuteMap[0]];
     Rt0 = srcTPixel[permuteMap[1]];
     Gt0 = srcTPixel[permuteMap[2]];
     Bt0 = srcTPixel[permuteMap[3]];
     srcTPixel += 4;
     At1 = srcTPixel[permuteMap[0]];
     Rt1 = srcTPixel[permuteMap[1]];
     Gt1 = srcTPixel[permuteMap[2]];
     Bt1 = srcTPixel[permuteMap[3]];
     srcTPixel += 4;
     uint8_t *srcBPixel = src.data + src.rowBytes;
     Ab0 = srcBPixel[permuteMap[0]];
     Rb0 = srcBPixel[permuteMap[1]];
     Gb0 = srcBPixel[permuteMap[2]];
     Bb0 = srcBPixel[permuteMap[3]];
     srcBPixel += 4;
     Ab1 = srcBPixel[permuteMap[0]];
     Rb1 = srcBPixel[permuteMap[1]];
     Gb1 = srcBPixel[permuteMap[2]];
     Bb1 = srcBPixel[permuteMap[3]];
     srcBPixel += 4;
 
     Ypt0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rt0 * R_Yp      + Gt0 * G_Yp + Bt0 * B_Yp     )
     Ypt1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rt1 * R_Yp      + Gt1 * G_Yp + Bt1 * B_Yp     )
     Ypb0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rb0 * R_Yp      + Gb0 * G_Yp + Bb0 * B_Yp     )
     Ypb1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rb1 * R_Yp      + Gb1 * G_Yp + Bb1 * B_Yp     )
     Cb0  = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( Rt0 * R_Cb      + Gt0 * G_Cb + Bt0 * B_Cb_R_Cr
                                                    +   Rt1 * R_Cb      + Gt1 * G_Cb + Bt1 * B_Cb_R_Cr
                                                    +   Rb0 * R_Cb      + Gb0 * G_Cb + Bb0 * B_Cb_R_Cr
                                                    +   Rb1 * R_Cb      + Gb1 * G_Cb + Bb1 * B_Cb_R_Cr) / 4 )
     Cr0  = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( Rt0 * B_Cb_R_Cr + Gt0 * G_Cr + Bt0 * B_Cr
                                                    +   Rt1 * B_Cb_R_Cr + Gt1 * G_Cr + Bt1 * B_Cr
                                                    +   Rb0 * B_Cb_R_Cr + Gb0 * G_Cr + Bb0 * B_Cr
                                                    +   Rb1 * B_Cb_R_Cr + Gb1 * G_Cr + Bb1 * B_Cr     ) / 4 )
     
     uint8_t *destYptPixel = destYp.data;
     uint8_t *destYpbPixel = destYp.data + destYp.rowBytes;
     destYptPixel[0] = Ypt0;
     destYptPixel[1] = Ypt1;
     destYpbPixel[0] = Ypb0;
     destYpbPixel[1] = Ypb1;
     destYptPixel += 2;
     destYpbPixel += 2;
     
     uint8_t *destCbPixel = destCb.data;
     uint8_t *destCrPixel = destCr.data;
     destCbPixel[0] = Cb0;
     destCrPixel[0] = Cr0;
     destCbPixel += 1;
     destCrPixel += 1;
   @/textblock
   </pre>
 
  @return
    <pre>
    @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock
    </pre>

     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To420Yp8_Cb8_Cr8(src: UnsafePointer<vImage_Buffer>, _ destYp: UnsafePointer<vImage_Buffer>, _ destCb: UnsafePointer<vImage_Buffer>, _ destCr: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_420Yp8_CbCr8ToARGB8888
     
     @abstract Convert YUV 420Yp8_CbCr8 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 420Yp8_CbCr8 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 420Yp8_CbCr8 format to ARGB8888
     
     
     Ypt0 Ypt1  =>  At0 Rt0 Gt0 Bt0  At1 Rt1 Gt1 Bt1
     
     Ypb0 Ypb1      Ab0 Rb0 Gb0 Bb0  Ab1 Rb1 Gb1 Bb1
     
     Cb0 Cr0
 
     
     YUV 420Yp8_CbCr8 can be used for '420v' and '420f' that are defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert '420v' with ITU 601 video range to ARGB8888, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
 
     The per-pixel operation is:
  <pre>
  @textblock
 
     uint8_t *srcYtPixel = srcY.data;
     uint8_t *srcYbPixel = srcY.data + srcY.rowBytes;
     Ypt0 = srcYtPixel[0];
     Ypt1 = srcYtPixel[1];
     srcYtPixel += 2;
     Ypb0 = srcYbPixel[0];
     Ypb1 = srcYbPixel[1];
     srcYbPixel += 2;
     
     uint8_t *srcCbCrPixel = srcCbCr.data;
     Cb0 = srcCbCrPixel[0];
     Cr0 = srcCbCrPixel[1];
     srcCrPixel += 2;
     
     At0 = alpha
     Rt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     Gt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     Bt0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     At1 = alpha
     Rt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     Gt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     Bt1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypt1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     Ab0 = alpha
     Rb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     Gb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     Bb0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     Ab1 = alpha
     Rb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     Gb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     Bb1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Ypb1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                              ), 255 )
     
     uint8_t ARGB[16];
     ARGB[0]  = At0;
     ARGB[1]  = Rt0;
     ARGB[2]  = Gt0;
     ARGB[3]  = Bt0;
     ARGB[4]  = At1;
     ARGB[5]  = Rt1;
     ARGB[6]  = Gt1;
     ARGB[7]  = Bt1;
     ARGB[8]  = Ab0;
     ARGB[9]  = Rb0;
     ARGB[10] = Gb0;
     ARGB[11] = Bb0;
     ARGB[12] = Ab1;
     ARGB[13] = Rb1;
     ARGB[14] = Gb1;
     ARGB[15] = Bb1;
     
     uint8_t *destTPixel = dest.data;
     destTPixel[0]  = ARGB[permuteMap[0]];
     destTPixel[1]  = ARGB[permuteMap[1]];
     destTPixel[2]  = ARGB[permuteMap[2]];
     destTPixel[3]  = ARGB[permuteMap[3]];
     destTPixel[4]  = ARGB[permuteMap[0]+4];
     destTPixel[5]  = ARGB[permuteMap[1]+4];
     destTPixel[6]  = ARGB[permuteMap[2]+4];
     destTPixel[7]  = ARGB[permuteMap[3]+4];
     destTPixel += 8;
     uint8_t *destBPixel = dest.data + dest.rowBytes;
     destBPixel[0]  = ARGB[permuteMap[0]+8];
     destBPixel[1]  = ARGB[permuteMap[1]+8];
     destBPixel[2]  = ARGB[permuteMap[2]+8];
     destBPixel[3]  = ARGB[permuteMap[3]+8];
     destBPixel[4]  = ARGB[permuteMap[0]+12];
     destBPixel[5]  = ARGB[permuteMap[1]+12];
     destBPixel[6]  = ARGB[permuteMap[2]+12];
     destBPixel[7]  = ARGB[permuteMap[3]+12];
     destBPixel += 8;
     
   @/textblock
   </pre>
 
  @return
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre> 
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_420Yp8_CbCr8ToARGB8888(srcYp: UnsafePointer<vImage_Buffer>, _ srcCbCr: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt8, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To420Yp8_CbCr8
     
     @abstract Convert ARGB8888 to YUV 420Yp8_CbCr8 format.
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 420Yp8_CbCr8 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as the channels don't repeat. For example, the pirate colorspace {0,1,1,1} (ARRR) is not supported, because the red channel appears more than once. (Pirates see red.)
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 420Yp8_CbCr8 format
     
     
 <pre> @textblock
     At0 Rt0 Gt0 Bt0  At1 Rt1 Gt1 Bt1  =>  Ypt0 Ypt1
     
     Ab0 Rb0 Gb0 Bb0  Ab1 Rb1 Gb1 Bb1      Ypb0 Ypb1
     
                                           Cb0 Cr0
 @/textblock </pre>
 
     
     YUV 420Yp8_CbCr8 can be used for '420v' and '420f' that are defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB8888 to '420v' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
     The per-pixel operation is:
  <pre> @textblock
     uint8_t *srcTPixel = src.data;
     At0 = srcTPixel[permuteMap[0]];
     Rt0 = srcTPixel[permuteMap[1]];
     Gt0 = srcTPixel[permuteMap[2]];
     Bt0 = srcTPixel[permuteMap[3]];
     srcTPixel += 4;
     At1 = srcTPixel[permuteMap[0]];
     Rt1 = srcTPixel[permuteMap[1]];
     Gt1 = srcTPixel[permuteMap[2]];
     Bt1 = srcTPixel[permuteMap[3]];
     srcTPixel += 4;
     uint8_t *srcBPixel = src.data + src.rowBytes;
     Ab0 = srcBPixel[permuteMap[0]];
     Rb0 = srcBPixel[permuteMap[1]];
     Gb0 = srcBPixel[permuteMap[2]];
     Bb0 = srcBPixel[permuteMap[3]];
     srcBPixel += 4;
     Ab1 = srcBPixel[permuteMap[0]];
     Rb1 = srcBPixel[permuteMap[1]];
     Gb1 = srcBPixel[permuteMap[2]];
     Bb1 = srcBPixel[permuteMap[3]];
     srcBPixel += 4;
     
     Ypt0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rt0 * R_Yp      + Gt0 * G_Yp + Bt0 * B_Yp     )
     Ypt1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rt1 * R_Yp      + Gt1 * G_Yp + Bt1 * B_Yp     )
     Ypb0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rb0 * R_Yp      + Gb0 * G_Yp + Bb0 * B_Yp     )
     Ypb1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   Rb1 * R_Yp      + Gb1 * G_Yp + Bb1 * B_Yp     )
     Cb0  = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( Rt0 * R_Cb      + Gt0 * G_Cb + Bt0 * B_Cb_R_Cr
                                                    +   Rt1 * R_Cb      + Gt1 * G_Cb + Bt1 * B_Cb_R_Cr
                                                    +   Rb0 * R_Cb      + Gb0 * G_Cb + Bb0 * B_Cb_R_Cr
                                                    +   Rb1 * R_Cb      + Gb1 * G_Cb + Bb1 * B_Cb_R_Cr) / 4 )
     Cr0  = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( Rt0 * B_Cb_R_Cr + Gt0 * G_Cr + Bt0 * B_Cr
                                                    +   Rt1 * B_Cb_R_Cr + Gt1 * G_Cr + Bt1 * B_Cr
                                                    +   Rb0 * B_Cb_R_Cr + Gb0 * G_Cr + Bb0 * B_Cr
                                                    +   Rb1 * B_Cb_R_Cr + Gb1 * G_Cr + Bb1 * B_Cr     ) / 4 )
     
     uint8_t *destYptPixel = destYp.data;
     uint8_t *destYpbPixel = destYp.data + destYp.rowBytes;
     destYptPixel[0] = Ypt0;
     destYptPixel[1] = Ypt1;
     destYpbPixel[0] = Ypb0;
     destYpbPixel[1] = Ypb1;
     destYptPixel += 2;
     destYpbPixel += 2;
     
     uint8_t *destCbCrPixel = destCbCr.data;
     destCbCrPixel[0] = Cb0;
     destCbCrPixel[1] = Cr0;
     destCbCrPixel += 2;
  @/textblock </pre>
 
 
  @return
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
   @/textblock 
   </pre>
 

     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To420Yp8_CbCr8(src: UnsafePointer<vImage_Buffer>, _ destYp: UnsafePointer<vImage_Buffer>, _ destCbCr: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_444AYpCbCr16ToARGB8888
     
     @abstract Convert YUV 444AYpCbCr16 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 444AYpCbCr16 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 444AYpCbCr16 format to ARGB8888
     
     
     A0 Yp0 Cb0 Cr0  =>  A0 R0 G0 B0
     
     
     YUV 444AYpCbCr8 can be used for 'y416' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert 'y416' with ITU 601 video range to ARGB8888, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
 
 
     The per-pixel operation is:
 <pre> @textblock
     uint16_t *srcPixel = src.data;
     A0  = srcPixel[0];
     Yp0 = srcPixel[1];
     Cb0 = srcPixel[2];
     Cr0 = srcPixel[3];
     srcPixel += 4;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[4];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
 @/textblock </pre>

 @result
   <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
   @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_444AYpCbCr16ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To444AYpCbCr16
     
     @abstract Convert ARGB8888 to YUV 444AYpCbCr16 format
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 444AYpCbCr16 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as the values are unique.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 444AYpCbCr16 format
     
     
     A0 R0 G0 B0  =>  A0 Yp0 Cb0 Cr0
     
     
     YUV 444AYpCbCr8 can be used for 'y416' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB8888 to 'y416' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 
 
     The per-pixel operation is:
  <pre> @textblock
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = A0;
     destPixel[1] = Yp0;
     destPixel[2] = Cb0;
     destPixel[3] = Cr0;
     destPixel += 4;
  @/textblock </pre>
 
  @return
  <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
  @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To444AYpCbCr16(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_444AYpCbCr16ToARGB16U
     
     @abstract Convert YUV 444AYpCbCr16 format to ARGB16U
     
     @param src
     A pointer to vImage_Buffer that references YUV 444AYpCbCr16 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 16-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 444AYpCbCr16 format to ARGB16U
     
     
     A0 Yp0 Cb0 Cr0  =>  A0 R0 G0 B0
     
     
     YUV 444AYpCbCr8 can be used for 'y416' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert 'y416' with ITU 601 video range to ARGB16U, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
     
     
     The per-pixel operation is:
  <pre> @textblock
     uint16_t *srcPixel = src.data;
     A0  = srcPixel[0];
     Yp0 = srcPixel[1];
     Cb0 = srcPixel[2];
     Cr0 = srcPixel[3];
     srcPixel += 4;
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 65535 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 65535 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 65535 )
     
     uint16_t ARGB[4];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
  @/textblock </pre>
 
  @return
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>

   Results are guaranteed to be faithfully rounded.
   This function can work in place.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_444AYpCbCr16ToARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB16UTo444AYpCbCr16
     
     @abstract Convert ARGB8888 to YUV 444AYpCbCr16 format
     
     @param src
     A pointer to vImage_Buffer that references 16-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 444AYpCbCr16 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
     Any ordering of channels is supported as long as each channel appears only once.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB16U to YUV 444AYpCbCr16 format
     
     
     A0 R0 G0 B0  =>  A0 Yp0 Cb0 Cr0
     
     
     YUV 444AYpCbCr8 can be used for 'y416' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB16U to 'y416' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
     
     
     The per-pixel operation is:
  <pre> @textblock
     uint16_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = A0;
     destPixel[1] = Yp0;
     destPixel[2] = Cb0;
     destPixel[3] = Cr0;
     destPixel += 4;
  @/textblock </pre>
 
  @return
   <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>

     Results are guaranteed to be faithfully rounded.
     This function can work in place.
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB16UTo444AYpCbCr16(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_444CrYpCb10ToARGB8888
     
     @abstract Convert YUV 444CrYpCb10 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 444CrYpCb10 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 444CrYpCb10 format to ARGB8888
     
     
      3 10-bit unsigned components are packed into a 32-bit little-endian word.
 
 <pre> @textblock
           Decreasing Address order (32-bit little-endian)
      byte3           byte2            byte1            byte0
      10-bit Cr            10-bit Yp            10-bit Cb                   =>  A0 R0 G0 B0
      9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  X X
 @/textblock </pre>
 
     
     YUV 444CrYpCb10 can be used for 'v410' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert 'v410' with ITU 601 video range to ARGB8888, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
     
     
     The per-pixel operation is:
    <pre> @textblock
     uint32_t *srcPixel = src.data;
     uint32_t pixel = *srcPixel;
     srcPixel += 1;
 
     Yp0 = getYpFromv410(pixel);
     Cb0 = getCbFromv410(pixel);
     Cr0 = getCrFromv410(pixel);
 
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[4];
     ARGB[0] = alpha;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
   @/textblock </pre>
 
  @return
   <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
   @/textblock </pre>
 

    Results are guaranteed to be faithfully rounded.
    This function can work in place.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_444CrYpCb10ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt8, _ flags: vImage_Flags) -> vImage_Error

/*!
 *   @function vImageConvert_ARGB8888To444CrYpCb10
 *
 *   @abstract Convert ARGB8888 to YUV 444CrYpCb10 format
 *
 *   @param src
 *   A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
 *
 *   @param dest
 *   A pointer to vImage_Buffer that references YUV 444CrYpCb10 destination pixels.
 *
 *   @param info
 *   A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
 *
 *   @param permuteMap
 *   Values that can be used to switch the channel order of dest.
 *   For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
 *   permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
 *   Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.
 *
 *   @param flags
 *   kvImageGetTempBufferSize    Returns 0. Does no work.
 *   kvImageDoNotTile            Disables internal multithreading, if any.
 *
 *   @discussion Convert ARGB8888 to YUV 444CrYpCb10 format
 *
 *
 *   3 10-bit unsigned components are packed into a 32-bit little-endian word.
 *
 *                          Decreasing Address order (32-bit little-endian)
 *                    byte3           byte2            byte1            byte0
 *   A0 R0 G0 B0  =>  10-bit Cr            10-bit Yp            10-bit Cb
 *                    9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  X X
 *
 *
 *   YUV 444CrYpCb10 can be used for 'v410' that is defined in CVPixelBuffer.h.
 *
 *   For example, if we want to use this function to convert ARGB8888 to 'v410' with ITU 601 video range, then we need
 *   generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
 *
 *   Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
 *   converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
 *
 *
 *   The per-pixel operation is:
 *  <pre> @textblock
 *   uint8_t *srcPixel = src.data;
 *   R0 = srcPixel[permuteMap[1]];
 *   G0 = srcPixel[permuteMap[2]];
 *   B0 = srcPixel[permuteMap[3]];
 *   srcPixel += 4;
 *
 *   Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
 *   Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
 *   Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
 *
 *   pixel = makev410(Yp0, Cb0, Cr0);
 *
 *   uint32_t *destPixel = dest.data;
 *   *destPixel = pixel;
 *   destPixel += 1;
 *  @/textblock </pre>
 *
 *  @return
 *  <pre> @textblock
 *   kvImageNoError                  Is returned when there was no error.
 *   kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
 *   kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
 *  @/textblock </pre>
 *
 *
 *   Results are guaranteed to be faithfully rounded.
 *   This function can work in place.
 *
 *  
 */
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To444CrYpCb10(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_444CrYpCb10ToARGB16Q12
     
     @abstract Convert YUV 444CrYpCb10 format to ARGB16Q12
     
     @param src
     A pointer to vImage_Buffer that references YUV 444CrYpCb10 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 16Q12 ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
     
     @param alpha
     A 16Q12 value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 444CrYpCb10 format to ARGB16Q12
     
     
     3 10-bit unsigned components are packed into a 32-bit little-endian word.
     
          Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cr            10-bit Yp            10-bit Cb                   =>  A0 R0 G0 B0
     9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  X X
     
     
     YUV 444CrYpCb10 can be used for 'v410' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert 'v410' with ITU 601 video range to ARGB16Q12, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
     
     
     The per-pixel operation is:
     <pre> @textblock
     uint32_t *srcPixel = src.data;
     uint32_t pixel = *srcPixel;
     srcPixel += 1;
     
     Yp0 = getYpFromv410(pixel);
     Cb0 = getCbFromv410(pixel);
     Cr0 = getCrFromv410(pixel);
     
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 4096 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 4096 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                            ), 4096 )
     
     uint16_t ARGB[4];
     ARGB[0] = alpha;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
    @/textblock </pre>
 
   @return
     <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_444CrYpCb10ToARGB16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: Pixel_16Q12, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB16Q12To444CrYpCb10
     
     @abstract Convert ARGB16Q12 to YUV 444CrYpCb10 format
     
     @param src
     A pointer to vImage_Buffer that references 16Q12 ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 444CrYpCb10 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
    Any ordering of channels is supported as long as each channel appears only once.

 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB16Q12 to YUV 444CrYpCb10 format
     
     
     3 10-bit unsigned components are packed into a 32-bit little-endian word.
     <pre> @textblock
                           Decreasing Address order (32-bit little-endian)
                      byte3           byte2            byte1            byte0
     A0 R0 G0 B0  =>  10-bit Cr            10-bit Yp            10-bit Cb
                      9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  X X
     @/textblock </pre>
     
     
     YUV 444CrYpCb10 can be used for 'v410' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB16Q12 to 'v410' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
     
     
     The per-pixel operation is:
     <pre> @textblock
     uint16_t *srcPixel = src.data;
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   + R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr)
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr     )
     
     pixel = makev410(Yp0, Cb0, Cr0);
     
     uint32_t *destPixel = dest.data;
     destPixel[0] = pixel;
     destPixel += 1;
     @/textblock </pre>
 
@return
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB16Q12To444CrYpCb10(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888
     
     @abstract Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB8888
 

     6 packed YUV pixels are getting mapped into 6 ARGB8888 pixels.
 
     12 10-bit unsigned components are packed into 4 32-bit little-endian words.
 <pre> @textblock

                         Word0
         Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
         10-bit Cr0           10-bit Y0            10-bit Cb0
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0

                         Word1
         Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
         10-bit Y2            10-bit Cb1           10-bit Y1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0

                         Word2
         Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
         10-bit Cb2           10-bit Y3            10-bit Cr1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0

                         Word3
         Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
         10-bit Y5            10-bit Cr2           10-bit Y4
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
 
     
     =>  A0 R0 G0 B0  A1 R1 G1 B1  A2 R2 G2 B2  A3 R3 G3 B3  A4 R4 G4 B4  A5 R5 G5 B5
   @/textblock </pre>
 
     YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 can be used for 'v210' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB8888 to 'v210' with ITU 601 video range, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
     
     
     The per-pixel operation is:
     <pre> @textblock
     uint32_t *srcPixel = src.data;
     pixel0 = srcPixel[0];
     pixel1 = srcPixel[1];
     pixel2 = srcPixel[2];
     pixel3 = srcPixel[3];
     srcPixel += 4;
 
     Yp0 = getYp0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp1 = getYp1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp2 = getYp2Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp3 = getYp3Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp4 = getYp4Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp5 = getYp5Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb0 = getCb0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb1 = getCb1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb2 = getCb2Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr0 = getCr0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr1 = getCr1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr2 = getCr2Fromv210(pixel0, pixel1, pixel2, pixel3);
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     A2 = alpha
     R2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp                            + (Cr1 - CbCr_bias) * Cr_R), 255 )
     G2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_G + (Cr1 - CbCr_bias) * Cr_G), 255 )
     B2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_B                           ), 255 )
     A3 = alpha
     R3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp                            + (Cr1 - CbCr_bias) * Cr_R), 255 )
     G3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_G + (Cr1 - CbCr_bias) * Cr_G), 255 )
     B3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_B                           ), 255 )
     A4 = alpha
     R4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp                            + (Cr2 - CbCr_bias) * Cr_R), 255 )
     G4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_G + (Cr2 - CbCr_bias) * Cr_G), 255 )
     B4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_B                           ), 255 )
     A5 = alpha
     R5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp                            + (Cr2 - CbCr_bias) * Cr_R), 255 )
     G5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_G + (Cr2 - CbCr_bias) * Cr_G), 255 )
     B5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_B                           ), 255 )
 
     uint8_t ARGB[24];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     ARGB[8] = A2;
     ARGB[9] = R2;
     ARGB[10] = G2;
     ARGB[11] = B2;
     ARGB[12] = A3;
     ARGB[13] = R3;
     ARGB[14] = G3;
     ARGB[15] = B3;
     ARGB[16] = A4;
     ARGB[17] = R4;
     ARGB[18] = G4;
     ARGB[19] = B4;
     ARGB[20] = A5;
     ARGB[21] = R5;
     ARGB[22] = G5;
     ARGB[23] = B5;
 
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel[8] = ARGB[permuteMap[0]+8];
     destPixel[9] = ARGB[permuteMap[1]+8];
     destPixel[10] = ARGB[permuteMap[2]+8];
     destPixel[11] = ARGB[permuteMap[3]+8];
     destPixel[12] = ARGB[permuteMap[0]+12];
     destPixel[13] = ARGB[permuteMap[1]+12];
     destPixel[14] = ARGB[permuteMap[2]+12];
     destPixel[15] = ARGB[permuteMap[3]+12];
     destPixel[16] = ARGB[permuteMap[0]+16];
     destPixel[17] = ARGB[permuteMap[1]+16];
     destPixel[18] = ARGB[permuteMap[2]+16];
     destPixel[19] = ARGB[permuteMap[3]+16];
     destPixel[20] = ARGB[permuteMap[0]+20];
     destPixel[21] = ARGB[permuteMap[1]+20];
     destPixel[22] = ARGB[permuteMap[2]+20];
     destPixel[23] = ARGB[permuteMap[3]+20];
     destPixel += 24;
    @/textblock </pre>
 

  @return
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>
 
    Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt8, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10
     
     @abstract Convert ARGB8888 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format.
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format
 
 
     6 ARGB8888 pixels are getting mapped into 6 packed YUV pixels.
 
     A0 R0 G0 B0  A1 R1 G1 B1  A2 R2 G2 B2  A3 R3 G3 B3  A4 R4 G4 B4  A5 R5 G5 B5  =>
 
     12 10-bit unsigned components are packed into 4 32-bit little-endian words.
 
    <pre> @textblock
     Word0
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cr0           10-bit Y0            10-bit Cb0
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
 
     Word1
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y2            10-bit Cb1           10-bit Y1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
 
     Word2
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cb2           10-bit Y3            10-bit Cr1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
 
     Word3
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y5            10-bit Cr2           10-bit Y4
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
    @/textblock </pre>
 
     YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 can be used for 'v210' that is defined in CVPixelBuffer.h.
 
     For example, if we want to use this function to convert ARGB8888 to 'v210' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
     
     The per-pixel operation is:
   <pre> @textblock
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A2 = srcPixel[permuteMap[0]];
     R2 = srcPixel[permuteMap[1]];
     G2 = srcPixel[permuteMap[2]];
     B2 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A3 = srcPixel[permuteMap[0]];
     R3 = srcPixel[permuteMap[1]];
     G3 = srcPixel[permuteMap[2]];
     B3 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A4 = srcPixel[permuteMap[0]];
     R4 = srcPixel[permuteMap[1]];
     G4 = srcPixel[permuteMap[2]];
     B4 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A5 = srcPixel[permuteMap[0]];
     R5 = srcPixel[permuteMap[1]];
     G5 = srcPixel[permuteMap[2]];
     B5 = srcPixel[permuteMap[3]];
     srcPixel += 4;
 
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     Yp2 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R2 * R_Yp      + G2 * G_Yp + B2 * B_Yp     )
     Yp3 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R3 * R_Yp      + G3 * G_Yp + B3 * B_Yp     )
     Cb1 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R2 * R_Cb      + G2 * G_Cb + B2 * B_Cb_R_Cr
                                                   +   R3 * R_Cb      + G3 * G_Cb + B3 * B_Cb_R_Cr) / 2 )
     Cr1 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R2 * B_Cb_R_Cr + G2 * G_Cr + B2 * B_Cr
                                                   +   R3 * B_Cb_R_Cr + G3 * G_Cr + B3 * B_Cr     ) / 2 )
     Yp4 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R4 * R_Yp      + G4 * G_Yp + B4 * B_Yp     )
     Yp5 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R5 * R_Yp      + G5 * G_Yp + B5 * B_Yp     )
     Cb2 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R4 * R_Cb      + G4 * G_Cb + B4 * B_Cb_R_Cr
                                                   +   R5 * R_Cb      + G5 * G_Cb + B5 * B_Cb_R_Cr) / 2 )
     Cr2 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R4 * B_Cb_R_Cr + G4 * G_Cr + B4 * B_Cr
                                                   +   R5 * B_Cb_R_Cr + G5 * G_Cr + B5 * B_Cr     ) / 2 )
 
     uint32_t *destPixel = dest.data;
     packv210AndStore(destPixel, Yp0, Yp1, Yp2, Yp3, Yp4, Yp5, Cb0, Cb1, Cb2, Cr0, Cr1, Cr2);
     destPixel += 4;
   @/textblock </pre>
 

  @return 
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12
     
     @abstract Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB16Q12
     
     @param src
     A pointer to vImage_Buffer that references YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 16Q12 ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
     
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format to ARGB16Q12
     
     
     6 packed YUV pixels are getting mapped into 6 ARGB16Q12 pixels.
     
     12 10-bit unsigned components are packed into 4 32-bit little-endian words.
     <pre> @textblock
     Word0
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cr0           10-bit Y0            10-bit Cb0
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word1
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y2            10-bit Cb1           10-bit Y1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word2
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cb2           10-bit Y3            10-bit Cr1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word3
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y5            10-bit Cr2           10-bit Y4
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     
     =>  A0 R0 G0 B0  A1 R1 G1 B1  A2 R2 G2 B2  A3 R3 G3 B3  A4 R4 G4 B4  A5 R5 G5 B5
     @/textblock </pre>
     
     YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 can be used for 'v210' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB16Q12 to 'v210' with ITU 601 video range, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
     
     
     The per-pixel operation is:
    <pre> @textblock
 
     uint32_t *srcPixel = src.data;
     pixel0 = srcPixel[0];
     pixel1 = srcPixel[1];
     pixel2 = srcPixel[2];
     pixel3 = srcPixel[3];
     srcPixel += 4;
     
     Yp0 = getYp0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp1 = getYp1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp2 = getYp2Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp3 = getYp3Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp4 = getYp4Fromv210(pixel0, pixel1, pixel2, pixel3);
     Yp5 = getYp5Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb0 = getCb0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb1 = getCb1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cb2 = getCb2Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr0 = getCr0Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr1 = getCr1Fromv210(pixel0, pixel1, pixel2, pixel3);
     Cr2 = getCr2Fromv210(pixel0, pixel1, pixel2, pixel3);
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 4096 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 4096 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 4096 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 4096 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 4096 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 4096 )
     A2 = alpha
     R2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp                            + (Cr1 - CbCr_bias) * Cr_R), 4096 )
     G2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_G + (Cr1 - CbCr_bias) * Cr_G), 4096 )
     B2 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp2 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_B                           ), 4096 )
     A3 = alpha
     R3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp                            + (Cr1 - CbCr_bias) * Cr_R), 4096 )
     G3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_G + (Cr1 - CbCr_bias) * Cr_G), 4096 )
     B3 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp3 - Yp_bias) * Yp + (Cb1 - CbCr_bias) * Cb_B                           ), 4096 )
     A4 = alpha
     R4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp                            + (Cr2 - CbCr_bias) * Cr_R), 4096 )
     G4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_G + (Cr2 - CbCr_bias) * Cr_G), 4096 )
     B4 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp4 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_B                           ), 4096 )
     A5 = alpha
     R5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp                            + (Cr2 - CbCr_bias) * Cr_R), 4096 )
     G5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_G + (Cr2 - CbCr_bias) * Cr_G), 4096 )
     B5 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp5 - Yp_bias) * Yp + (Cb2 - CbCr_bias) * Cb_B                           ), 4096 )
     
     uint16_t ARGB[24];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     ARGB[8] = A2;
     ARGB[9] = R2;
     ARGB[10] = G2;
     ARGB[11] = B2;
     ARGB[12] = A3;
     ARGB[13] = R3;
     ARGB[14] = G3;
     ARGB[15] = B3;
     ARGB[16] = A4;
     ARGB[17] = R4;
     ARGB[18] = G4;
     ARGB[19] = B4;
     ARGB[20] = A5;
     ARGB[21] = R5;
     ARGB[22] = G5;
     ARGB[23] = B5;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel[8] = ARGB[permuteMap[0]+8];
     destPixel[9] = ARGB[permuteMap[1]+8];
     destPixel[10] = ARGB[permuteMap[2]+8];
     destPixel[11] = ARGB[permuteMap[3]+8];
     destPixel[12] = ARGB[permuteMap[0]+12];
     destPixel[13] = ARGB[permuteMap[1]+12];
     destPixel[14] = ARGB[permuteMap[2]+12];
     destPixel[15] = ARGB[permuteMap[3]+12];
     destPixel[16] = ARGB[permuteMap[0]+16];
     destPixel[17] = ARGB[permuteMap[1]+16];
     destPixel[18] = ARGB[permuteMap[2]+16];
     destPixel[19] = ARGB[permuteMap[3]+16];
     destPixel[20] = ARGB[permuteMap[0]+20];
     destPixel[21] = ARGB[permuteMap[1]+20];
     destPixel[22] = ARGB[permuteMap[2]+20];
     destPixel[23] = ARGB[permuteMap[3]+20];
     destPixel += 24;
     @/textblock </pre>
 

 @return 
   <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
   @/textblock </pre>
 
     Note: Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: Pixel_16Q12, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10
     
     @abstract Convert ARGB16Q12 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format.
     
     @param src
     A pointer to vImage_Buffer that references 16Q12 ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
     Any ordering of channels is supported as long as each channel appears only once.

 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB16Q12 to YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 format
     
     
     6 ARGB16Q12 pixels are getting mapped into 6 packed YUV pixels.
     <pre> @textblock
 
     A0 R0 G0 B0  A1 R1 G1 B1  A2 R2 G2 B2  A3 R3 G3 B3  A4 R4 G4 B4  A5 R5 G5 B5  =>
     
     12 10-bit unsigned components are packed into 4 32-bit little-endian words.
     
     Word0
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cr0           10-bit Y0            10-bit Cb0
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word1
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y2            10-bit Cb1           10-bit Y1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word2
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Cb2           10-bit Y3            10-bit Cr1
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     
     Word3
     Decreasing Address order (32-bit little-endian)
     byte3           byte2            byte1            byte0
     10-bit Y5            10-bit Cr2           10-bit Y4
     X X 9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0  9 8 7 6 5 4 3 2 1 0
     @/textblock </pre>
     
     YUV 422CrYpCbYpCbYpCbYpCrYpCrYp10 can be used for 'v210' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB16Q12 to 'v210' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
     
     The per-pixel operation is:
     
    <pre> @textblock
 
     uint16_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A2 = srcPixel[permuteMap[0]];
     R2 = srcPixel[permuteMap[1]];
     G2 = srcPixel[permuteMap[2]];
     B2 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A3 = srcPixel[permuteMap[0]];
     R3 = srcPixel[permuteMap[1]];
     G3 = srcPixel[permuteMap[2]];
     B3 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A4 = srcPixel[permuteMap[0]];
     R4 = srcPixel[permuteMap[1]];
     G4 = srcPixel[permuteMap[2]];
     B4 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A5 = srcPixel[permuteMap[0]];
     R5 = srcPixel[permuteMap[1]];
     G5 = srcPixel[permuteMap[2]];
     B5 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     Yp2 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R2 * R_Yp      + G2 * G_Yp + B2 * B_Yp     )
     Yp3 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R3 * R_Yp      + G3 * G_Yp + B3 * B_Yp     )
     Cb1 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R2 * R_Cb      + G2 * G_Cb + B2 * B_Cb_R_Cr
                                                   +   R3 * R_Cb      + G3 * G_Cb + B3 * B_Cb_R_Cr) / 2 )
     Cr1 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R2 * B_Cb_R_Cr + G2 * G_Cr + B2 * B_Cr
                                                   +   R3 * B_Cb_R_Cr + G3 * G_Cr + B3 * B_Cr     ) / 2 )
     Yp4 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R4 * R_Yp      + G4 * G_Yp + B4 * B_Yp     )
     Yp5 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R5 * R_Yp      + G5 * G_Yp + B5 * B_Yp     )
     Cb2 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R4 * R_Cb      + G4 * G_Cb + B4 * B_Cb_R_Cr
                                                   +   R5 * R_Cb      + G5 * G_Cb + B5 * B_Cb_R_Cr) / 2 )
     Cr2 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R4 * B_Cb_R_Cr + G4 * G_Cr + B4 * B_Cr
                                                   +   R5 * B_Cb_R_Cr + G5 * G_Cr + B5 * B_Cr     ) / 2 )
     
     uint32_t *destPixel = dest.data;
     packv210AndStore(destPixel, Yp0, Yp1, Yp2, Yp3, Yp4, Yp5, Cb0, Cb1, Cb2, Cr0, Cr1, Cr2);
     destPixel += 4;
     @/textblock </pre>
     
  @return     
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_422CbYpCrYp16ToARGB8888
     
     @abstract Convert YUV 422CbYpCrYp16 format to ARGB8888
     
     @param src
     A pointer to vImage_Buffer that references YUV 422CbYpCrYp16 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param alpha
     A value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>  
 
     @discussion Convert YUV 422CbYpCrYp16 format to ARGB8888
     <pre> @textblock
     
                            pixel0-1
     byte0 byte1   byte2 byte3   byte4 byte5   byte6 byte7
     LE-16-bit-Cb  LE-16-bit-Y0  LE-16-bit-Cr  LE-16-bit-Y1  =>  A0 R0 G0 B0  A1 R1 G1 B1
     
     (LE and left-justified 16-bit-per-component)
     @/textblock </pre>
     
     YUV 422CbYpCrYp16 can be used for 16-bit 'v216' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB8888 to 16-bit 'v216' with ITU 601 video range, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
     
     
     The per-pixel operation is:
     <pre> @textblock
 
     uint64_t *srcPixel = src.data;
     uint64_t pixel = *srcPixel;
     Yp0 = getYp0From16bitv216(pixel);
     Cb0 = getCb0From16bitv216(pixel);
     Yp1 = getYp1From16bitv216(pixel);
     Cr0 = getCr0From16bitv216(pixel);
     srcPixel += 1;
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 255 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 255 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 255 )
     
     uint8_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;
    @/textblock </pre>
 
 
@return
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock <pre>
 
     Results are guaranteed to be faithfully rounded.
     This function can work in place.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_422CbYpCrYp16ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt8, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888To422CbYpCrYp16
     
     @abstract Convert ARGB8888 to YUV 422CbYpCrYp16 format.
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 422CbYpCrYp16 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.
 
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB8888 to YUV 422CbYpCrYp16 format
     <pre> @textblock
     
                                                        pixel0-1
                                   byte0 byte1   byte2 byte3   byte4 byte5   byte6 byte7
     A0 R0 G0 B0  A1 R1 G1 B1  =>  LE-16-bit-Cb  LE-16-bit-Y0  LE-16-bit-Cr  LE-16-bit-Y1
     
     (LE and left-justified 16-bit-per-component)
     @/textblock </pre>
     
     YUV 422CbYpCrYp16 can be used for 16-bit 'v216' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB8888 to 16-bit 'v216' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
     
     The per-pixel operation is:
     <pre> @textblock
 
     uint8_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R0 * R_Yp      + G0 * G_Yp + B0 * B_Yp     )
     Yp1 = ROUND_TO_NEAREST_INTEGER( Yp_bias   +   R1 * R_Yp      + G1 * G_Yp + B1 * B_Yp     )
     Cb0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * R_Cb      + G0 * G_Cb + B0 * B_Cb_R_Cr
                                                   +   R1 * R_Cb      + G1 * G_Cb + B1 * B_Cb_R_Cr) / 2 )
     Cr0 = ROUND_TO_NEAREST_INTEGER( CbCr_bias + ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr
                                                   +   R1 * B_Cb_R_Cr + G1 * G_Cr + B1 * B_Cr     ) / 2 )
     
     uint64_t *destPixel = dest.data;
     pack16bitv216AndStore(destPixel, Yp0, Yp1, Cb0, Cr0);
     destPixel += 1;
   
     @/textblock </pre>
 
  @return
    <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
    @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
     This function can work in place.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888To422CbYpCrYp16(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_422CbYpCrYp16ToARGB16U
     
     @abstract Convert YUV 422CbYpCrYp16 format to ARGB16U
     
     @param src
     A pointer to vImage_Buffer that references YUV 422CbYpCrYp16 source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 16-bit ARGB interleaved destination pixels.
     
     @param info
     A pointer to vImage_YpCbCrToRGBConversionInfo which contains info coeffcient and preBias values.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
     
     @param alpha
     A 16-bit value for alpha channel in dest.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
 @/textblock </pre>
 
     @discussion Convert YUV 422CbYpCrYp16 format to ARGB16U
     <pre> @textblock
     
                            pixel0-1
     byte0 byte1   byte2 byte3   byte4 byte5   byte6 byte7
     LE-16-bit-Cb  LE-16-bit-Y0  LE-16-bit-Cr  LE-16-bit-Y1  =>  A0 R0 G0 B0  A1 R1 G1 B1
     
     (LE and left-justified 16-bit-per-component)
     @/textblock </pre>
     
     YUV 422CbYpCrYp16 can be used for 16-bit 'v216' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB16U to 16-bit 'v216' with ITU 601 video range, then we need
     generate vImage_YpCbCrToARGB by vImageConvert_YpCbCrToARGB_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, Yp, Cr_R, Cb_G, Cr_G, and Cb_B are calculated and converted into the right
     format by vImageConvert_YpCbCrToARGB_GenerateConversion() inside of vImage_YpCbCrToARGB.
     
     
     The per-pixel operation is:
 <pre> @textblock
 
     uint64_t *srcPixel = src.data;
     uint64_t pixel = *srcPixel;
     Yp0 = getYp0From16bitv216(pixel);
     Cb0 = getCb0From16bitv216(pixel);
     Yp1 = getYp1From16bitv216(pixel);
     Cr0 = getCr0From16bitv216(pixel);
     srcPixel += 1;
     
     A0 = alpha
     R0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 65535 )
     G0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 65535 )
     B0 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp0 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 65535 )
     A1 = alpha
     R1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp                            + (Cr0 - CbCr_bias) * Cr_R), 65535 )
     G1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_G + (Cr0 - CbCr_bias) * Cr_G), 65535 )
     B1 = CLAMP(0, ROUND_TO_NEAREST_INTEGER((Yp1 - Yp_bias) * Yp + (Cb0 - CbCr_bias) * Cb_B                           ), 65535 )
     
     uint16_t ARGB[8];
     ARGB[0] = A0;
     ARGB[1] = R0;
     ARGB[2] = G0;
     ARGB[3] = B0;
     ARGB[4] = A1;
     ARGB[5] = R1;
     ARGB[6] = G1;
     ARGB[7] = B1;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel[4] = ARGB[permuteMap[0]+4];
     destPixel[5] = ARGB[permuteMap[1]+4];
     destPixel[6] = ARGB[permuteMap[2]+4];
     destPixel[7] = ARGB[permuteMap[3]+4];
     destPixel += 8;

 @/textblock </pre>


 @return 
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
 @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_422CbYpCrYp16ToARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_YpCbCrToARGB>, _ permuteMap: UnsafePointer<UInt8>, _ alpha: UInt16, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB16UTo422CbYpCrYp16
     
     @abstract Convert ARGB16U to YUV 422CbYpCrYp16 format.
     
     @param src
     A pointer to vImage_Buffer that references 16-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references YUV 422CbYpCrYp16 destination pixels.
     
     @param info
     A pointer to vImage_RGBToYpCbCrConversionInfo which contains info coeffcient and postBias values.
     This is generated by vImageConvert_ARGBToYpCbCr_GenerateConversion().
     
     @param permuteMap
     Values that can be used to switch the channel order of src.
     permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
     
     @param flags
 <pre> @textblock
     kvImageGetTempBufferSize    Returns 0. Does no work.
     kvImageDoNotTile            Disables internal multithreading, if any.
 @/textblock </pre>
 
 
     @discussion Convert ARGB16U to YUV 422CbYpCrYp16 format
     <pre> @textblock
     
                                                        pixel0-1
                                   byte0 byte1   byte2 byte3   byte4 byte5   byte6 byte7
     A0 R0 G0 B0  A1 R1 G1 B1  =>  LE-16-bit-Cb  LE-16-bit-Y0  LE-16-bit-Cr  LE-16-bit-Y1
     
     (LE and left-justified 16-bit-per-component)
     @/textblock </pre>
     
     YUV 422CbYpCrYp16 can be used for 16-bit 'v216' that is defined in CVPixelBuffer.h.
     
     For example, if we want to use this function to convert ARGB16U to 16-bit 'v216' with ITU 601 video range, then we need
     generate vImage_ARGBToYpCbCr by vImageConvert_ARGBToYpCbCr_GenerateConversion() and call this function.
     
     Yp_bias, CbCr_bias, CbCr_bias, R_Yp, G_Yp, B_Yp, R_Cb, G_Cb, B_Cb_R_Cr, G_Cr and B_Cr are calculated and
     converted into the right format by vImageConvert_ARGBToYpCbCr_GenerateConversion() inside of vImage_ARGBToYpCbCr.
     
     The per-pixel operation is:
     <pre> @textblock
 
     uint16_t *srcPixel = src.data;
     A0 = srcPixel[permuteMap[0]];
     R0 = srcPixel[permuteMap[1]];
     G0 = srcPixel[permuteMap[2]];
     B0 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     A1 = srcPixel[permuteMap[0]];
     R1 = srcPixel[permuteMap[1]];
     G1 = srcPixel[permuteMap[2]];
     B1 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     Yp0 = Yp_bias + ROUND_TO_NEAREST_INTEGER( R0 * R_Yp + G0 * G_Yp + B0 * B_Yp )
     Yp1 = Yp_bias + ROUND_TO_NEAREST_INTEGER( R1 * R_Yp + G1 * G_Yp + B1 * B_Yp )
     R0 += R1;  G0 += G1;   B0 += B1;
     Cb0 = CbCr_bias + ROUND_TO_NEAREST_INTEGER( ( R0 * R_Cb + G0 * G_Cb + B0 * B_Cb_R_Cr) / 2 )
     Cr0 = CbCr_bias + ROUND_TO_NEAREST_INTEGER( ( R0 * B_Cb_R_Cr + G0 * G_Cr + B0 * B_Cr) / 2 )
     
     uint64_t *destPixel = dest.data;
     pack16bitv216AndStore(destPixel, Yp0, Yp1, Cb0, Cr0);
     destPixel += 1;
        
    @/textblock </pre>
 
 
  @return
   <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
   @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
     Chroma is sampled at center by default.
 
     Note: vImage doesn't do anything with the alpha here. It is just thrown away. The operation is therefore best suited for kCGImageAlphaNoneSkip<First/Last>
           images.  If it has alpha, you may wish to composite against an opaque background first, before the transparency information is lost.
           If it is premultiplied by alpha, you at minimum should unpremultiply it first, or composite it against an opaque background. See
           vImageUnpremultiplyData_ARGB16U() and vImageFlatten_ARGB16U().
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB16UTo422CbYpCrYp16(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ info: UnsafePointer<vImage_ARGBToYpCbCr>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_RGBA1010102ToARGB8888
     
     @abstract Convert RGBA1010102 to ARGB8888 format.
     
     @param src
     A pointer to vImage_Buffer that references 10-bit RGB interleaved source pixels. Source pixels must be at least 4 byte aligned.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved destination pixels. Destination pixels may have any alignment.
 
     @param RGB101010RangeMax
     A maximum value for 10-bit RGB pixel.
 
     @param RGB101010RangeMin
     A minimum value for 10-bit RGB pixel.
 
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param flags
 <pre> @textblock
     kvImageDoNotTile            Disables internal multithreading, if any.
 @/textblock <pre>
 
     @discussion Convert RGBA1010102 to ARGB8888 format
     
     RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
     except that this format uses the least significant 2 bits for alpha channel.
 
     This format is 10-bit big endian 32-bit pixels.
 
     RGB101010RangeMax & RGB101010RangeMin are available for non-full-range pixel values.
     For full-range pixel values, the user can set these as
 
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
 
     The per-pixel operation is:
     <pre> @textblock
 
     uint32_t *srcPixel = src.data;
     uint32_t pixel = ntohl(srcPixel[0]);
     srcPixel += 1;
 
     int32_t A2  = pixel & 0x3;
     int32_t R10 = (pixel >> 22) & 0x3ff;
     int32_t G10 = (pixel >> 12) & 0x3ff;
     int32_t B10 = (pixel >>  2) & 0x3ff;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
 
     A2  = (A2 * UCHAR_MAX + 1) / 3;
     R10 = ((R10 - RGB101010RangeMin) * UCHAR_MAX + (range10 >> 1)) / range10;
     G10 = ((G10 - RGB101010RangeMin) * UCHAR_MAX + (range10 >> 1)) / range10;
     B10 = ((B10 - RGB101010RangeMin) * UCHAR_MAX + (range10 >> 1)) / range10;
 
     uint8_t R8, G8, B8;
     R8 = CLAMP(0, R10, UCHAR_MAX);
     G8 = CLAMP(0, G10, UCHAR_MAX);
     B8 = CLAMP(0, B10, UCHAR_MAX);
 
     uint8_t ARGB[4];
     ARGB[0] = A2;
     ARGB[1] = R8;
     ARGB[2] = G8;
     ARGB[3] = B8;
 
     uint8_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
     @/textblock <pre>
 
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
 @/textblock </pre>
 
     Note: Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_RGBA1010102ToARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ RGB101010RangeMin: Int32, _ RGB101010RangeMax: Int32, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB8888ToRGBA1010102
     
     @abstract Convert ARGB8888 to RGBA1010102 format.
     
     @param src
     A pointer to vImage_Buffer that references 8-bit ARGB interleaved source pixels. Source pixels may have any alignment.
     
     @param dest
     A pointer to vImage_Buffer that references 10-bit RGB interleaved destination pixels.  Destination pixels must be at least 4 byte aligned.
     
     @param RGB101010RangeMax
     A maximum value for 10-bit RGB pixel.
 
     @param RGB101010RangeMin
     A minimum value for 10-bit RGB pixel.
 
     @param permuteMap
     Values that can be used to switch the channel order of src.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB8888.
     permuteMap[4] = {3, 2, 1, 0} is BGRA8888.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
     
     @param flags
 <pre> @textblock
     kvImageDoNotTile            Disables internal multithreading, if any.
 @/textblock </pre>
 
     @discussion Convert ARGB8888 to RGBA1010102 format.
     
     RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
     except that this format uses the least significant 2 bits for alpha channel.
 
     This format is 10-bit big endian 32-bit pixels.
 
     RGB101010RangeMax & RGB101010RangeMin are available for non-full-range pixel values.
     For full-range pixel values, the user can set these as
 
 <pre> @textblock
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
 @/textblock </pre>
 
     The per-pixel operation is:
 <pre> @textblock
 
     uint8_t *srcPixel = src.data;
     A8 = srcPixel[permuteMap[0]];
     R8 = srcPixel[permuteMap[1]];
     G8 = srcPixel[permuteMap[2]];
     B8 = srcPixel[permuteMap[3]];
     srcPixel += 4;
 
     int32_t R10, G10, B10;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     int32_t rounding = UCHAR_MAX >> 1;
     R10 = ((R8 * range10 + rounding) / UCHAR_MAX) + RGB101010RangeMin;
     G10 = ((G8 * range10 + rounding) / UCHAR_MAX) + RGB101010RangeMin;
     B10 = ((B8 * range10 + rounding) / UCHAR_MAX) + RGB101010RangeMin;
     A10 = ((A10 * 3 + rounding) / UCHAR_MAX);
 
     uint32_t *destPixel = dest.data;
     destPixel[0] = htonl((R10 << 22) | (G10 << 12) | (B10 << 2) | A10);
     destPixel += 1;
 @/textblock </pre>
 
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
 @/textblock </pre>
 
     Note
     ----
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB8888ToRGBA1010102(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ RGB101010RangeMin: Int32, _ RGB101010RangeMax: Int32, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_RGBA1010102ToARGB16Q12
     
     @abstract Convert RGBA1010102 to ARGB16Q12 format.
     
     @param src
     A pointer to vImage_Buffer that references 10-bit RGB interleaved source pixels.  Samples must be at least 4 byte aligned.
     
     @param dest
     A pointer to vImage_Buffer that references 16Q12 ARGB interleaved destination pixels.  Samples must be at least 2 byte aligned.
     
     @param RGB101010RangeMax
     A maximum value for 10-bit RGB pixel.
     
     @param RGB101010RangeMin
     A minimum value for 10-bit RGB pixel.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel is unique.  That is, ARRG is not an allowed order
     because R is repeated.
 
     @param flags
 <pre> @textblock
     kvImageDoNotTile            Disables internal multithreading, if any.
 @/textblock </pre>
 
     @discussion Convert RGBA1010102 to ARGB16Q12 format
     
     RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
     except that this format uses the least significant 2 bits for alpha channel.
     
     This format is 10-bit big endian 32-bit pixels.
     
     RGB101010RangeMax & RGB101010RangeMin are available for non-full-range pixel values.
     For full-range pixel values, the user can set these as
     
 <pre> @textblock
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
 @/textblock </pre>
 
     The per-pixel operation is:
     
 <pre> @textblock
     uint32_t *srcPixel = src.data;
     uint32_t pixel = ntohl(srcPixel[0]);
     srcPixel += 1;
     
     int32_t A2  = pixel & 0x3;
     int32_t R10 = (pixel >> 22) & 0x3ff;
     int32_t G10 = (pixel >> 12) & 0x3ff;
     int32_t B10 = (pixel >>  2) & 0x3ff;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     
     int16_t R16, G16, B16;
     A2  = (A2 * 4096 + 1) / 3;
     R16 = ((R10 - RGB101010RangeMin) * 4096 + (range10 >> 1)) / range10;
     G16 = ((G10 - RGB101010RangeMin) * 4096 + (range10 >> 1)) / range10;
     B16 = ((B10 - RGB101010RangeMin) * 4096 + (range10 >> 1)) / range10;
     
     R16 = CLAMP(INT16_MIN, R16, INT16_MAX);
     G16 = CLAMP(INT16_MIN, G16, INT16_MAX);
     B16 = CLAMP(INT16_MIN, B16, INT16_MAX);
     
     int16_t ARGB[4];
     ARGB[0] = A2;
     ARGB[1] = R16;
     ARGB[2] = G16;
     ARGB[3] = B16;
     
     int16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
 @/textblock </pre>
 
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
 @/textblock </pre>
 
     Note: Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_RGBA1010102ToARGB16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ RGB101010RangeMin: Int32, _ RGB101010RangeMax: Int32, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB16Q12ToRGBA1010102
     
     @abstract Convert ARGB16Q12 to RGBA1010102 format.
     
     @param src
     A pointer to vImage_Buffer that references 16Q12 ARGB interleaved source pixels.   ARGB16Q12 pixels must be at least 2 byte aligned.
     
     @param dest
     A pointer to vImage_Buffer that references 10-bit RGB interleaved destination pixels.  RGBA1010102 pixels must be at least 4 byte aligned.
     
     @param RGB101010RangeMax
     A maximum value for the range of 10-bit RGB pixel.
 
     @param RGB101010RangeMin
     A minimum value for the range of 10-bit RGB pixel.
 
     @param RGB101010Max
     A maximum value for 10-bit RGB pixel.
 
     @param RGB101010Min
     A minimum value for 10-bit RGB pixel.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16Q12.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16Q12.
     
     @param flags
  <pre> @textblock
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB16Q12 to RGBA1010102 format.
     
     RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
     except that this format uses the least significant 2 bits for alpha channel.
     
     This format is 10-bit big endian 32-bit pixels.
     
     RGB101010RangeMax & RGB101010RangeMin are available for non-full-range pixel values.
     For full-range pixel values, the user can set these as
     
 <pre> @textblock
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
 @/textblock </pre>
 
     RGB101010Max & RGB101010Min are available to specify the min / max of the representation.
     This will be used as clipping the results.
 
 <pre> @textblock
     RGB101010Max  = 1023;
     RGB101010Min  = 0;
 @/textblock </pre>

     This is needed because 16Q12 has a chance to be outside of [0.0, 1.0] range and we are converting those
     values into video-range. Then, there will be some numbers outside of 10-bit video-range and we want those 
     values to be representable as much as possible.
 
     The per-pixel operation is:
 <pre> @textblock
 
     int16_t *srcPixel = src.data;
     A16 = srcPixel[permuteMap[0]];
     R16 = srcPixel[permuteMap[1]];
     G16 = srcPixel[permuteMap[2]];
     B16 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     int32_t R10, G10, B10;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     R10 = CLAMP(RGB101010Min, ((R16 * range10 + 2048) >> 12) + RGB101010RangeMin, RGB101010Max);
     G10 = CLAMP(RGB101010Min, ((G16 * range10 + 2048) >> 12) + RGB101010RangeMin, RGB101010Max);
     B10 = CLAMP(RGB101010Min, ((B16 * range10 + 2048) >> 12) + RGB101010RangeMin, RGB101010Max);
     A10 = CLAMP( 0, (A16 * 3 + 2048) >> 12), 3);
     
     uint32_t *destPixel = dest.data;
     destPixel[0] = htonl((R10 << 22) | (G10 << 12) | (B10 << 2) | A10);
     destPixel += 1;
 @/textblock </pre>
 
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
     kvImageInvalidParameter         Is returned when RGB101010Min > RGB101010Max || RGB101010RangeMin > RGB101010RangeMax
 @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB16Q12ToRGBA1010102(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ RGB101010RangeMin: Int32, _ RGB101010RangeMax: Int32, _ RGB101010Min: Int32, _ RGB101010Max: Int32, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_RGBA1010102ToARGB16U
     
     @abstract Convert RGBA1010102 to ARGB16U format.
     
     @param src
     A pointer to vImage_Buffer that references 10-bit RGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 16-bit ARGB interleaved destination pixels.
     
     @param RGB101010RangeMax
     A maximum value for 10-bit RGB pixel.
     
     @param RGB101010RangeMin
     A minimum value for 10-bit RGB pixel.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3.
 
     @param flags
  <pre> @textblock
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert RGBA1010102 to ARGB16U format
     
     RGBA1010102 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
     except that this format uses the least significant 2 bits for alpha channel.
 
     This format is 10-bit big endian 32-bit pixels.
 
     RGB101010RangeMax & RGB101010RangeMin are available for non-full-range pixel values.
     For full-range pixel values, the user can set these as
     
 <pre> @textblock
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
 @/textblock </pre>
 
     The per-pixel operation is:
 <pre> @textblock
 
     uint32_t *srcPixel = src.data;
     uint32_t pixel = ntohl(srcPixel[0]);
     srcPixel += 1;
     
     int32_t A2  = pixel & 0x3;
     int32_t R10 = (pixel >> 22) & 0x3ff;
     int32_t G10 = (pixel >> 12) & 0x3ff;
     int32_t B10 = (pixel >>  2) & 0x3ff;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     
     A2  = (A2 * USHRT_MAX + 1) / 3;
     R10 = ((R10 - RGB101010RangeMin) * USHRT_MAX + (range10 >> 1)) / range10;
     G10 = ((G10 - RGB101010RangeMin) * USHRT_MAX + (range10 >> 1)) / range10;
     B10 = ((B10 - RGB101010RangeMin) * USHRT_MAX + (range10 >> 1)) / range10;
     
     uint16_t R16, G16, B16;
     R16 = CLAMP(0, R10, USHRT_MAX);
     G16 = CLAMP(0, G10, USHRT_MAX);
     B16 = CLAMP(0, B10, USHRT_MAX);
     
     uint16_t ARGB[4];
     ARGB[0] = A2;
     ARGB[1] = R16;
     ARGB[2] = G16;
     ARGB[3] = B16;
     
     uint16_t *destPixel = dest.data;
     destPixel[0] = ARGB[permuteMap[0]];
     destPixel[1] = ARGB[permuteMap[1]];
     destPixel[2] = ARGB[permuteMap[2]];
     destPixel[3] = ARGB[permuteMap[3]];
     destPixel += 4;
 @/textblock </pre>
 
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
 @/textblock </pre>
 
     Note: Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_RGBA1010102ToARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ RGB101010RangeMin: Int32, _ RGB101010RangeMax: Int32, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageConvert_ARGB16UToRGBA1010102
     
     @abstract Convert ARGB16U to RGBA1010102 format.
     
     @param src
     A pointer to vImage_Buffer that references 16-bit ARGB interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 10-bit RGB interleaved destination pixels.
     
     @param RGB101010RangeMax
     A maximum value for 10-bit RGB pixel.
     
     @param RGB101010RangeMin
     A minimum value for 10-bit RGB pixel.
     
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[4] = {0, 1, 2, 3} or NULL are ARGB16U.
     permuteMap[4] = {3, 2, 1, 0} is BGRA16U.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, 2, or 3, as long as each channel appears only once.
     
     @param flags
  <pre> @textblock
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion Convert ARGB16U to RGB101010 format.
     
     RGB101010 is almost the same format that is defined in CVPixelBuffer.h as 'kCVPixelFormatType_30RGB'
     except that this format uses the least significant 2 bits for alpha channel.
 
     This format is 10-bit big endian 32-bit pixels. 
 
     RGB101010RangeMax & RGB101010RangeMin are available for non-full-range pixel values.
     For full-range pixel values, the user can set these as
     
     RGB101010RangeMax  = 1023;
     RGB101010RangeMin  = 0;
     
     The per-pixel operation is:
     
     uint16_t *srcPixel = src.data;
     A16 = srcPixel[permuteMap[0]];
     R16 = srcPixel[permuteMap[1]];
     G16 = srcPixel[permuteMap[2]];
     B16 = srcPixel[permuteMap[3]];
     srcPixel += 4;
     
     int32_t R10, G10, B10;
     int32_t range10 = RGB101010RangeMax - RGB101010RangeMin;
     R10 = ((R16 * range10 + (USHRT_MAX >> 1)) / USHRT_MAX) + RGB101010RangeMin;
     G10 = ((G16 * range10 + (USHRT_MAX >> 1)) / USHRT_MAX) + RGB101010RangeMin;
     B10 = ((B16 * range10 + (USHRT_MAX >> 1)) / USHRT_MAX) + RGB101010RangeMin;
     A10 = ((A16 * 3 + (USHRT_MAX >> 1)) / USHRT_MAX);
 
     uint32_t *destPixel = dest.data;
     destPixel[0] = htonl((R10 << 22) | (G10 << 12) | (B10 << 2) | A10);
     destPixel += 1;
     
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
     kvImageInvalidParameter         Is returned when RGB101010RangeMin is bigger than RGB101010RangeMax.
 @/textblock </pre>
 
     Results are guaranteed to be faithfully rounded.
 
 
*/
@available(OSX 10.10, *)
func vImageConvert_ARGB16UToRGBA1010102(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ RGB101010RangeMin: Int32, _ RGB101010RangeMax: Int32, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImagePermuteChannels_RGB888
     
     @abstract Reorder 3 color channels within the buffer according to the permute map.
     
     @param src
     A pointer to vImage_Buffer that references 8-bit 3-channel interleaved source pixels.
     
     @param dest
     A pointer to vImage_Buffer that references 8-bit 3-channel interleaved destination pixels.
 
     @param permuteMap
     Values that can be used to switch the channel order of dest.
     For exmaple, permuteMap[3] = {0, 1, 2} or NULL will produce the same dest pixels as the src.
     permuteMap[3] = {2, 1, 0} is the reverse ordered dest pixels from the dest.
     Any order of permuteMap is allowed when each permuteMap value is 0, 1, or 2.
     
     @param flags
  <pre> @textblock
     kvImageDoNotTile            Disables internal multithreading, if any.
  @/textblock </pre>     
     @discussion This function can be used to reorder 3 color channel buffer.
 
     The per-pixel operation is:
     <pre> @textblock
 
     uint8_t *srcRow = src.data;
     uint8_t *destRow = dest.data;
 
     R = srcRow[permuteMap[0]];
     G = srcRow[permuteMap[1]];
     B = srcRow[permuteMap[2]];
     srcRow += 3;
 
     destRow[0] = R;
     destRow[1] = G;
     destRow[2] = B;
     destRow += 3;
    
     @/textblock </pre>
 
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageUnknownFlagsBit          Is returned when there is a unknown flag.
     kvImageRoiLargerThanInputBuffer Is returned when src.width < dest.width || src.height < dest.height
 @/textblock </pre>

   Works in place.
 
 
*/
@available(OSX 10.10, *)
func vImagePermuteChannels_RGB888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ permuteMap: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
     @function vImageCopyBuffer
 
     @abstract Copy vImage buffer from src to dest.
 
     @param src
     A pointer to source vImage_Buffer.
 
     @param dest
     A pointer to destination vImage_Buffer.
 
     @param pixelSize
     Number of bytes for one pixel.
 
     @param flags
  <pre> @textblock
     kvImageDoNotTile            Disables internal multithreading, if any.
     kvImageGetTempBufferSize    Returns 0. Does no work.
  @/textblock </pre>
 
@return
 <pre> @textblock
     kvImageNoError                  Is returned when there was no error.
     kvImageBufferSizeMismatch       Is returned when src.width < dest.width || src.height < dest.height
 @/textblock </pre>

 
*/
@available(OSX 10.10, *)
func vImageCopyBuffer(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ pixelSize: Int, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolve_Planar8
 *  @abstract General convolution on a Planar8 image.
 *  @discussion This filter applies a convolution filter of your choosing to a Planar8 image. 
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              int sum = 0;
 *              
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sum += kernel_element[i][j] * 
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2];
 *              }
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sum = (sum + divisor/2) / divisor;
 *
 *              // write out result
 *              result[y][x] = CLAMP(sum, 0, 255);
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const int16_t kernel[9] = { 1, 2, 1,
 *                                                      2, 4, 2,
 *                                                      1, 2, 1 };
 *                          @/textblock </pre>
 *
 *                          The kernel values may not sum in any combination to be outside the range
 *                          [-2**23, 2**23), or modulo overflow in the accumulator may result.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param divisor          The weighted sum of nearby pixels is typically a large number, which must be corrected
 *                          to fit back into the image format of the destination image. The correction factor 
 *                          is passed in as divisor here, and is divided from the sum before the result is 
 *                          returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
 *                          is 0, 1 will be used instead.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the 
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of 
 *                                      the temp buffer to use with this function and this set of 
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided: 
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal 
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageConvolve_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Int16>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ divisor: Int32, _ backgroundColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolve_PlanarF
 *  @abstract General convolution on a PlanarF image.
 *  @discussion This filter applies a convolution filter of your choosing to a PlanarF image.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              float sum = 0;
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sum += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2];
 *              }
 *
 *              // write out result
 *              result[y][x] = sum;
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const float kernel[9] =   { 1./16, 2./16, 1./16,
 *                                                      2./16, 4./16, 2./16,
 *                                                      1./16, 2./16, 1./16 };
 *                          @/textblock </pre>
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageConvolve_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ backgroundColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolve_ARGB8888
 *  @abstract General convolution on a ARGB888 image of any channel order.
 *  @discussion This filter applies a convolution filter of your choosing to a ARGB8888 image.
 *              This filter will work on any four-channel, 8-bit per component image format, not just ARGB.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              int sumA = 0;
 *              int sumR = 0;
 *              int sumG = 0;
 *              int sumB = 0;
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sumA += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][0];
 *                  sumR += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][1];
 *                  sumG += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][2];
 *                  sumB += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][3];
 *              }
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sumA = (sumA + divisor/2) / divisor;
 *              sumR = (sumR + divisor/2) / divisor;
 *              sumG = (sumG + divisor/2) / divisor;
 *              sumB = (sumB + divisor/2) / divisor;
 *
 *              // write out result
 *              result[y][x][0] = CLAMP(sumA, 0, 255);
 *              result[y][x][1] = CLAMP(sumR, 0, 255);
 *              result[y][x][2] = CLAMP(sumG, 0, 255);
 *              result[y][x][3] = CLAMP(sumB, 0, 255);
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const int16_t kernel[9] = { 1, 2, 1,
 *                                                      2, 4, 2,
 *                                                      1, 2, 1 };
 *                          @/textblock </pre>
 *
 *                          The kernel values may not sum in any combination to be outside the range
 *                          [-2**23, 2**23), or modulo overflow in the accumulator may result.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param divisor          The weighted sum of nearby pixels is typically a large number, which must be corrected
 *                          to fit back into the image format of the destination image. The correction factor
 *                          is passed in as divisor here, and is divided from the sum before the result is
 *                          returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
 *                          is 0, 1 will be used instead.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageConvolve_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Int16>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ divisor: Int32, _ backgroundColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolve_ARGBFFFF
 *  @abstract General convolution on a ARGBFFFF image of any channel order.
 *  @discussion This filter applies a convolution filter of your choosing to a ARGBFFFF image.
 *              This filter will work on any four-channel, float per component image format, not just ARGB.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              float sumA = 0;
 *              float sumR = 0;
 *              float sumG = 0;
 *              float sumB = 0;
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sumA += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][0];
 *                  sumR += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][1];
 *                  sumG += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][2];
 *                  sumB += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][3];
 *              }
 *
 *              // write out result
 *              result[y][x][0] = sumA;
 *              result[y][x][1] = sumR;
 *              result[y][x][2] = sumG;
 *              result[y][x][3] = sumB;
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const float kernel[9] =   { 1./16, 2./16, 1./16,
 *                                                      2./16, 4./16, 2./16,
 *                                                      1./16, 2./16, 1./16 };
 *                          @/textblock </pre>
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageConvolve_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ backgroundColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolveWithBias_Planar8
 *  @abstract General convolution on a Planar8 image with added bias.
 *  @discussion This filter applies a convolution filter of your choosing to a Planar8 image.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              int sum = 0;
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sum += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2];
 *              }
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sum = (sum + bias) / divisor;
 *
 *              // write out result
 *              result[y][x] = CLAMP(sum, 0, 255);
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const int16_t kernel[9] = { 1, 2, 1,
 *                                                      2, 4, 2,
 *                                                      1, 2, 1 };
 *                          @/textblock </pre>
 *
 *                          The kernel values may not sum in any combination to be outside the range
 *                          [-2**23, 2**23), or modulo overflow in the accumulator may result.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param divisor          The weighted sum of nearby pixels is typically a large number, which must be corrected
 *                          to fit back into the image format of the destination image. The correction factor
 *                          is passed in as divisor here, and is divided from the sum before the result is
 *                          returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
 *                          is 0, 1 will be used instead.
 *
 *  @param bias             This value is added to the sum of weighted pixels before the divisor is applied.
 *                          It can serve to both control rounding and adjust the brightness of the result.
 *                          A large bias (e.g 128 * divisor) may be required for some kernels to return
 *                          representable results, such as edge detection filters.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageConvolveWithBias_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Int16>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ divisor: Int32, _ bias: Int32, _ backgroundColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolveWithBias_PlanarF
 *  @abstract General convolution on a PlanarF image with added bias.
 *  @discussion This filter applies a convolution filter of your choosing to a PlanarF image.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              float sum = bias;
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sum += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2];
 *              }
 *
 *              // write out result
 *              result[y][x] = sum;
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const float kernel[9] =   { 1./16, 2./16, 1./16,
 *                                                      2./16, 4./16, 2./16,
 *                                                      1./16, 2./16, 1./16 };
 *                          @/textblock </pre>
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param bias             This value is added to the sum of weighted pixels.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageConvolveWithBias_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ bias: Float, _ backgroundColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolveWithBias_ARGB8888
 *  @abstract General convolution on a ARGB888 image of any channel order with bias.
 *  @discussion This filter applies a convolution filter of your choosing to a ARGB8888 image.
 *              This filter will work on any four-channel, 8-bit per component image format, not just ARGB.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              int sumA = 0;
 *              int sumR = 0;
 *              int sumG = 0;
 *              int sumB = 0;
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sumA += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][0];
 *                  sumR += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][1];
 *                  sumG += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][2];
 *                  sumB += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][3];
 *              }
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sumA = (sumA + bias[0]) / divisor;
 *              sumR = (sumR + bias[1]) / divisor;
 *              sumG = (sumG + bias[2]) / divisor;
 *              sumB = (sumB + bias[3]) / divisor;
 *
 *              // write out result
 *              result[y][x][0] = CLAMP(sumA, 0, 255);
 *              result[y][x][1] = CLAMP(sumR, 0, 255);
 *              result[y][x][2] = CLAMP(sumG, 0, 255);
 *              result[y][x][3] = CLAMP(sumB, 0, 255);
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const int16_t kernel[9] = { 1, 2, 1,
 *                                                      2, 4, 2,
 *                                                      1, 2, 1 };
 *                          @/textblock </pre>
 *
 *                          The kernel values may not sum in any combination to be outside the range
 *                          [-2**23, 2**23), or modulo overflow in the accumulator may result.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param divisor          The weighted sum of nearby pixels is typically a large number, which must be corrected
 *                          to fit back into the image format of the destination image. The correction factor
 *                          is passed in as divisor here, and is divided from the sum before the result is
 *                          returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
 *                          is 0, 1 will be used instead.
 *
 *  @param bias             This value is added to the sum of weighted pixels before the divisor is applied.
 *                          It can serve to both control rounding and adjust the brightness of the result.
 *                          A large bias (e.g 128 * divisor) may be required for some kernels, such as edge 
 *                          detection filters, to return representable results.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageConvolveWithBias_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Int16>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ divisor: Int32, _ bias: Int32, _ backgroundColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolveWithBias_ARGBFFFF
 *  @abstract General convolution on a ARGBFFFF image of any channel order with bias.
 *  @discussion This filter applies a convolution filter of your choosing to a ARGBFFFF image.
 *              This filter will work on any four-channel, float per component image format, not just ARGB.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              float sumA = bias[0];
 *              float sumR = bias[1];
 *              float sumG = bias[2];
 *              float sumB = bias[3];
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sumA += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][0];
 *                  sumR += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][1];
 *                  sumG += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][2];
 *                  sumB += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][3];
 *              }
 *
 *              // write out result
 *              result[y][x][0] = sumA;
 *              result[y][x][1] = sumR;
 *              result[y][x][2] = sumG;
 *              result[y][x][3] = sumB;
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const float kernel[9] =   { 1./16, 2./16, 1./16,
 *                                                      2./16, 4./16, 2./16,
 *                                                      1./16, 2./16, 1./16 };
 *                          @/textblock </pre>
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param bias             This value is added to the sum of weighted pixels.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageConvolveWithBias_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ bias: Float, _ backgroundColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolveMultiKernel_ARGB8888
 *  @abstract General convolution on a ARGB8888 image of any channel order with separate bias, kernel and divisor for each channel.
 *  @discussion This filter applies a convolution filter of your choosing to a ARGB8888 image.
 *              This filter will work on any four-channel, 8-bit per component image format, not just ARGB.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              int sumA = 0;
 *              int sumR = 0;
 *              int sumG = 0;
 *              int sumB = 0;
 *				const int16_t *kA = kernel[0];
 *				const int16_t *kR = kernel[1];
 *				const int16_t *kG = kernel[2];
 *				const int16_t *kB = kernel[3];
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sumA += kA[i*kernel_width+j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][0];
 *                  sumR += kR[i*kernel_width+j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][1];
 *                  sumG += kG[i*kernel_width+j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][2];
 *                  sumB += kB[i*kernel_width+j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][3];
 *              }
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sumA = (sumA + bias[0]) / divisor[0];
 *              sumR = (sumR + bias[1]) / divisor[1];
 *              sumG = (sumG + bias[2]) / divisor[2];
 *              sumB = (sumB + bias[3]) / divisor[3];
 *
 *              // write out result
 *              result[y][x][0] = CLAMP(sumA, 0, 255);
 *              result[y][x][1] = CLAMP(sumR, 0, 255);
 *              result[y][x][2] = CLAMP(sumG, 0, 255);
 *              result[y][x][3] = CLAMP(sumB, 0, 255);
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           An array of 4 pointers to weights of dimension kernel_height x kernel_width.
 *                          The kernel values in each array may not sum in any combination to be outside the range
 *                          [-2**23, 2**23), or modulo overflow in the accumulator may result.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param divisor          The weighted sum of nearby pixels is typically a large number, which must be corrected
 *                          to fit back into the image format of the destination image. The correction factor
 *                          is passed in as divisor here, and is divided from the sum before the result is
 *                          returned. Typically, the divisor is the sum over the area of the kernel. If the divisor
 *                          is 0, 1 will be used instead.
 *
 *  @param bias             This array of values is added to the sum of weighted pixels for each channel respectively
 *                          before the divisor is applied. It can serve to both control rounding and adjust the 
 *                          brightness of the result. A large bias (e.g 128 * divisor) may be required for some 
 *                          kernels, such as edge detection filters, to return representable results.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageConvolveMultiKernel_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernels: UnsafeMutablePointer<UnsafePointer<Int16>>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ divisors: UnsafePointer<Int32>, _ biases: UnsafePointer<Int32>, _ backgroundColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageConvolveMultiKernel_ARGBFFFF
 *  @abstract General convolution on a ARGBFFFF image of any channel order with separate bias and kernel for each channel.
 *  @discussion This filter applies a convolution filter of your choosing to a ARGBFFFF image.
 *              This filter will work on any four-channel, float per component image format, not just ARGB.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              float sumA = bias[0];
 *              float sumR = bias[1];
 *              float sumG = bias[2];
 *              float sumB = bias[3];
 *				const float *kA = kernel[0];
 *				const float *kR = kernel[1];
 *				const float *kG = kernel[2];
 *				const float *kB = kernel[3];
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sumA += kA[i*kernel_width+j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][0];
 *                  sumR += kR[i*kernel_width+j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][1];
 *                  sumG += kG[i*kernel_width+j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][2];
 *                  sumB += kB[i*kernel_width+j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2] [x+j+srcOffsetToROI_X- kernel_width/2][3];
 *              }
 *
 *              // write out result
 *              result[y][x][0] = sumA;
 *              result[y][x][1] = sumR;
 *              result[y][x][2] = sumG;
 *              result[y][x][3] = sumB;
 *          }
 *      @/textblock </pre>
 *              (Above, we imagine the kernel to be a 2D array of size kernel_height by kernel_width.
 *              However, in practice it is passed in as a contiguous 1D array of size kernel_height *
 *              kernel_width.)
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const float kernel[9] =   { 1./16, 2./16, 1./16,
 *                                                      2./16, 4./16, 2./16,
 *                                                      1./16, 2./16, 1./16 };
 *                          @/textblock </pre>
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param bias             This value is added to the sum of weighted pixels.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageConvolveMultiKernel_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernels: UnsafeMutablePointer<UnsafePointer<Float>>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ biases: UnsafePointer<Float>, _ backgroundColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageRichardsonLucyDeConvolve_Planar8
 * @abstract Perform N iterations of a Lucy-Richardson deconvolution on Planar8 data
 * @discussion
 *  This routine iteratively uses the following formula:
 *      <pre>@textblock
 *		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )
 *
 *		where:
 *              e[0] = the observed image (src parameter)
 *              e[n] = the result of the nth iteration
 *              psf  = point spread function (kernel for call to convolution)
 *				x    = multiply operator
 *              '*'  = convolution operator
 *      @/textblock </pre>
 *
 *  The work in these functions is currently done internally with floating point precision. If you plan to call this function multiple times
 *  (rather than with iterationCount > 1) on 8-bit per channel images, you can save some computation by converting the 8-bit image data to
 *  single precision floating-point yourself using something like vImageConvert_Planar8toPlanarF and iterating on the appropriate
 *  floating-point Richardson Lucy variant. Convert back, when you are done.
 *
 *  Does not work in place.
 * @param src           The input image
 *
 * @param dest          A preallocated buffer to receive the result image. 
 *                      This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const int16_t kernel[9] = { 1, 2, 1,
 *                                                      2, 4, 2,
 *                                                      1, 2, 1 };
 *                          @/textblock </pre>
 *
 *                          This is psf0 in the formula given in the discussion.
 *
 *  @param kernel2          A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
 *                          This is psf1 in the formula given in the discussion.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel1. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel1. It must be an odd number.
 *
 *  @param kernel_height2   The height of the 2D table of weights passed in as kernel2. It must be an odd number.
 *
 *  @param kernel_width2    The width of the 2D table of weights passed in as kernel2. It must be an odd number.
 *
 *  @param divisor          The divisor to use to correct for the volume under kernel.
 *
 *  @param divisor2         The divisor to use to correct for the volume under kernel2.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *  
 *  @param iterationCount   The number of Richardson-Lucy iterations to perform on the data before returning. 
 *                          If 0, the src buffer is coped to dest.
 *
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageRichardsonLucyDeConvolve_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Int16>, _ kernel2: UnsafePointer<Int16>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ kernel_height2: UInt32, _ kernel_width2: UInt32, _ divisor: Int32, _ divisor2: Int32, _ backgroundColor: Pixel_8, _ iterationCount: UInt32, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageRichardsonLucyDeConvolve_PlanarF
 * @abstract Perform N iterations of a Lucy-Richardson deconvolution on PlanarF data
 * @discussion
 *  This routine iteratively uses the following formula:
 *      <pre>@textblock
 *		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )
 *
 *		where:
 *              e[0] = the observed image (src parameter)
 *              e[n] = the result of the nth iteration
 *              psf  = point spread function (kernel for call to convolution)
 *				x    = multiply operator
 *              '*'  = convolution operator
 *      @/textblock </pre>
 *
 *  Does not work in place.
 * @param src           The input image
 *
 * @param dest          A preallocated buffer to receive the result image.
 *                      This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const float kernel[9] =   { 1./16, 2./16, 1./16,
 *                                                      2./16, 4./16, 2./16,
 *                                                      1./16, 2./16, 1./16 };
 *                          @/textblock </pre>
 *
 *                          This is psf0 in the formula given in the discussion.
 *
 *  @param kernel2          A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
 *                          This is psf1 in the formula given in the discussion.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel1. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel1. It must be an odd number.
 *
 *  @param kernel_height2   The height of the 2D table of weights passed in as kernel2. It must be an odd number.
 *
 *  @param kernel_width2    The width of the 2D table of weights passed in as kernel2. It must be an odd number.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param iterationCount   The number of Richardson-Lucy iterations to perform on the data before returning.
 *                          If 0, the src buffer is coped to dest.
 *
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageRichardsonLucyDeConvolve_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel2: UnsafePointer<Float>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ kernel_height2: UInt32, _ kernel_width2: UInt32, _ backgroundColor: Pixel_F, _ iterationCount: UInt32, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageRichardsonLucyDeConvolve_ARGB8888
 * @abstract Perform N iterations of a Lucy-Richardson deconvolution on ARGB8888 data.
 * @discussion
 *  This routine iteratively uses the following formula:
 *      <pre>@textblock
 *		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )
 *
 *		where:
 *              e[0] = the observed image (src parameter)
 *              e[n] = the result of the nth iteration
 *              psf  = point spread function (kernel for call to convolution)
 *				x    = multiply operator
 *              '*'  = convolution operator
 *      @/textblock </pre>
 *  The channels are operated on independently of one another. Consequently, this function will work on
 *  any 4-channel interleaved 8-bit per component format (e.g. RGBA, BGRA...), not just ARGB. 
 *
 *  The work in these functions is currently done internally with floating point precision. If you plan to call this function multiple times
 *  (rather than with iterationCount > 1) on 8-bit per channel images, you can save some computation by converting the 8-bit image data to
 *  single precision floating-point yourself using something like vImageConvert_Planar8toPlanarF and iterating on the appropriate
 *  floating-point Richardson Lucy variant. Convert back, when you are done.
 *
 *  Does not work in place.
 *
 * @param src           The input image
 *
 * @param dest          A preallocated buffer to receive the result image.
 *                      This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const int16_t kernel[9] = { 1, 2, 1,
 *                                                      2, 4, 2,
 *                                                      1, 2, 1 };
 *                          @/textblock </pre>
 *
 *                          This is psf0 in the formula given in the discussion.
 *
 *  @param kernel2          A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
 *                          This is psf1 in the formula given in the discussion.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel1. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel1. It must be an odd number.
 *
 *  @param kernel_height2   The height of the 2D table of weights passed in as kernel2. It must be an odd number.
 *
 *  @param kernel_width2    The width of the 2D table of weights passed in as kernel2. It must be an odd number.
 *
 *  @param divisor          The divisor to use to correct for the volume under kernel.
 *
 *  @param divisor2         The divisor to use to correct for the volume under kernel2.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param iterationCount   The number of Richardson-Lucy iterations to perform on the data before returning.
 *                          If 0, the src buffer is coped to dest.
 *
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *              kvImageLeaveAlphaUnchanged  Operate only on the last 3 channels in memory. Leave the first channel
 *                                          unmodified.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageRichardsonLucyDeConvolve_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Int16>, _ kernel2: UnsafePointer<Int16>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ kernel_height2: UInt32, _ kernel_width2: UInt32, _ divisor: Int32, _ divisor2: Int32, _ backgroundColor: UnsafePointer<UInt8>, _ iterationCount: UInt32, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageRichardsonLucyDeConvolve_ARGBFFFF
 * @abstract Perform N iterations of a Lucy-Richardson deconvolution on ARGBFFFF data
 * @discussion
 *  This routine iteratively uses the following formula:
 *      <pre>@textblock
 *		e[i+1] = e[i] x (psf0 * ( e[0] / (psf1 * e[i]) ) )
 *
 *		where:
 *              e[0] = the observed image (src parameter)
 *              e[n] = the result of the nth iteration
 *              psf  = point spread function (kernel for call to convolution)
 *				x    = multiply operator
 *              '*'  = convolution operator
 *      @/textblock </pre>
 *
 *  The channels are operated on independently of one another. Consequently, this function will work on
 *  any 4-channel interleaved 8-bit per component format (e.g. RGBA, BGRA...), not just ARGB.
 *
 *  Does not work in place.
 * @param src           The input image
 *
 * @param dest          A preallocated buffer to receive the result image.
 *                      This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel           A pointer to a 1D array of weights of dimension kernel_height x kernel_width.
 *                          For example, for a simple 3x3 blur, it might be:
 *                          <pre>@textblock
 *                          const float kernel[9] =   { 1./16, 2./16, 1./16,
 *                                                      2./16, 4./16, 2./16,
 *                                                      1./16, 2./16, 1./16 };
 *                          @/textblock </pre>
 *
 *                          This is psf0 in the formula given in the discussion.
 *
 *  @param kernel2          A pointer to a second 1D array of weights of dimension kernel_height2 x kernel_width2.
 *                          This is psf1 in the formula given in the discussion.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel1. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel1. It must be an odd number.
 *
 *  @param kernel_height2   The height of the 2D table of weights passed in as kernel2. It must be an odd number.
 *
 *  @param kernel_width2    The width of the 2D table of weights passed in as kernel2. It must be an odd number.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param iterationCount   The number of Richardson-Lucy iterations to perform on the data before returning.
 *                          If 0, the src buffer is coped to dest.
 *
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *              kvImageLeaveAlphaUnchanged  Operate only on the last 3 channels in memory. Leave the first channel
 *                                          unmodified.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageNullPointerArgument  kernel may not be NULL
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageRichardsonLucyDeConvolve_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel2: UnsafePointer<Float>, _ kernel_height: UInt32, _ kernel_width: UInt32, _ kernel_height2: UInt32, _ kernel_width2: UInt32, _ backgroundColor: UnsafePointer<Float>, _ iterationCount: UInt32, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageBoxConvolve_Planar8
 *  @abstract Special purpose box convolution on a Planar8 image.
 *  @discussion This filter applies a box filter to a Planar8 image.  A box filter uses a much faster algorithm
 *              than a standard convolution, and may be a good solution for real time application of large blur
 *              radii against images.
 *              For each pixel:
 *      <pre>@textblock
 *          vImagePixelCount kernel_area = kernel_height * kernel_width;
 *          for each pixel[y][x] in image{
 *              int sum = 0;
 *
 *              // Calculate unweighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sum += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                              [x+j+srcOffsetToROI_X- kernel_width/2];
 *              }
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sum = (sum + kernel_area/2) / kernel_area;
 *
 *              // write out result
 *              result[y][x] = CLAMP(sum, 0, 255);
 *          }
 *      @/textblock </pre>
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageBoxConvolve_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: UInt32, _ kernel_width: UInt32, _ backgroundColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageBoxConvolve_ARGB8888
 *  @abstract Special purpose box convolution on a 4-channel interleaved, 8-bit per channel image.
 *  @discussion This filter applies a box filter to a 4-channel interleaved, 8-bit per channel imagee.
 *              A box filter uses a much faster algorithm than a standard convolution, and may be a good
 *              solution for real time application of large blur radii against images.
 *              For each pixel:
 *      <pre>@textblock
 *          vImagePixelCount kernel_area = kernel_height * kernel_width;
 *          for each pixel[y][x] in image{
 *              int sumA = 0;
 *              int sumR = 0;
 *              int sumG = 0;
 *              int sumB = 0;
 *
 *              // Calculate unweighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sumA += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2][0];
 *                  sumR += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2][1];
 *                  sumG += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2][2];
 *                  sumB += pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2][3];
 *              }
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sumA = (sumA + kernel_area/2) / kernel_area;
 *              sumR = (sumR + kernel_area/2) / kernel_area;
 *              sumG = (sumG + kernel_area/2) / kernel_area;
 *              sumB = (sumB + kernel_area/2) / kernel_area;
 *
 *              // write out result
 *              result[y][x][0] = CLAMP(sumA, 0, 255);
 *              result[y][x][1] = CLAMP(sumR, 0, 255);
 *              result[y][x][2] = CLAMP(sumG, 0, 255);
 *              result[y][x][3] = CLAMP(sumB, 0, 255);
 *          }
 *      @/textblock </pre>
 *
 *              This filter does not work in place.
 *
 *              This filter will work without modification for other byte orders such as RGBA, BGRA, AGBR, CMYK, etc. 
 *              The image should be non-premultiplied to avoid odd results in non-opaque regions.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageLeaveAlphaUnchanged  Apply the convolution to the last three channels in memory, only.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageBoxConvolve_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: UInt32, _ kernel_width: UInt32, _ backgroundColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageTentConvolve_Planar8
 *  @abstract Special purpose tent convolution on a Planar8 image.
 *  @discussion This filter applies a tent filter to a Planar8 image.  A tent filter uses a much faster algorithm
 *              than a standard convolution, and may be a good solution for real time application of large blur
 *              radii against images.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              int sum = 0;
 *              int divisor = 0;
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sum += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2]
 *                               [x+j+srcOffsetToROI_X- kernel_width/2];
 *                  divisor += kernel_element[i][j];
 *              }
 *
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sum = (sum + divisor/2) / divisor;
 *
 *              // write out result
 *              result[y][x] = CLAMP(sum, 0, 255);
 *          }
 *      @/textblock </pre>
 *
 *              This filter does not work in place.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageTentConvolve_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: UInt32, _ kernel_width: UInt32, _ backgroundColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageTentConvolve_ARGB8888
 *  @abstract Special purpose tent convolution on a 4-channel interleaved, 8-bit per channel image.
 *  @discussion This filter applies a tent filter to a 4-channel interleaved, 8-bit per channel imagee.
 *              A tent filter uses a much faster algorithm than a standard convolution, and may be a good
 *              solution for real time application of large blur radii against images.
 *              For each pixel:
 *      <pre>@textblock
 *          for each pixel[y][x] in image{
 *              int sumA = 0;
 *              int sumR = 0;
 *              int sumG = 0;
 *              int sumB = 0;
 *              int divisor = 0;
 *
 *              // Calculate weighted average over kernel area
 *              for each kernel_element[i][j] in kernel{
 *                  sumA += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][0];
 *                  sumR += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][1];
 *                  sumG += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][2];
 *                  sumB += kernel_element[i][j] *
 *                          pixel[y+i+srcOffsetToROI_Y-kernel_height/2][x+j+srcOffsetToROI_X- kernel_width/2][3];
 *                  divisor += kernel_element[i][j];
 *              }
 *              // Correct for the scaling introduced by multiplying by the weights table
 *              sumA = (sumA + divisor/2) / divisor;
 *              sumR = (sumR + divisor/2) / divisor;
 *              sumG = (sumG + divisor/2) / divisor;
 *              sumB = (sumB + divisor/2) / divisor;
 *
 *              // write out result
 *              result[y][x][0] = CLAMP(sumA, 0, 255);
 *              result[y][x][1] = CLAMP(sumR, 0, 255);
 *              result[y][x][2] = CLAMP(sumG, 0, 255);
 *              result[y][x][3] = CLAMP(sumB, 0, 255);
 *          }
 *      @/textblock </pre>
 *
 *              This filter does not work in place.
 *
 *              This filter will work without modification for other byte orders such as RGBA, BGRA, AGBR, CMYK, etc.
 *              The image should be non-premultiplied to avoid odd results in non-opaque regions.
 *
 *  @param src              The input image
 *
 *  @param dest             A pointer to a preallocated vImage_Buffer to receive the result image.
 *                          This may not alias the src image.
 *
 *  @param tempBuffer       An optional pointer to a region of memory to use as a working area during
 *                          computation.  The size of the tempBuffer is given by calling the function
 *                          with the same parameters and the kvImageGetTempBufferSize flag, in which case
 *                          the size is returned instead of an error code from the left hand side.
 *                          You may pass NULL here, in which case a region of memory of similar size
 *                          will be allocated by the function and freed before it returns.  Temp Buffers
 *                          are a way of avoiding lost time due to VM faults to initialize newly allocated
 *                          buffers. If you will be calling this function repeatedly with similar parameters
 *                          you should use a temp buffer. If the function is called from different threads
 *                          concurrently, a different temp buffer should be used for each.
 *
 *  @param srcOffsetToROI_X An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the left edge of the image.
 *
 *  @param srcOffsetToROI_Y An offset used in tiling to shift the position of the destination image
 *                          relative to the src image. Typically this is 0. Non-Zero values are needed
 *                          when the destination tile is not aligned with the top edge of the image.
 *
 *  @param kernel_height    The height of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param kernel_width     The width of the 2D table of weights passed in as kernel. It must be an odd number.
 *
 *  @param backgroundColor  When the kvImageBackgroundColorFill edging mode is active, the backgroundColor
 *                          parameter provides the background color to be used for missing pixels when the
 *                          kernel extends off the edge of the image.
 *
 *  @param flags            The following flags are allowed:
 *      <pre>@textblock
 *              kvImageCopyInPlace          If any pixels covered by the kernel do no not exist, simply
 *                                          copy the corresponding source pixel to the destination. This
 *                                          will result in a ring on unconvolved content at the edges
 *                                          and convolved content in the middle.
 *
 *              kvImageBackgroundColorFill  Substitute in the provided background color for missing pixels.
 *                                          For a blur filter this will look like the edges of the image
 *                                          have been blurred into a particular color. This is usually
 *                                          appropriate when the color of the surface onto which the image
 *                                          will be drawn is known.  You can also use {Alpha = 0, color = 0}
 *                                          as a background color, and let the downstream image compositor
 *                                          blend in the background color. In this case, the result image
 *                                          should be treated as a premultiplied image.
 *
 *              kvImageEdgeExtend           Substitute in the nearest defined pixel for missing pixels.
 *                                          This is better when the image is drawn into a frame or other
 *                                          context where the background is not expected to contribute to
 *                                          the final content.
 *
 *              kvImageTruncateKernel       This is similar to kvImageEdgeExtend, except that edge pixels are
 *                                          simply ignored, and the bias and divisor are adjusted accordingly.
 *                                          Because of the complication at the edges, this edging mode can
 *                                          be significantly slower than the others. It can be numerically
 *                                          unstable if the sum over any rectangular subsection of the kernel
 *                                          is zero, which can result in division by zero during the computation.
 *                                          The results for this edging mode are usually quite visually similar
 *                                          to kvImageEdgeExtend.
 *
 *              kvImageGetTempBufferSize    Instead of calculating the convolution of the image, return the
 *                                          size of the temp buffer needed for this set of parameters. Does
 *                                          not touch the src or dest image.
 *
 *              kvImageLeaveAlphaUnchanged  Apply the convolution to the last three channels in memory, only.
 *
 *              kvImageDoNotTile            Disable internal multithreading.
 *
 *      @/textblock </pre>
 *                          The first four flags listed are edging modes. One and only one edging mode must be
 *                          provided. If no edging mode is provided (e.g. kvImageNoFlags), then an error will
 *                          be returned.
 *
 *  @return One of the following error codes may be returned:
 *      <pre>@textblock
 *          kvImageNoError              Success.
 *              >= 0                    If kvImageGetTempBufferSize is passed, this is the size of
 *                                      the temp buffer to use with this function and this set of
 *                                      parameters.
 *
 *          kvImageInvalidEdgeStyle     One and only one of the following flags must be provided:
 *                                         { kvImageCopyInPlace, kvImageBackgroundColorFill,
 *                                           kvImageEdgeExtend,  kvImageTruncateKernel }
 *
 *          kvImageRoiLargerThanInputBuffer The dest->width and height must be less than or equal
 *                                          to corresponding dimensions of the source buffer.
 *
 *          kvImageInvalidOffset_X      The destination width + srcOffsetToROI_X > src->width
 *
 *          kvImageInvalidOffset_Y      The destination height + srcOffsetToROI_Y > src->height
 *
 *          kvImageMemoryAllocationError Could not allocate memory to serve as a temp buffer.
 *
 *          kvImageInvalidKernelSize    The kernel height and width must be odd numbers.
 *      @/textblock </pre>
 */
@available(OSX 10.4, *)
func vImageTentConvolve_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: UInt32, _ kernel_width: UInt32, _ backgroundColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
var kRotate0DegreesClockwise: Int { get }
var kRotate90DegreesClockwise: Int { get }
var kRotate180DegreesClockwise: Int { get }
var kRotate270DegreesClockwise: Int { get }
var kRotate0DegreesCounterClockwise: Int { get }
var kRotate90DegreesCounterClockwise: Int { get }
var kRotate180DegreesCounterClockwise: Int { get }
var kRotate270DegreesCounterClockwise: Int { get }
@available(OSX 10.3, *)
func vImageRotate_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ angleInRadians: Float, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageRotate_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ angleInRadians: Float, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageRotate_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ angleInRadians: Float, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageRotate_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ angleInRadians: Float, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageRotate_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ angleInRadians: Float, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageRotate_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ angleInRadians: Float, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageScale_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageScale_Planar16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageScale_Planar16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageScale_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageScale_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageScale_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageScale_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageScale_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageAffineWarp_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform>, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageAffineWarp_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform>, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageAffineWarp_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform>, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageAffineWarp_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform>, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageAffineWarp_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform>, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageAffineWarp_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform>, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageAffineWarpD_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform_Double>, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageAffineWarpD_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform_Double>, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageAffineWarpD_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform_Double>, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageAffineWarpD_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform_Double>, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageAffineWarpD_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform_Double>, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageAffineWarpD_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_AffineTransform_Double>, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageAffineWarpCG_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_CGAffineTransform>, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageAffineWarpCG_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_CGAffineTransform>, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageAffineWarpCG_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_CGAffineTransform>, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageAffineWarpCG_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_CGAffineTransform>, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageAffineWarpCG_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_CGAffineTransform>, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageAffineWarpCG_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ transform: UnsafePointer<vImage_CGAffineTransform>, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageHorizontalReflect_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageHorizontalReflect_Planar16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageHorizontalReflect_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageHorizontalReflect_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageHorizontalReflect_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageHorizontalReflect_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageHorizontalReflect_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageVerticalReflect_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageVerticalReflect_Planar16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageVerticalReflect_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageVerticalReflect_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageVerticalReflect_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageVerticalReflect_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageVerticalReflect_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageRotate90_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ rotationConstant: UInt8, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageRotate90_Planar16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ rotationConstant: UInt8, _ backColor: Pixel_16U, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageRotate90_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ rotationConstant: UInt8, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageRotate90_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ rotationConstant: UInt8, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageRotate90_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ rotationConstant: UInt8, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageRotate90_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ rotationConstant: UInt8, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageRotate90_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ rotationConstant: UInt8, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageHorizontalShear_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageHorizontalShear_Planar16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: Pixel_16S, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageHorizontalShear_Planar16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: Pixel_16U, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageHorizontalShear_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageHorizontalShear_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageHorizontalShear_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageHorizontalShear_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageHorizontalShear_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageVerticalShear_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageVerticalShear_Planar16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: Pixel_16S, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.10, *)
func vImageVerticalShear_Planar16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: Pixel_16U, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageVerticalShear_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageVerticalShear_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageVerticalShear_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageVerticalShear_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageVerticalShear_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Float, _ shearSlope: Float, _ filter: ResamplingFilter, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageHorizontalShearD_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageHorizontalShearD_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageHorizontalShearD_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageHorizontalShearD_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageHorizontalShearD_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageHorizontalShearD_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ xTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageVerticalShearD_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageVerticalShearD_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: Pixel_F, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageVerticalShearD_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: UnsafePointer<UInt8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageVerticalShearD_ARGB16U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: UnsafePointer<UInt16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageVerticalShearD_ARGB16S(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: UnsafePointer<Int16>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.8, *)
func vImageVerticalShearD_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ yTranslate: Double, _ shearSlope: Double, _ filter: ResamplingFilter, _ backColor: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageNewResamplingFilter(scale: Float, _ flags: vImage_Flags) -> ResamplingFilter
@available(OSX 10.3, *)
func vImageDestroyResamplingFilter(filter: ResamplingFilter)
@available(OSX 10.3, *)
func vImageNewResamplingFilterForFunctionUsingBuffer(filter: ResamplingFilter, _ scale: Float, _ kernelFunc: (@convention(c) (UnsafePointer<Float>, UnsafeMutablePointer<Float>, UInt, UnsafeMutablePointer<Void>) -> Void)!, _ kernelWidth: Float, _ userData: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.3, *)
func vImageGetResamplingFilterSize(scale: Float, _ kernelFunc: (@convention(c) (UnsafePointer<Float>, UnsafeMutablePointer<Float>, UInt, UnsafeMutablePointer<Void>) -> Void)!, _ kernelWidth: Float, _ flags: vImage_Flags) -> Int
@available(OSX 10.9, *)
func vImageGetResamplingFilterExtent(filter: ResamplingFilter, _ flags: vImage_Flags) -> vImagePixelCount

/*!
 * @function vImageHistogramCalculation_Planar8
 *
 * @abstract Calculates a histogram for a Planar8 image.
 *
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each pixel, do the following:
 *          histogram[src[x]]++;
 * @/textblock</pre>
 *
 * This routine will not work in place
 *
 * @param   src            A pointer to a vImage_Buffer that references the source pixels
 *
 * @param   histogram      A pointer to a histogram. On return, this array will
 *                   contain the histogram for the source image.
 *                   The histogram will be an array with 256 elements.
 *
 * @param   flags          The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 * @/textblock</pre>
 *
 * @return The following error codes may be returned
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageNullPointerArgument      src or histogram pointer is NULL.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageHistogramCalculation_Planar8(src: UnsafePointer<vImage_Buffer>, _ histogram: UnsafeMutablePointer<vImagePixelCount>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageHistogramCalculation_PlanarF
 *
 * @abstract Calculates a histogram for a PlanarF image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each pixel, do the following:
 *          val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *          i = clip val between 0 and histogram_entries-1
 *          histogram[i]++;
 * @/textblock</pre>
 *
 * This routine will not work in place
 *
 * @param   src         A pointer to a vImage_Buffer that references the source pixels
 *
 * @param   histogram   A pointer to a histogram. On return, this array will
 *                      contain the histogram for the source image.
 *                      The histogram will have histogram_entries elements.
 *
 * @param   histogram_entries The number of histogram entries, or bins.
 *                      The histogram will be an array with histogram_entries elements.
 *
 * @param   minVal      A minimum pixel value. Any pixel value less than this will be
 *                      clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the first histogram entry. src is not modified.
 *
 * @param   maxVal      A maximum pixel value. Any pixel value greater than this will
 *                      be clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the last histogram entry.  src is not modified.
 *
 * @param   flags       The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 * @/textblock</pre>
 *
 * @return  The following error codes may occur:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or histogram pointer is NULL.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageHistogramCalculation_PlanarF(src: UnsafePointer<vImage_Buffer>, _ histogram: UnsafeMutablePointer<vImagePixelCount>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageHistogramCalculation_ARGB8888
 *
 * @abstract Calculates histograms for each channel of an ARGB8888 image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *
 *      For each pixel and channel, do the following:
 *          val = src[x];
 *          histogram[ch][val[ch]]++;
 *
 * @/textblock</pre>
 *
 * This routine will not work in place
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the histogram will match the channel order of the image.
 *
 * @param   src         A pointer to a vImage_Buffer that references the source pixels
 *
 * @param   histogram   A pointer to a histograms, one each for alpha, red, green, and blue (in that order).
 *                      On return, this array will contain the four histograms for the corresponding channels.
 *                      Each of the four histograms will be an array with 256 elements.
 *                      This function does not allocate storage for the histograms. You must allocate
 *                      storage for each of the four histograms, create an array and populate it with
 *                      pointers to the histograms before calling the function.
 *
 * @param   flags       The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Do not calculate the histogram for the alpha channel
 * @/textblock</pre>
 *
 * @return  The following error codes may occur
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageNullPointerArgument      src or histogram pointer is NULL.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageHistogramCalculation_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ histogram: UnsafeMutablePointer<UnsafeMutablePointer<vImagePixelCount>>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageHistogramCalculation_ARGBFFFF
 *
 * @abstract Calculates histograms for each channel of an ARGBFFFF image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each pixel, do the following:
 *          val = src[x];
 *          For each channel do:
 *              i = histogram_entries * (val[ch] - minVal) / (maxVal - minVal);
 *              i = clip i between 0 and histogram_entries-1
 *              histogram[ch][i]++;
 * @/textblock</pre>
 *
 * This routine will not work in place
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the histogram will match the channel order of the image.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param histogram     A pointer to an array of four histograms,
 *                      one each for alpha, red, green, and blue (in that order).
 *                      On return, this array will contain the four histograms for the corresponding channels.
 *                      Each of the four histograms will be an array with histogram_entries elements.
 *                      This function does not allocate storage for the histograms. You must allocate
 *                      storage for each of the four histograms, create an array and populate it with
 *                      pointers to the histograms before calling the function.
 *
 * @param histogram_entries The number of histogram entries, or bins. Each of the four
 *                      calculated histograms will be an array with histogram_entries elements.
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *                      This minimum value is applied to each of the four channels separately.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry.
 *                      This maximum value is applied to each of the four channels separately.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Do not calculate the histogram for the alpha channel
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or any of the histogram pointers is NULL.
 * @/textblock</pre>
 *
 */
@available(OSX 10.3, *)
func vImageHistogramCalculation_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ histogram: UnsafeMutablePointer<UnsafeMutablePointer<vImagePixelCount>>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageEqualization_Planar8
 *
 * @abstract Equalizes the histogram of a Planar8 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image;
 *      Calculate normalized sum of histogram;
 *      For each pixel, do the following:
 *          dest[x] = equalized_histogram[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src       A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest      A pointer to a vImage buffer that references the destination pixels
 *
 * @param flags     The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageEqualization_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageEqualization_PlanarF
 *
 * @abstract Equalizes the histogram of a PlanarF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image:
 *          For each pixel, do the following:
 *              val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *              i = clip val between 0 and histogram_entries-1
 *              histogram[i]++;
 *      Calculate normalized sum of histogram;
 *      For each pixel, do the following:
 *          val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *          i = clip val between 0 and histogram_entries-1
 *          dest[x] = equalized_histogram[i];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param histogram_entries The number of histogram entries, or bins.
 *                      The histogram will be an array with histogram_entries elements.
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be
 *                      clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the first histogram entry.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will
 *                      be clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the last histogram entry.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day.
 * @/textblock</pre>
 *
 * @return The following values may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or histogram pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageEqualization_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageEqualization_ARGB8888
 *
 * @abstract Equalizes the histogram of an ARGB8888 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Calculates histograms for each channel of the ARGB8888 source image;
 *      Calculate normalized sum of each histogram;
 *      For each pixel do the following:
 *          val = src[x];
 *          For each channel:
 *              val[ch] = equalized_histogram[ch][val[ch]];
 *              dest[x] = val;
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *
 * @param src       A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest      A pointer to a vImage buffer that references the destination pixels
 *
 * @param flags     The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageEqualization_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageEqualization_ARGBFFFF
 *
 * @abstract Equalizes the histogram of an ARGBFFFF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image:
 *          For each pixel, do the following:
 *              val = src[x];
 *              For each channel do:
 *                  i = histogram_entries * (val[ch] - minVal) / (maxVal - minVal);
 *                  i = clip i between 0 and histogram_entries-1
 *                  histogram[ch][i]++;
 *
 *      Calculate normalized sum of each histogram;
 *
 *      For each pixel, do the following:
 *          val = src[x];
 *          For each channel do:
 *              i = histogram_entries * (val[ch] - minVal) / (maxVal - minVal);
 *              i = clip i between 0 and histogram_entries-1
 *              val[ch] = equalized_histogram[ch][i];
 *          dest[x] = val;
 * @/textblock</pre>
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *                      This minimum value is applied to each of the four channels separately.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry.
 *                      This maximum value is applied to each of the four channels separately.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 *
 *          kvImageLeaveAlphaUnchanged    Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF. 
 */
@available(OSX 10.3, *)
func vImageEqualization_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageHistogramSpecification_Planar8
 *
 * @abstract Performs a histogram specification operation on a Planar8 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image;
 *      Calculate normalized sum of the input histogram and the desired_histogram
 *      Generate the inverse transform
 *      Transform final image using inv_hist as a LUT. For each pixel, do the following:
 *          dest[x] = inv_histogram[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src               A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest              A pointer to a vImage buffer that references the destination pixels
 *
 * @param desired_histogram A pointer to the desired histogram for the transformed image.
 *                          The histogram should be an array with 256 elements.
 *
 * @param flags             The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 * @/textblock</pre>
 *
 * @return  The following error codes may occur:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src, dest or desired_histogram pointer is NULL.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageHistogramSpecification_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ desired_histogram: UnsafePointer<vImagePixelCount>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageHistogramSpecification_PlanarF
 *
 * @abstract Performs a histogram specification operation on a PlanarF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image:
 *          For each pixel, do the following:
 *              val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *              i = clip val between 0 and histogram_entries-1
 *              histogram[i]++;
 *      Calculate normalized sum of the input histogram and the desired_histogram
 *      Generate the inverse transform
 *      Transform final image using inverse transform as a LUT. For each pixel, do the following:
 *          val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *          i = clip val between 0 and histogram_entries-1
 *          dest[x] = inv_histogram[i];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param desired_histogram A pointer the desired histogram for the transformed image.
 *                      The histogram should be an array with histogram_entries elements.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be
 *                      clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the first histogram entry.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will
 *                      be clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the last histogram entry.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src, dest or desired_histogram pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageHistogramSpecification_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ desired_histogram: UnsafePointer<vImagePixelCount>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageHistogramSpecification_ARGB8888
 *
 * @abstract Performs a histogram specification operation on an ARGB8888 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel:
 *          Compute the histogram of the input image;
 *          Calculate normalized sum of the input histogram and the desired_histogram
 *          Generate the inverse transform
 *          Transform final image using inv_hist as a LUT. For each pixel, do the following:
 *              dest[x] = inv_histogram[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the desired_histogram must match the channel order of the image.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param desired_histogram A pointer to an array of four histograms, one each for
 *                      alpha, red, green, and blue (in that order).
 *                      These are the desired histograms for the transformed image.
 *                      Each histogram should be an array with 256 elements.
 *                      This function does not allocate storage for the histograms. You must allocate
 *                      storage for each of the four histograms, create an array and populate it with
 *                      pointers to the histograms before calling the function. The contents of the 
 *                      histograms are generally obtained from vImageHistogramCalculation_<fmt> from
 *                      another image, but need not be so.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following values may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src, dest or any of the desired_histogram pointers is NULL.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageHistogramSpecification_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ desired_histogram: UnsafeMutablePointer<UnsafePointer<vImagePixelCount>>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageHistogramSpecification_ARGBFFFF
 *
 * @abstract Performs a histogram specification operation on an ARGBFFFF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel do:
 *          Compute the histogram of the input image:
 *              For each pixel, do the following:
 *                  val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *                  i = clip val between 0 and histogram_entries-1
 *                  histogram[ch][i]++;
 *          Calculate normalized sum of the input histogram and the desired_histogram
 *          Generate the inverse transform
 *          Transform final image using inverse transform as a LUT. For each pixel, do the following:
 *              val = histogram_entries * (src[ch][x] - minVal) / (maxVal - minVal);
 *              i = clip val between 0 and histogram_entries-1
 *              dest[ch][x] = inv_histogram[ch][i];
 * @/textblock </pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the desired_histogram must match the channel order of the image.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param desired_histogram A pointer to an array of four histograms, one each for
 *                      alpha, red, green, and blue (in that order).                
 *                      These are the desired histograms for the transformed image.
 *                      Each histogram should be an array with histogram_entries elements..
 *                      This function does not allocate storage for the histograms. You must allocate
 *                      storage for each of the four histograms, create an array and populate it with
 *                      pointers to the histograms before calling the function. The contents of the
 *                      histograms are generally obtained from vImageHistogramCalculation_<fmt> from
 *                      another image, but need not be so.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *                      This minimum value is applied to each of the four channels separately.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry. 
 *                      This maximum value is applied to each of the four channels separately.
 *
 * @param flags The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return  The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src, dest or any of desired_histogram pointers is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageHistogramSpecification_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ desired_histogram: UnsafeMutablePointer<UnsafePointer<vImagePixelCount>>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageContrastStretch_Planar8
 *
 * @abstract Stretches the contrast of a Planar8 source image.
 * @discussion This function performs the following operation:
 *   <pre>@textblock
 *      Compute the histogram of the input image;
 *      Generate LookUp table based on the histogram
 *      Transform final image using the LUT. For each pixel, do the following:
 *          dest[x] = LUT[src[x]];
 *   @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * vImageEndsInContrastStretch_Planar8 or vImageTableLookUp_Planar8 may be used instead when more control
 * over the stretch is desired.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param flags         The following flags are allowed:
 *   <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 *   @/textblock</pre>
 *
 * @return The following error codes may be returned:
 *   <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageContrastStretch_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageContrastStretch_PlanarF
 *
 * @abstract Stretches the contrast of a PlanarF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Find minimum and maximum value of the input image: loVal, hiVal;
 *      scale_factor = ( maxVal - minVal ) / (float) ( hiVal - loVal );
 *      Transfer the image. For each pixel do:
 *          dest[x] = (src[x] - loVal) * scale_factor + minVal;
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * vImageEndsInContrastStretch_PlanarF or vImageInterpolatedLookupTable_PlanarF may be used instead when more control
 * over the stretch is desired.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param histogram_entries The number of histogram entries, or bins to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be
 *                      clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the first histogram entry.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will
 *                      be clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the last histogram entry.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 * @/textblock</pre>
 *
 * @return The following error codes may be returned
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageContrastStretch_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageContrastStretch_ARGB8888
 * @abstract Stretches the contrast of an ARGB8888 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel:
 *          Compute the histogram of the input image;
 *          Generate LookUp table based on the histogram
 *          Transform final image using the LUT. For each pixel, do the following:
 *              dest[x] = LUT[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *
 * vImageEndsInContrastStretch_ARGB8888 or vImageTableLookUp_ARGB8888 may be used instead when more control
 * over the stretch is desired.
 *
 * @param src       A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest      A pointer to a vImage buffer that references the destination pixels
 *
 * @param flags     The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageContrastStretch_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageContrastStretch_ARGBFFFF
 *
 * @abstract Stretches the contrast of  an ARGBFFFF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *        For each channel:
 *            Find minimum and maximum value of the input image: loVal, hiVal;
 *            scale_factor = ( maxVal - minVal ) / (float) ( hiVal - loVal );
 *            Transfer the image. For each pixel do:
 *                dest[x] = (src[x] - loVal) * scale_factor + minVal;
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *                      This minimum value is applied to each of the four channels separately.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry. 
 *                      This maximum value is applied to each of the four channels separately.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 * @/textblock<pre>
 */
@available(OSX 10.3, *)
func vImageContrastStretch_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageEndsInContrastStretch_Planar8
 *
 * @abstract Performs an ends-in contrast stretch operation on a Planar8 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image;
 *      Generate LookUp table based on the histogram and percentage parameters
 *      Transform final image using the LookUp table. For each pixel, do the following:
 *          dest[x] = LUT[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param percent_low   A percentage value.
 *                      The number of pixels that map to the lowest end of the histogram of the
 *                      transformed image should represent this percentage of the total pixels.
 *    
 * @param percent_high  A percentage value.
 *                      The number of pixels that map to the highest end of the histogram of the 
 *                      transformed image should represent this percentage of the total pixels.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageInvalidParameter         percent_low + percent_high is greater than 100.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageEndsInContrastStretch_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ percent_low: UInt32, _ percent_high: UInt32, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageEndsInContrastStretch_PlanarF
 *
 * @abstract Performs an ends-in contrast stretch operation on a PlanarF source image.
 * @discussion 
 * <pre>@textblock
 *      Compute the histogram of the input image;
 *      Generate LookUp table based on the histogram and percentage parameters
 *      Transform final image using the LookUp table. For each pixel, do the following:
 *          val = histogram_entries * (src[x] - minVal) / ( maxVal - minVal );
 *          i = clip val between 0 and histogram_entries-1
 *          dest[x] = LUT[i];
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param percent_low   A percentage value.
 *                      The number of pixels that map to the lowest end of the histogram of the
 *                      transformed image should represent this percentage of the total pixels.
 *    
 * @param percent_high  A percentage value.
 *                      The number of pixels that map to the highest end of the histogram of the 
 *                      transformed image should represent this percentage of the total pixels.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value, the low end of the histogram.
 *                      Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *
 * @param maxVal        A maximum pixel value, the high end of the histogram.
 *                      Any pixel value greater than this will be clipped to this value 
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry.
 *
 * @param    flags      The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal, histogram_entries is 0 or
 *                                   percent_low + percent_high is greater than 100.
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageEndsInContrastStretch_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ percent_low: UInt32, _ percent_high: UInt32, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageEndsInContrastStretch_ARGB8888
 *
 * @abstract Performs an ends-in contrast stretch operation on an ARGB8888 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel:
 *          Compute the histogram of the input image;
 *          Generate LookUp table based on the histogram and percentage parameters
 *          Transform final image using the LookUp table. For each pixel, do the following:
 *              dest[x] = LUT[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the percent_low and percent_high parameters match the order of the channels.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param percent_low   An array of four percentage values, one each for alpha, red, green, and blue.
 *                      The number of pixels that map to the lowest end of the histogram of the
 *                      transformed image should represent this percentage of the total pixels.
 *    
 * @param percent_high  An array of four percentage values, one each for alpha, red, green, and blue.
 *                      The number of pixels that map to the highest end of the histogram of the 
 *                      transformed image should represent this percentage of the total pixels.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src, dest, percent_low or percent_high pointer is NULL.
 *   kvImageInvalidParameter         Some of percent_low[i]+percent_high[i] is greater than 100.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageEndsInContrastStretch_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ percent_low: UnsafePointer<UInt32>, _ percent_high: UnsafePointer<UInt32>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageEndsInContrastStretch_ARGBFFFF
 *
 * @abstract Performs a histogram specification operation on an ARGBFFFF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel do:
 *          Compute the histogram of the input image;
 *          Generate LookUp table based on the histogram and percentage parameters
 *          Transform final image using the LookUp table. For each pixel, do the following:
 *              val = histogram_entries * (src[x] - minVal) / ( maxVal - minVal );
 *              i = clip val between 0 and histogram_entries-1
 *              dest[x] = LUT[i];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the percent_low and percent_high parameters match the order of the channels.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param percent_low   An array of four percentage values, one each for alpha, red, green, and blue.
 *                      The number of pixels that map to the lowest end of the histogram of the
 *                      transformed image should represent this percentage of the total pixels.
 *    
 * @param percent_high  An array of four percentage values, one each for alpha, red, green, and blue.
 *                      The number of pixels that map to the highest end of the histogram of the 
 *                      transformed image should represent this percentage of the total pixels.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *                      This minimum value is applied to each of the four channels separately.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry. 
 *                      This maximum value is applied to each of the four channels separately.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal, histogram_entries is 0 or 
 *                                   some of percent_low[i]+percent_high[i] is greater than 100.
 *   kvImageNullPointerArgument      src, dest, percent_low or percent_high pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
@available(OSX 10.3, *)
func vImageEndsInContrastStretch_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ percent_low: UnsafePointer<UInt32>, _ percent_high: UnsafePointer<UInt32>, _ histogram_entries: UInt32, _ minVal: Pixel_F, _ maxVal: Pixel_F, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageDilate_Planar8
 *  @abstract Apply a dilate filter to a Planar8 image
 *  @discussion  This is a general purpose dilate filter for Planar8 data. It is optimized to handle the special cases that occur
 *               in image masks -- large contiguous regions of all 0xff or 0x0. If your filter is all 0's, you should use vImageMax_Planar8
 *               instead. 
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = CLIP( r );
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image. 
 *
 *                Does not work in place.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the 
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageDilate_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<UInt8>, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageDilate_PlanarF
 *  @abstract Apply a dilate filter to a PlanarF image
 *  @discussion  This is a general purpose dilate filter for Planar8 data. If your filter is all 0's, you should use vImageMax_PlanarF
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float r = -INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place. Floating-point values have host endianness.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageDilate_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageDilate_ARGB8888
 *  @abstract Apply a dilate filter to a ARGB8888 image
 *  @discussion  This is a general purpose dilate filter for ARGB8888 data. If your filter is all 0's, you should use vImageMax_ARGB8888
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int a = 0;
 *                      int r = 0;
 *                      int g = 0;
 *                      int b = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
 *                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
 *                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : CLIP( a );
 *                      result[i][j][1] = CLIP( r );
 *                      result[i][j][2] = CLIP( g );
 *                      result[i][j][3] = CLIP( b );
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place. If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. 
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a dilate filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageDilate_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<UInt8>, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageDilate_ARGBFFFF
 *  @abstract Apply a dilate filter to a ARGBFFFF image
 *  @discussion  This is a general purpose dilate filter for ARGBFFFF data. If your filter is all 0's, you should use vImageMax_ARGBFFFF
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float a = -INFINITY;
 *                      float r = -INFINITY;
 *                      float g = -INFINITY;
 *                      float b = -INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
 *                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
 *                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place.  If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. Floating-point values have host
 *                endianness.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first float in pixel in memory) is copied to the destination
 *                                          without modification, instead of having a dilate filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageDilate_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageErode_Planar8
 *  @abstract Apply a erode filter to a Planar8 image
 *  @discussion  This is a general purpose erode filter for Planar8 data. If your filter is all 0's, you should use vImageMin_Planar8
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = MAX_CHANNEL_VALUE;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = CLIP( r );
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageErode_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<UInt8>, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageErode_PlanarF
 *  @abstract Apply a erode filter to a PlanarF image
 *  @discussion  This is a general purpose erode filter for Planar8 data. If your filter is all 0's, you should use vImageMin_PlanarF
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float r = INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place. Floating-point values have host endianness.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageErode_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageErode_ARGB8888
 *  @abstract Apply a erode filter to a ARGB8888 image
 *  @discussion  This is a general purpose erode filter for ARGB8888 data. If your filter is all 0's, you should use vImageMin_ARGB8888
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int a = 255;
 *                      int r = 255;
 *                      int g = 255;
 *                      int b = 255;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
 *                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
 *                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : CLIP( a );
 *                      result[i][j][1] = CLIP( r );
 *                      result[i][j][2] = CLIP( g );
 *                      result[i][j][3] = CLIP( b );
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place. If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a erode filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageErode_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<UInt8>, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageErode_ARGBFFFF
 *  @abstract Apply a erode filter to a ARGBFFFF image
 *  @discussion  This is a general purpose erode filter for ARGBFFFF data. If your filter is all 0's, you should use vImageMin_ARGBFFFF
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float a = INFINITY;
 *                      float r = INFINITY;
 *                      float g = INFINITY;
 *                      float b = INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
 *                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
 *                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place.  If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. Floating-point values have host
 *                endianness.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first float in pixel in memory) is copied to the destination
 *                                          without modification, instead of having a erode filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageErode_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel: UnsafePointer<Float>, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function   vImageMax_Planar8
 *  @abstract   Apply a max filter to a Planar8 image.
 *  @discussion A max filter is a special case dilate filter, in which the filter elements are all 0. It is much faster than the normal dilate.
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *                If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place, unless the kvImageDoNotTile flag is used.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed 
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of 
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. It also
 *                                          allows the function to work in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageMax_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function   vImageMax_PlanarF
 *  @abstract   Apply a max filter to a PlanarF image.
 *  @discussion A max filter is a special case dilate filter, in which the filter elements are all 0. It is much faster than the normal dilate.
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float r = -INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *                If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place, unless the kvImageDoNotTile flag is used.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size 
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. It also
 *                                          allows the function to work in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return the size of the temp buffer needed.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageMax_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageMax_ARGB8888
 *  @abstract Apply a max filter to a ARGB8888 image
 *  @discussion  This is a special purpose dilate filter for ARGB8888 data, for rectangular kernels with value 0. It is much faster than the normal dilate.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int a = 0;
 *                      int r = 0;
 *                      int g = 0;
 *                      int b = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
 *                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
 *                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *                Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably 
 *                run more slowly.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. 
 *                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a max filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageMax_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageMax_ARGBFFFF
 *  @abstract Apply a max filter to a ARGBFFFF image
 *  @discussion  This is a special purpose dilate filter for ARGBFFFF data, for rectangular kernels with value 0. It is much faster than the normal dilate.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float a = -INFINITY;
 *                      float r = -INFINITY;
 *                      float g = -INFINITY;
 *                      float b = -INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
 *                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
 *                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *                Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
 *                run more slowly.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a max filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageMax_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function   vImageMin_Planar8
 *  @abstract   Apply a min filter to a Planar8 image.
 *  @discussion A min filter is a special case erode filter, in which the filter elements are all 0.  It is much faster than the normal erode.
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = MAX_CHANNEL_VALUE;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *                If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place, unless the kvImageDoNotTile flag is used.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. It also
 *                                          allows the function to work in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageMin_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function   vImageMin_PlanarF
 *  @abstract   Apply a min filter to a PlanarF image.
 *  @discussion A min filter is a special case erode filter, in which the filter elements are all 0. It is much faster than the normal erode.
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float r = INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *                If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place, unless the kvImageDoNotTile flag is used.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. It also
 *                                          allows the function to work in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageMin_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageMin_ARGB8888
 *  @abstract Apply a min filter to a ARGB8888 image
 *  @discussion  This is a special purpose erode filter for ARGB8888 data, for rectangular kernels with value 0. It is much faster than the normal erode.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int a = MAX_CHANNEL_VALUE;
 *                      int r = MAX_CHANNEL_VALUE;
 *                      int g = MAX_CHANNEL_VALUE;
 *                      int b = MAX_CHANNEL_VALUE;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
 *                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
 *                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *                Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
 *                run more slowly.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a min filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageMin_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageMin_ARGBFFFF
 *  @abstract Apply a min filter to a ARGBFFFF image
 *  @discussion  This is a special purpose erode filter for ARGBFFFF data, for rectangular kernels with value 0. It is much faster than the normal erode.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float a = INFINITY;
 *                      float r = INFINITY;
 *                      float g = INFINITY;
 *                      float b = INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
 *                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
 *                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *                Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
 *                run more slowly.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a min filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
@available(OSX 10.3, *)
func vImageMin_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ srcOffsetToROI_X: vImagePixelCount, _ srcOffsetToROI_Y: vImagePixelCount, _ kernel_height: vImagePixelCount, _ kernel_width: vImagePixelCount, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageMatrixMultiply_Planar16S(srcs: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ dests: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ src_planes: UInt32, _ dest_planes: UInt32, _ matrix: UnsafePointer<Int16>, _ divisor: Int32, _ pre_bias: UnsafePointer<Int16>, _ post_bias: UnsafePointer<Int32>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageMatrixMultiply_Planar8(srcs: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ dests: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ src_planes: UInt32, _ dest_planes: UInt32, _ matrix: UnsafePointer<Int16>, _ divisor: Int32, _ pre_bias: UnsafePointer<Int16>, _ post_bias: UnsafePointer<Int32>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageMatrixMultiply_PlanarF(srcs: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ dests: UnsafeMutablePointer<UnsafePointer<vImage_Buffer>>, _ src_planes: UInt32, _ dest_planes: UInt32, _ matrix: UnsafePointer<Float>, _ pre_bias: UnsafePointer<Float>, _ post_bias: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageMatrixMultiply_ARGB8888(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ matrix: UnsafePointer<Int16>, _ divisor: Int32, _ pre_bias: UnsafePointer<Int16>, _ post_bias: UnsafePointer<Int32>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageMatrixMultiply_ARGBFFFF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ matrix: UnsafePointer<Float>, _ pre_bias: UnsafePointer<Float>, _ post_bias: UnsafePointer<Float>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageMatrixMultiply_ARGB8888ToPlanar8
 * @abstract apply a 1d matrix to a four channel, 8-bit per component image and get a 1-channel 8-bit image as a result
 * @discussion vImageMatrixMultiply_ARGB8888ToPlanar8 is like vImageMatrixMultiply_ARGB8888, except that it produces
 *             only a single channel of output. It is intended to produce grayscale images from four channel content,
 *             but can be used for other purposes.  
 *  <pre>@textblock
 *                  for each pixel[y][x] in image:
 *                      int32_t p = (pixel[y][x][0] + pre_bias[0]) * matrix[0]  +
 *                                  (pixel[y][x][1] + pre_bias[1]) * matrix[1]  +
 *                                  (pixel[y][x][2] + pre_bias[2]) * matrix[2]  +
 *                                  (pixel[y][x][3] + pre_bias[3]) * matrix[3];
 *                      result[y][x] = CLAMP( ( p + post_bias ) / divisor, 0, 0xff);
 *  @/textblock </pre>
 *             If you intend to just extract a single channel without modification (e.g. alpha), please see 
 *             vImageExtractChannel_ARGB8888.  This function will work in place, provided that src->data = dest->data
 *             and src->rowBytes = dest->rowBytes.  
 *
 *  @param      src         A four channel, 8-bit per component input buffer. It does not have to be ARGB.
 *
 *  @param      dest        A preallocated buffer to receive the 8-bit per component monochromatic result.
 *
 *  @param      matrix      The 1D matrix by which to multiply each pixel.
 *
 *  @param      divisor     Used to renormalize the image after scaling by the matrix. Typically this is the 
 *                          sum over the matrix. If 0, 1 will be used. A faster implementation may be available
 *                          if the divisor is an integer power of 2.
 *
 *  @param      pre_bias    A set of values used to correct the input image so that 0 is encoded as 0.  For example,
 *                          if the input image is 444 AYCbCr video range, then {0, -16, -128, -128} could be used here.
 *                          If NULL, {0,0,0,0} will be used.
 *  
 *  @param      post_bias   A value added to the sum at the end to provide both for rounding control and for
 *                          allowing for a bias to be encoded into the image format.  Typically, this is just
 *                          divisor/2 to allow for round to nearest behavior. However, other values may be appropriate
 *                          if the encoding for 0.0 is not 0.  For example, for video range luminance, you might
 *                          pass 16 * divisor + divisor/2. 
 *
 *  @param      flags       The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags                      Default operation
 *          kvImageDoNotTile                    Disable internal multithreading.
 *          kvImageGetTempBufferSize            return 0, do no work
 *          kvImagePrintDiagnosticsToConsole    Might print more helpful diagnostic info to the console in the event of an
 *                                              error.
 *      @/textblock</pre>
 *
 *  @return     The following error codes may be returned:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *          0                                   If kvImageGetTempBufferSize was passed, 0 is returned and no work is done on the image.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and height must be less than or equal to the corresponding dimension of src.
 *
 *          kvImageUnknownFlagsBit              A flag not from the above list of flags was passed in.
 *      @/textblock </pre>
 */
@available(OSX 10.11, *)
func vImageMatrixMultiply_ARGB8888ToPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ matrix: UnsafePointer<Int16>, _ divisor: Int32, _ pre_bias: UnsafePointer<Int16>, _ post_bias: Int32, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageMatrixMultiply_ARGBFFFFToPlanarF
 * @abstract apply a 1d matrix to a four channel, float per component image and get a 1-channel float image as a result
 * @discussion vImageMatrixMultiply_ARGBFFFFToPlanarF is like vImageMatrixMultiply_ARGBFFFF, except that it produces
 *             only a single channel of output. It is intended to produce grayscale images from four channel content,
 *             but can be used for other purposes.
 *  <pre>@textblock
 *                  for each pixel[y][x] in image:
 *                      float p =   (pixel[y][x][0] + pre_bias[0]) * matrix[0]  +
 *                                  (pixel[y][x][1] + pre_bias[1]) * matrix[1]  +
 *                                  (pixel[y][x][2] + pre_bias[2]) * matrix[2]  +
 *                                  (pixel[y][x][3] + pre_bias[3]) * matrix[3];
 *                      result[y][x] = p + post_bias;
 *  @/textblock </pre>
 *             vImage reserves the right to reorder computation from the above formulation to improve performance.
 *             If you intend to just extract a single channel without modification (e.g. alpha), please see
 *             vImageExtractChannel_ARGBFFFF. This function will work in place, provided that src->data = dest->data
 *             and src->rowBytes = dest->rowBytes.
 *
 *  @param      src         A four channel, floating-point input buffer. It does not have to be ARGB.
 *
 *  @param      dest        A preallocated buffer to receive the floating-point monochromatic result.
 *
 *  @param      matrix      The 1D matrix by which to multiply each pixel.
 *
 *  @param      pre_bias    A set of values used to correct the input image so that 0 is encoded as 0.
 *                          If NULL, {0,0,0,0} will be used.
*
 *  @param      post_bias   A value added to the sum at the end to provide both for rounding control and for
 *                          allowing for a bias to be encoded into the image format.  Typically, this is just
 *                          zero.
 *
 *  @param      flags       The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags                      Default operation
 *          kvImageDoNotTile                    Disable internal multithreading.
 *          kvImageGetTempBufferSize            return 0, do no work
 *          kvImagePrintDiagnosticsToConsole    Might print more helpful diagnostic info to the console in the event of an
 *                                              error.
 *      @/textblock</pre>
 *
 *  @return     The following error codes may be returned:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *          0                                   If kvImageGetTempBufferSize was passed, 0 is returned and no work is done on the image.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and height must be less than or equal to the corresponding dimension of src.
 *
 *          kvImageUnknownFlagsBit              A flag not from the above list of flags was passed in.
 *      @/textblock </pre>
 */
@available(OSX 10.11, *)
func vImageMatrixMultiply_ARGBFFFFToPlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ matrix: UnsafePointer<Float>, _ pre_bias: UnsafePointer<Float>, _ post_bias: Float, _ flags: vImage_Flags) -> vImage_Error
var kvImageGamma_UseGammaValue: Int { get }
var kvImageGamma_UseGammaValue_half_precision: Int { get }
var kvImageGamma_5_over_9_half_precision: Int { get }
var kvImageGamma_9_over_5_half_precision: Int { get }
var kvImageGamma_5_over_11_half_precision: Int { get }
var kvImageGamma_11_over_5_half_precision: Int { get }
var kvImageGamma_sRGB_forward_half_precision: Int { get }
var kvImageGamma_sRGB_reverse_half_precision: Int { get }
var kvImageGamma_11_over_9_half_precision: Int { get }
var kvImageGamma_9_over_11_half_precision: Int { get }
var kvImageGamma_BT709_forward_half_precision: Int { get }
var kvImageGamma_BT709_reverse_half_precision: Int { get }
@available(OSX 10.4, *)
func vImageCreateGammaFunction(gamma: Float, _ gamma_type: Int32, _ flags: vImage_Flags) -> GammaFunction
@available(OSX 10.4, *)
func vImageDestroyGammaFunction(f: GammaFunction)
@available(OSX 10.4, *)
func vImageGamma_Planar8toPlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ gamma: GammaFunction, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageGamma_PlanarFtoPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ gamma: GammaFunction, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageGamma_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ gamma: GammaFunction, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePiecewiseGamma_Planar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ exponentialCoeffs: UnsafePointer<Float>, _ gamma: Float, _ linearCoeffs: UnsafePointer<Float>, _ boundary: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePiecewiseGamma_Planar8toPlanar16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ exponentialCoeffs: UnsafePointer<Float>, _ gamma: Float, _ linearCoeffs: UnsafePointer<Float>, _ boundary: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePiecewiseGamma_Planar16Q12(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ exponentialCoeffs: UnsafePointer<Float>, _ gamma: Float, _ linearCoeffs: UnsafePointer<Float>, _ boundary: Pixel_16S, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePiecewiseGamma_Planar16Q12toPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ exponentialCoeffs: UnsafePointer<Float>, _ gamma: Float, _ linearCoeffs: UnsafePointer<Float>, _ boundary: Pixel_16S, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePiecewiseGamma_Planar8toPlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ exponentialCoeffs: UnsafePointer<Float>, _ gamma: Float, _ linearCoeffs: UnsafePointer<Float>, _ boundary: Pixel_8, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePiecewiseGamma_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ exponentialCoeffs: UnsafePointer<Float>, _ gamma: Float, _ linearCoeffs: UnsafePointer<Float>, _ boundary: Float, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImagePiecewiseGamma_PlanarFtoPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ exponentialCoeffs: UnsafePointer<Float>, _ gamma: Float, _ linearCoeffs: UnsafePointer<Float>, _ boundary: Float, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImagePiecewisePolynomial_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ coefficients: UnsafeMutablePointer<UnsafePointer<Float>>, _ boundaries: UnsafePointer<Float>, _ order: UInt32, _ log2segments: UInt32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImagePiecewisePolynomial_Planar8toPlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ coefficients: UnsafeMutablePointer<UnsafePointer<Float>>, _ boundaries: UnsafePointer<Float>, _ order: UInt32, _ log2segments: UInt32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImagePiecewisePolynomial_PlanarFtoPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ coefficients: UnsafeMutablePointer<UnsafePointer<Float>>, _ boundaries: UnsafePointer<Float>, _ order: UInt32, _ log2segments: UInt32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.11, *)
func vImageSymmetricPiecewisePolynomial_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ coefficients: UnsafeMutablePointer<UnsafePointer<Float>>, _ boundaries: UnsafePointer<Float>, _ order: UInt32, _ log2segments: UInt32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImagePiecewiseRational_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ topCoefficients: UnsafeMutablePointer<UnsafePointer<Float>>, _ bottomCoefficients: UnsafeMutablePointer<UnsafePointer<Float>>, _ boundaries: UnsafePointer<Float>, _ topOrder: UInt32, _ bottomOrder: UInt32, _ log2segments: UInt32, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageLookupTable_Planar8toPlanar16(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ table: UnsafePointer<Pixel_16U>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageLookupTable_Planar8toPlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ table: UnsafePointer<Pixel_F>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageLookupTable_PlanarFtoPlanar8(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ table: UnsafePointer<Pixel_8>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageLookupTable_8to64U(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ LUT: UnsafePointer<UInt64>, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.4, *)
func vImageInterpolatedLookupTable_PlanarF(src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ table: UnsafePointer<Pixel_F>, _ tableEntries: vImagePixelCount, _ maxFloat: Float, _ minFloat: Float, _ flags: vImage_Flags) -> vImage_Error
typealias vImage_MultidimensionalTable = COpaquePointer
struct vImageMDTableUsageHint : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var kvImageMDTableHint_16Q12: vImageMDTableUsageHint { get }
var kvImageMDTableHint_Float: vImageMDTableUsageHint { get }
@available(OSX 10.9, *)
func vImageMultidimensionalTable_Create(tableData: UnsafePointer<UInt16>, _ numSrcChannels: UInt32, _ numDestChannels: UInt32, _ table_entries_per_dimension: UnsafePointer<UInt8>, _ hint: vImageMDTableUsageHint, _ flags: vImage_Flags, _ err: UnsafeMutablePointer<vImage_Error>) -> vImage_MultidimensionalTable
@available(OSX 10.9, *)
func vImageMultidimensionalTable_Retain(table: vImage_MultidimensionalTable) -> vImage_Error
@available(OSX 10.9, *)
func vImageMultidimensionalTable_Release(table: vImage_MultidimensionalTable) -> vImage_Error
struct vImage_InterpolationMethod : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var kvImageNoInterpolation: vImage_InterpolationMethod { get }
var kvImageFullInterpolation: vImage_InterpolationMethod { get }
var kvImageHalfInterpolation: vImage_InterpolationMethod { get }
@available(OSX 10.9, *)
func vImageMultiDimensionalInterpolatedLookupTable_PlanarF(srcs: UnsafePointer<vImage_Buffer>, _ dests: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ table: vImage_MultidimensionalTable, _ method: vImage_InterpolationMethod, _ flags: vImage_Flags) -> vImage_Error
@available(OSX 10.9, *)
func vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12(srcs: UnsafePointer<vImage_Buffer>, _ dests: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ table: vImage_MultidimensionalTable, _ method: vImage_InterpolationMethod, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageBuffer_InitWithCVPixelBuffer
 *
 * @abstract Initializes a vImage_Buffer to contain a representation of the CVPixelBufferRef provided.
 * @discussion It does the following:
 *
 *  <pre>
 *  @textblock
 *      o   Set buffer->height and buffer->width to match the size of the provided image.
 *
 *      o   set buffer->rowBytes for good performance                               (see kvImageDoNotAllocate flag below)
 *
 *      o   allocate a region of memory and assign a pointer to it to buffer->data  (see kvImageDoNotAllocate flag below)
 *
 *      o   convert the pixels contained in the image to the desired format and write to buffer->data.
 *  @/textblock
 *  </pre>
 *
 *
 * The entire image is converted. If you want to convert less, you can do so using vImageConvert_AnyToAny and a converter prepared with 
 * vImageConverter_CreateForCVToCGImageFormat.
 *
 *      @param buffer           A pointer to a vImage_Buffer structure to be initialized. The height and width fields will be overwritten
 *                              with the size of the CVPixelBuffer. Please see the kvImageDoNotAllocate flag description below for
 *                              options about how the buffer->data and buffer->rowBytes field is handled.
 *
 *      @param desiredFormat    image format for the vImage_Buffer.
 *
 *      @param cvPixelBuffer    A CVPixelBufferRef for the image. It is not necessary to lock the CVPixelBuffer before calling this function.
 *
 *      @param cvImageFormat    An optional vImageCVImageFormatRef to specify the pixel format of the CVPixelBuffer.
 *
 *                                  If NULL, vImage attempts to discover this information automatically from the CVPixelBuffer. However, sometimes
 *                                  necessary color information in the CVPixelBuffer is missing, preventing conversion.  An error will be returned.
 *                                  See kvImageCVImageFormat return codes for this function for more information. To supply vImage with complete
 *                                  color information, provide a complete vImageCVImageFormatRef here.
 *
 *                                  If not NULL, the cvImageFormat is used instead of looking to the CVPixelBufferRef for color information. If the
 *                                  cvImageFormat is also incomplete, a kvImageCVImageFormat_ error code will be returned.
 *
 *      @param backgroundColor  In cases where the vImage_Buffer format specifies opaque alpha and the cvPixelBuffer is has non-opaque alpha, the
 *                              image will be composited against a background color to remove the alpha before writing to the vImage_Buffer. The
 *                              background color is given in the colorspace of the desiredFormat.
 *
 *
 *      @param flags    The following flags are understood by this function:
 *
 *          <pre>
 *          @textblock
 *          kvImageDoNotAllocate        Under normal operation, new memory is allocated to hold the image pixels and its address is written
 *                                      to buffer->data. You are responsible for freeing that data when you are done with it, using free(). 
 *                                      When the kvImageDoNotAllocate flag is set, the buffer->data pointer and buffer->rowBytes is used unmodified.  
 *                                      This is intended to allow you to allocate the buffer yourself, or write directly into part of another image.
 *                                      Use CVPixelBufferGetHeight() and CVPixelBufferGetWidth() to find the size of the result buffer.
 *
 *          kvImageDoNotTile            Disable internal multithreading. This may be desired if you are extracting many
 *                                      such images in parallel, or are otherwise attempting to keep CPU utilization to
 *                                      a single core.
 *
 *          kvImageHighQualityResampling    For some CVPixelBuffer formats, the chroma channels are subsampled. This flag directs
 *                                          vImage to spend extra time where it can to give better image quality.
 *
 *          kvImagePrintDiagnosticsToConsole    In case of an error, print human readable error messages to the Apple System Logger (Console).
 *                                              This is useful for debugging, but probably should not be on for a shipping application.
 *          @/textblock
 *          </pre>
 *
 *  @return
 *          <pre>
 *          @textblock
 *      kvImageMemoryAllocationError            buffer->data was not able to be allocated.
 *
 *      kvImageBufferSizeMismatch               buffer and cvPixelBuffer are not the same height and width
 *
 *      kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
 *
 *      kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
 *
 *      kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the CVPixelBuffer / vImageCVImageFormatRef.
 *
 *      kvImageInvalidParameter                 buffer is NULL
 *
 *      kvImageInvalidImageObject               cvPixelBuffer is NULL or can not be locked
 *
 *      kvImageInvalidImageFormat               desiredFormat is NULL or points to an illegal CG image format
 *
 *      Note: Some CVPixelBuffers have incompletely specified color information. This makes it impossible for vImage to do the conversion.
 *            When this happens, you will get one of the kvImageCVImageFormat_ errors above. To proceed, create a vImageCVImageFormatRef, add
 *            the missing information and pass as the cvImageFormat parameter. It is possible that more than one piece of information is missing.
 *            If the vImageCVImageFormatRef is missing information, then you will also get these errors.
 *          @/textblock
 *          </pre>
 *
 * Returned image notes:
 *
 *      vImage here conforms to CoreVideo practice of substituting gamma 1/1.961 for kCVImageBufferTransferFunction_ITU_R_709_2 and
 *      kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using the ITU-R BT.709-5 specified transfer function.  You may
 *      manually set the transfer function using vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() and vImageCVImageFormat_SetColorSpace().
 *      vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() does not make this substitution.
 */
@available(OSX 10.10, *)
func vImageBuffer_InitWithCVPixelBuffer(buffer: UnsafeMutablePointer<vImage_Buffer>, _ desiredFormat: UnsafeMutablePointer<vImage_CGImageFormat>, _ cvPixelBuffer: CVPixelBuffer, _ cvImageFormat: vImageCVImageFormat!, _ backgroundColor: UnsafePointer<CGFloat>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageBuffer_CopyToCVPixelBuffer
 * @abstract Copies the contents of the vImage_Buffer to a CVPixelBufferRef.
 * @discussion If the format of the vImage_Buffer doesn't match the CVPixelBuffer format, the image will be converted to the CVPixelBuffer 
 *              format as part of the copy.
 *
 *  The entire CVPixelBuffer is overwritten. If you want to copy less, you can do so using vImageConvert_AnyToAny and a converter prepared
 *  with vImageConverter_CreateForCFToCVImageFormat.
 *
 *  vImage here conforms to CoreVideo practice of substituting gamma 1/1.961 for kCVImageBufferTransferFunction_ITU_R_709_2 and
 *  kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using the ITU-R BT.709-5 specified transfer function.  You may
 *  manually set the transfer function using vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() and vImageCVImageFormat_SetColorSpace().
 *  ImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() does not make this substitution.
 *
 *
 *      @param buffer          A pointer to a vImage_Buffer containing the pixels to be copied (converted) to the CVPixelBuffer. May not be NULL.
 *
 *      @param bufferFormat    The format of buffer. May not be NULL.
 *
 *      @param cvPixelBuffer   The CVPixelBufferRef where the image will be written.  It should be a valid, preallocated CVPixelBufferRef
 *                      set to the desired image type (which need not match bufferFormat).  It is not necessary to lock the 
 *                      CVPixelBuffer before calling this function. May not be NULL.
 *
 *      @param cvImageFormat   An optional vImageCVImageFormatRef to specify the pixel format of the CVPixelBuffer.
 *
 *                      If NULL, vImage attempts to discover this information automatically. However, sometimes necessary color information
 *                      in the CVPixelBuffer is missing, preventing conversion.  An error will be returned. See kvImageCVImageFormat return 
 *                      codes for this function for more information. To supply vImage with complete color information, provide a complete 
 *                      vImageCVImageFormatRef here.
 *
 *                      If not NULL, the cvImageFormat is used instead of looking to the CVPixelBufferRef for color information. If the 
 *                      cvImageFormat is also incomplete, a kvImageCVImageFormat_ error code will be returned.
 *
 *                          CAUTION: In this case, it is your responsibility to make sure that the CVPixelBuffer has the right 
 *                                   attachments for matrix, chroma siting and colorspace as necessary to be properly decoded.
 *                                   vImage does not set these things for you.
 *
 *      @param backgroundColor If bufferFormat->bitmapInfo encodes kCGImageAlphaPremultipliedLast, kCGImageAlphaPremultipliedFirst,
 *                      kCGImageAlphaLast or kCGImageAlphaFirst -- that is, has a real alpha channel -- and the CVPixelBuffer
 *                      does not (most CV pixel formats don't) then the image will be flattened against a solid color to remove
 *                      the alpha information. You can select which color that is here. The background color is a CGFloat[3] 
 *                      (red, green, blue) in the RGB colorspace of the CVPixelBuffer. (YpCbCr images reference a RGB colorspace
 *                      through a matrix like ITU-709. That is the RGB colorspace we are talking about here.)  
 *
 *                      This parameter may be NULL, indicating black. 
 *
 *                      If you want to skip flattening, you can substitute in kCGImageAlphaNoneSkipFirst/Last for the encoding of
 *                      the input buffer. This may lead to undesired results in the case of premultiplied alpha however, when alpha 
 *                      is not all either 1.0 or 0. In that case, unpremultiply it first as a separate pass. Unpremultiplication may 
 *                      be more costly than just flattening it, but does not introduce regions of background color into the image.
 *
 *      @param flags           The following flags are understood by this function:
 *
 *          <pre>
 *          @textblock
 *          kvImageNoFlags                      Default operation.
 *
 *          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
 *                                              many such operations going concurrently, and in cases where it is desirable to keep
 *                                              CPU utilization to a single core.
 *
 *          kvImageHighQualityResampling        For some CVPixelBuffer formats, the chroma channels are subsampled. This flag directs
 *                                              vImage to spend extra time where it can to give better image quality.
 *
 *          kvImagePrintDiagnosticsToConsole    In case of an error, print human readable error messages to the Apple System Logger (Console).
 *                                              This is useful for debugging, but probably should not be on for a shipping application.
 *          @/textblock
 *          </pre>
 *
 *      @return  
 *          <pre>
 *          @textblock
 *          kvImageNoError                          Success
 *
 *          kvImageInvalidImageFormat               bufferFormat is NULL or encodes an invalid format
 *
 *          kvImageBufferSizeMismatch               buffer and cvPixelBuffer are not the same height and width
 *
 *          kvImageNullPointerArgument              buffer and cvPixelBuffer may not be NULL
 *
 *          kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
 *
 *          kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
 *
 *          kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the CVPixelBuffer / vImageCVImageFormatRef.
 *          @/textblock
 *          </pre>
 *
 *          Note: Some CVPixelBuffers have incompletely specified color information. This makes it impossible for vImage to do the conversion.
 *            When this happens, you will get one of the kvImageCVImageFormat_ errors above. To proceed, create a vImageCVImageFormatRef, add
 *            the missing information and pass as the cvImageFormat parameter. It is possible that more than one piece of information is missing.
 *
 */
@available(OSX 10.10, *)
func vImageBuffer_CopyToCVPixelBuffer(buffer: UnsafePointer<vImage_Buffer>, _ bufferFormat: UnsafePointer<vImage_CGImageFormat>, _ cvPixelBuffer: CVPixelBuffer, _ cvImageFormat: vImageCVImageFormat!, _ backgroundColor: UnsafePointer<CGFloat>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageCVImageFormat_CreateWithCVPixelBuffer
 * @abstract Used to create a vImageCVImageFormatRef to describe the pixel format of an existing CVPixelBufferRef.
 *
 * @discussion If the CVPixelBufferRef has incomplete pixel format information, the vImageCVImageFormatRef will also be incomplete. Not all
 * missing fields ultimately will prove to be necessary, however.  If a function that consumes a vImageCVImageFormatRef returns a
 * vImageCVImageFormatError code, please add the missing information and try again. See "vImageCVImageFormatRef Accessors" below.
 *
 * @param buffer        The CBPixelBufferRef on which to base the vImageCVImageFormatRef
 *
 * @return
 *  On success, a non-NULL vImageCVImageFormatRef is returned. The vImageCVImageFormatRef has a retain count of 1. You are responsible
 *  for releasing it when you are done with it.
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_CreateWithCVPixelBuffer(buffer: CVPixelBuffer!) -> Unmanaged<vImageCVImageFormat>!

/*!
 * @function vImageCVImageFormat_Create
 * @abstract Create a vImageCVImageFormatRef (low level).
 * @discussion This function creates a vImageCVImageFormatRef from first principles. In most cases, vImageCVImageFormat_CreateWithCVPixelBuffer
 *              is easier, but if your video pipeline doesn't use CoreVideo, or you need absolute control then this is your alternative.
 *
 *              Other fields not given by function parameters like number of channels, channel names, and channel description are automatically 
 *              configured using the imageFormatType. User data is set separately with vImageCVImageFormat_SetUserData.
 *
 *
 * @param imageFormatType       A CVPixelFormatType such as '2vuy'. See CVPixelBuffer.h for the complete list.
 *
 * @param  matrix               A vImage_ARGBToYpCbCrMatrix showing how to convert from RGB to the YpCbCr format. This may be NULL. However, it
 *                              is required for conversions involving YpCbCr images, so for YpCbCr images you will be eventually forced to set the matrix
 *                              using vImageCVImageFormat_CopyConversionMatrix before you can make a vImageConverterRef with this object.  
 *                              There are some predefined conversion matrices in Conversion.h for Rec 601 and 709 formats.
 *
 * @param  cvImageBufferChromaLocation   See kCVImageBufferChromaLocationTopFieldKey in CVImageBuffer.h for a list of chroma locations.
 *                              kCVImageBufferChromaLocation_Center is typical.  This may be NULL. However, for YpCbCr formats with downsampled
 *                              chroma, you will be ultimately forced to set a chroma location using vImageCVImageFormat_SetChromaSiting, before
 *                              a vImageConverterRef can be made with this object.
 *
 * @param  baseColorspace       For RGB and monochrome images, this is the colorspace of the image.
 *
 *                              For YpCbCr images, this is the colorspace of the RGB image before it was converted to YpCbCr using the ARGB-to-YpCbCr
 *                              conversion matrix (see matrix parameter above). The colorspace is defined based on the YpCbCr format RGB primaries
 *                              and transfer function.
 *
 *                              This may be NULL. However, you will eventually be forced to set set a colorspace for all image types, before
 *                              a vImageConvertRef can be made with this object.
 *
 * @param  alphaIsOneHint       Typically this is 0. If your image format has an alpha channel, but you know the image is fully opaque,
 *                              or want it to be treated as opaque, you can set this to 1. This may allow for faster conversions to
 *                              opaque formats.
 *
 *
 * @return
 *   On success, a non-NULL vImageCVImageFormatRef will be returned, which encodes the information contained in the above parameters. The 
 *   vImageCVImageFormatRef has a retain count of 1.  You must release it when you are done with it.
 *
 *   On failure, NULL is returned.
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_Create(imageFormatType: UInt32, _ matrix: UnsafePointer<vImage_ARGBToYpCbCrMatrix>, _ cvImageBufferChromaLocation: CFString!, _ baseColorspace: CGColorSpace!, _ alphaIsOneHint: Int32) -> Unmanaged<vImageCVImageFormat>!

/*!
 *  @function vImageCVImageFormat_Copy
 *  @abstract Makes a copy of a vImageCVImageFormatRef.
 *  @discussion The new vImageCVFormatRef is different from the old one in that:
 *
 *      o       Its reference count is 1
 *
 *      o       The userData field and destructor callback are not copied, and are initialized to NULL.
 *
 *  Usually, it is preferable to simply retain a vImageCVImageFormatRef rather than copy it. You may wish to copy a vImageCVImageFormatRef if
 *  you want to modify an existing vImageCVImageFormatRef but can't because it is being read by another thread, or to replace another software layer's
 *  userData pointer with your own.  By convention, the new vImageCVImageFormatRef is considered to have been created by the software layer that called
 *  vImageCVImageFormat_Copy.
 *
 *  @param format  The vImageCVImageFormatRef to copy.
 *
 *  @return
 *  On success, a non-NULL vImageCVImageFormatRef is returned. Its reference count is 1. You are responsible for releasing it when you are done with it.
 *  On failure, this function returns NULL.
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_Copy(format: vImageConstCVImageFormat) -> Unmanaged<vImageCVImageFormat>!

/*! 
 *  @typedef vImageCVImageFormatError
 *  @abstract  Additional error codes for functions that use the vImageCVImageFormatRef
 *  @discussion It is possible for a vImageCVImageFormatRef to contain incomplete information. This frequently happens 
 *              when it is created from a CVPixelBufferRef which itself has incomplete formatting information. It can
 *              also happen by design as the result of something like vImageCVImageFormat_SetColorSpace(fmt, NULL). When
 *              this occurs, the vImageCVImageFormatRef may not contain enough information to perform a requested conversion
 *              (e.g. vImageBuffer_InitWithCVPixelBuffer). In such cases, a vImageCVImageFormatError will be returned
 *              from the left hand side of the function to indicate which field is absent.
 *
 *  @constant   kvImageCVImageFormat_NoError    No error. The conversion was successfully completed. 
 *
 *  @constant   kvImageCVImageFormat_ConversionMatrix The conversion matrix is absent and required. The conversion matrix
 *              provides the conversion from RGB to Y'CbCr.
 *
 *  @constant   kvImageCVImageFormat_ChromaSiting  The chroma siting information is absent.  Chroma siting indicates the position
 *              of chrominance information relative to luminance samples when chrominance is sub-sampled. 
 *
 *  @constant   kvImageCVImageFormat_ColorSpace The colorspace of the image is missing. If Y'CbCr, this is the colorspace of the
 *              RGB image from which the Y'CbCr pixels were calculated. Otherwise, it is the colorspace of the pixels themselves. 
 *              Most CVPixelBuffer formats only allow one or two colorspace models (e.g. kCGColorSpaceModelRGB)
 *
 *  @constant   kvImageCVImageFormat_VideoChannelDescription    The range and clipping information is missing. This is unlikely
 *              to occur, since the information is initialized automatically based on the imageFormatType (See vImageCVImageFormat_Create.)
 *
 *  @constant   kvImageCVImageFormat_AlphaIsOneHint    The alpha-is-one hint tells vImage that the alpha channel (if any) is opaque.
 *                                                      This hint may be used to avoid some computation to flatten the alpha channel
 *                                                      in some cases. Because it is a hint, it can not be missing.
 */
typealias vImageCVImageFormatError = Int
@available(OSX 10.10, *)
var kvImageCVImageFormat_NoError: Int { get }
@available(OSX 10.10, *)
var kvImageCVImageFormat_ConversionMatrix: Int { get }
@available(OSX 10.10, *)
var kvImageCVImageFormat_ChromaSiting: Int { get }
@available(OSX 10.10, *)
var kvImageCVImageFormat_ColorSpace: Int { get }
@available(OSX 10.10, *)
var kvImageCVImageFormat_VideoChannelDescription: Int { get }
@available(OSX 10.10, *)
var kvImageCVImageFormat_AlphaIsOneHint: Int { get }

/*!
    @typedef        vImageChannelDescription
    @abstract       A description of the range and clamp limits for a pixel format
    @discussion     The vImageChannelDescription is provided to allow for "video range" formats and detailed
                    control overclamping on a per-channel basis. The min and max control clamping limits. Values 
                    outside the range [min, max] are clamped to be in that range.  The zero and full values give
                    the normal range and bias for the format. They are the encodings for 0.0 and 1.0 respectively.
                    (0.0 and 0.5 for Chroma.)
 
    @field          min     The minimum encoded value allowed. Values less than this encoding are clamped to this value.
    @field          zero    The encoding for the value 0.0.   For example, for 8-bit chroma data this would be 128. For 
                            8-bit full range Luminance, this is 0. 8-bit video range Luminance is 16. 
    @field          full    The encoding for 1.0 (0.5 for chroma). 
    @field          max     The maximum allowed encoding. Values greater than this are clamped to this value.
 
    @seealso        vImage_YpCbCrPixelRange
    @seealso        vImageCVImageFormatRef channel descriptions
 */
struct vImageChannelDescription {
  var min: CGFloat
  var zero: CGFloat
  var full: CGFloat
  var max: CGFloat
  init()
  init(min: CGFloat, zero: CGFloat, full: CGFloat, max: CGFloat)
}

/*!
 *  @typedef    vImageMatrixType
 *  @abstract   An enumeration of RGB -> Y'CbCr conversion matrix types. 
 *  @description    Currently, only one matrix type is available. Additional formats are reserved for future expansion.
 *
 *  @constant   kvImageMatrixType_ARGBToYpCbCrMatrix    A vImage_ARGBToYpCbCrMatrix
 */
typealias vImageMatrixType = UInt32
@available(OSX 10.10, *)
var kvImageMatrixType_None: Int { get }
@available(OSX 10.10, *)
var kvImageMatrixType_ARGBToYpCbCrMatrix: Int { get }

/*!
 *  @function vImageCVImageFormat_GetFormatCode
 *  @abstract Return the kCVPixelFormatType_ (4 character code) that encodes the pixel format.
 *  @discussion The kCVPixelFormatType_ of a CoreVideo pixel buffer is given by a four character code (4CC), such as '2vuy'. It describes the number of channels,
 *              channel packing order, bits per component (except in one case), and usually range information like whether it is full range or
 *              video range.
 *  @param format   The vImageCVImageFormatRef for which the 4 character code is desired.
 *  @return  A 4CC in host-endian format.
 *  @seealso See CoreVideo/CVPixelBuffer.h for a list of defined 4 character image type codes.
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetFormatCode(format: vImageConstCVImageFormat) -> UInt32

/*!
 *  @function vImageCVImageFormat_GetChannelCount
 *  @abstract Return the the number of color channels in the image, including alpha.
 *  @discussion The channels may be interleaved or planar. For RGBA, the result is 4. For 'yuvs' this is 3. This does not return
 *              the same results as vImageConverter_GetNumberOfSourceBuffers / vImageConverter_GetNumberOfSourceBuffers, which
 *              instead describe the number of vImage_Buffers to pass to vImageConvert_AnyToAny. Some vImage_Buffers contain
 *              multiple channels.
 *  @param format   The vImageCVImageFormatRef for which the number of channels is desired.
 *  @return  A uint32_t containing the number of channels
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetChannelCount(format: vImageConstCVImageFormat) -> UInt32

/*!
 *  @function vImageCVImageFormat_GetChannelNames
 *  @abstract Get a const kvImageBufferTypeCode_EndOfList-terminated array indicating the names of the channels in the buffer.
 *  @discussion The array is owned by the vImageCvImageFormatRef and will cease to be valid when the object is destroyed. 
 *              This function is not useful to discover the correct vImage_Buffer order for a call to vImageConvert_AnyToAny().
 *  @param format   The vImageCVImageFormatRef for which the channel names are desired.
 *  @return  A const pointer to an array of vImageBufferTypeCodes indicating the names of the channels in the image.
 *  @seealso  vImageConverter_GetSourceBufferOrder
 *  @seealso vImageConverter_GetDestinationBufferOrder
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetChannelNames(format: vImageConstCVImageFormat) -> UnsafePointer<vImageBufferTypeCode>

/*!
 *  @function vImageCVImageFormat_GetColorSpace
 *  @abstract Get the colorspace associated with the image.
 *  @discussion If the image format is a Y'CbCr image format, this is the RGB colorspace of the image after the inverse 
 *              RGB->YpCbCr conversion matrix is applied. Otherwise, it is the colorspace of the pixels in the image.
 *  @param format   The vImageCVImageFormatRef for which the colorspace is desired.
 *  @return  The colorspace (if any) that is returned is referenced by the vImageCVImageFormatRef and will be released
 *           when that object is destroyed. This function may return NULL, indicating an absence of colorspace information.
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetColorSpace(format: vImageConstCVImageFormat) -> Unmanaged<CGColorSpace>!

/*!
 *  @function vImageCVImageFormat_SetColorSpace
 *  @abstract Set the colorspace associated with the image.
 *  @discussion If the image format is a Y'CbCr image format, this sets the RGB colorspace of the image before the
 *              RGB->YpCbCr conversion matrix was applied. Otherwise, it is the colorspace of the pixels in the image.
 *              A non-NULL colorspace must be present before a vImageCVImageFormatRef can be used to do a conversion.
 *  @param format       The vImageCVImageFormatRef for which the colorspace is to be set.
 *  @param colorspace   The new colorspace.  May be NULL, indicating missing colorspace information.
 *  @return  On Success, kvImageNoError. An error will be returned if the colorspace model doesn't match what is expected
 *           for the image format type. For example, a 'RGBA' image must be kCGColorSpaceModelRGB.  Y'CbCr images expect a
 *           RGB colorspace. The new colorspace will be retained and he old one will be released.
 *
 *           On failure, nothing occurs.
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_SetColorSpace(format: vImageCVImageFormat, _ colorspace: CGColorSpace!) -> vImage_Error

/*!
 *  @function vImageCVImageFormat_GetChromaSiting
 *  @abstract Get the chroma-siting for the image.
 *  @discussion When Y'CbCr images have subsampled chroma, the position of the chroma samples relative to the luminance samples needs to be
 *              specified. Chroma siting information is only needed for Y'CbCr images that are not 444.
 *  @param format       The vImageCVImageFormatRef for which the chroma siting information is desired.
 *  @return  Returns a CFStringRef that describes the positioning of the chroma samples. Eligible string return values are listed 
 *           in CoreVideo/CVImageBuffer.h.   The result is NULL if the chroma siting information is missing.
 *  @seealso kCVImageBufferChromaLocationTopFieldKey
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetChromaSiting(format: vImageConstCVImageFormat) -> Unmanaged<CFString>!

/*!
 *  @function vImageCVImageFormat_SetChromaSiting
 *  @abstract Set the chroma-siting for the image.
 *  @discussion When Y'CbCr images have subsampled chroma, the position of the chroma samples relative to the luminance samples needs to be
 *              specified. Chroma siting information is only needed for Y'CbCr images that are not 444. The new siting name will be retained.
 *              The old siting will be released. This function has no effect for image format types that do not require siting information.
 *  @param format       The vImageCVImageFormatRef for which the chroma siting information is desired.
 *  @param siting       The new siting information for the format. May be NULL.
 *  @return  
 *      <pre>
 *      @textblock
 *          kvImageNoError                  Success
 *
 *          kvImageInvalidImageFormat       format is NULL
 *          
 *          kvImageInvalidParameter         siting is not a recognized CFStringRef from the set of values appearing in CoreVideo/CVImageBuffer.h.
 *      @/textblock
 *      </pre>
 *  @seealso kCVImageBufferChromaLocationTopFieldKey
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_SetChromaSiting(format: vImageCVImageFormat, _ siting: CFString!) -> vImage_Error

/*!
 *  @function vImageCVImageFormat_GetConversionMatrix
 *  @abstract Get the RGB -> Y'CbCr conversion matrix for the image.
 *  @discussion  Y'CbCr images are defined in terms of a RGB image and a conversion matrix from that RGB format to Y'CbCr. 
 *               The conversion frequently has the form:
 *
 *          <pre>
 *          @textblock
 *              Y' =  R_Yp * R  + G_Yp * G + B_Yp * B       Y' = [0, 1.0]
 *              Cb = k0 * (B - Y')                          Cb = [-0.5, 0.5]
 *              Cr = k1 * (R - Y')                          Cr = [-0.5, 0.5]
 *          @/textblock
 *          </pre>
 *
 *      That can be reformulated as a 3x3 matrix operation. The element names here correspond to the fields in the vImage_ARGBToYpCbCrMatrix type:
 *
 *          <pre>
 *          @textblock
 *              | Y' |   | R_Yp        G_Yp     B_Yp      |   | R |
 *              | Cb | = | R_Cb        G_Cb     B_Cb_R_Cr | * | G |
 *              | Cr |   | B_Cb_R_Cr   G_Cr     B_Cr      |   | B |
 *          @/textblock
 *          </pre>
 *
 *      Most Y'CbCr conversion matrices are of this form. However, some conversion matrices, such as that proposed to ITU-R BT.2020 for 
 *      constant luminance, are more complicated.
 *
 *      It is possible for the matrix to be absent. Y'CbCr image types may not be converted without a conversion matrix.
 *
 *  @param format       The vImageCVImageFormatRef for which the matrix is desired
 *  @param outType      A pointer to a variable of type vImageMatrixType.
 *  @return  A pointer to a matrix will be returned from the left hand side of the function. The memory pointed to by outType will be
 *              overwritten with the type of the matrix returned.  The returned matrix may be NULL, indicating an absent matrix.
 *
 *          The matrix is owned by the vImageCvImageFormatRef and will cease to be valid when the vImageCvImageFormatRef is destroyed.
 *
 *  @seealso vImage_ARGBToYpCbCrMatrix and vImageMatrixType
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetConversionMatrix(format: vImageConstCVImageFormat, _ outType: UnsafeMutablePointer<vImageMatrixType>) -> UnsafePointer<Void>

/*!
 *  @function vImageCVImageFormat_CopyConversionMatrix
 *  @abstract Set the RGB -> Y'CbCr conversion matrix for the image.
 *  @discussion  matrix is copied to the vImageCVImageFormatRef's internal matrix storage.
 *
 *  Y'CbCr images are defined in terms of a RGB image and a conversion matrix from that RGB format to Y'CbCr.
 *               The conversion frequently has the form:
 *
 *          <pre>
 *          @textblock
 *              Y' =  R_Yp * R  + G_Yp * G + B_Yp * B       Y' = [0, 1.0]
 *              Cb = k0 * (B - Y')                          Cb = [-0.5, 0.5]
 *              Cr = k1 * (R - Y')                          Cr = [-0.5, 0.5]
 *          @/textblock
 *          </pre>
 *
 *      That can be reformulated as a 3x3 matrix operation. The element names here correspond to the fields in the vImage_ARGBToYpCbCrMatrix type:
 *
 *          <pre>
 *          @textblock
 *              | Y' |   | R_Yp        G_Yp     B_Yp      |   | R |
 *              | Cb | = | R_Cb        G_Cb     B_Cb_R_Cr | * | G |
 *              | Cr |   | B_Cb_R_Cr   G_Cr     B_Cr      |   | B |
 *          @/textblock
 *          </pre>
 *
 *      Most Y'CbCr conversion matrices are of this form. However, some conversion matrices, such as that proposed to ITU-R BT.2020 for
 *      constant luminance, are more complicated.
 *
 *      It is possible for the matrix to be absent. Y'CbCr image types may not be converted without a conversion matrix.
 *
 *  @param format       The vImageCVImageFormatRef for which the matrix is desired
 *  @param matrix       The matrix data to be copied to the vImageCVImageFormatRef. If the matrix is a constant predefined by vImage, 
 *                      the address shall be preserved, and returned unmodified by vImageCVImageFormat_GetConversionMatrix.
 *                      The matrix must have a matrix inverse.
 *  @param inType       The type of the matrix. The only type defined for OS X.10 and iOS 8.0 is kvImageMatrixType_ARGBToYpCbCrMatrix, which is a vImage_ARGBToYpCbCrMatrix.
 *
 *  @return  
 *          <pre>
 *          @textblock
 *           kvImageNoError             Success.
 *
 *           kvImageInvalidParameter    The matrix type did not match that required for the image format.
 *
 *           kvImageInvalidParameter    The matrix is not invertible. (See console for log in this case.)
 *          @/textblock
 *          </pre>
 *
 *  @seealso vImage_ARGBToYpCbCrMatrix 
 *  @seealso vImageMatrixType
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_CopyConversionMatrix(format: vImageCVImageFormat, _ matrix: UnsafePointer<Void>, _ inType: vImageMatrixType) -> vImage_Error

/*!
 *  @function vImageCVImageFormat_GetAlphaHint
 *  @abstract Get the alpha-is-one hint from a vImageCVImageFormatRef
 *  @discussion  Some image formats have an alpha channel. Sometimes, the alpha channel for the entire image is known to be 1.0 (fully opaque).
 *               In some circumstances, that knowledge can be used to eliminate work from a conversion to make it faster, especially when converting
 *               to a format without an alpha channel.  If the alpha-is-one hint is non-zero, it indicates that the alpha channel is fully opaque. 
 *
 *               Images that do not have an alpha channel will also return non-zero.
 *
 *               There are a few image formats that have room for an alpha channel (kCVPixelFormatType_16BE555, kCVPixelFormatType_16LE555, 
 *               kCVPixelFormatType_30RGB) but which do not have an alpha channel. Setting the alpha-is-one hint to 0 does not add an alpha
 *               channel to these image types. 
 *
 *               The alpha-is-one hint is a hint.  It can not be absent in a way that will prevent conversion. If it is not set or is zero, and 
 *               the image format has alpha, then the alpha channel will be included in the calculation. If the result format has alpha, the alpha
 *               will propagate there. If the result format does not have alpha, the image will be flattened against the indicated background color
 *               for the conversion.
 *
 *  @param format       The vImageCVImageFormatRef for which the colorspace is to be set.
 *  @return  0  Alpha is not known to be opaque, or the hint has not been set.
 *
 *           non-zero  Alpha is known to be fully opaque, even if the values encoded for alpha in the image are not 1.0.
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetAlphaHint(format: vImageConstCVImageFormat) -> Int32

/*!
 *  @function vImageCVImageFormat_SetAlphaHint
 *  @abstract Set the alpha-is-one hint for a vImageCVImageFormatRef
 *  @discussion  Some image formats have an alpha channel. Sometimes, the alpha channel for the entire image is known to be 1.0 (fully opaque).
 *               In some circumstances, that knowledge can be used to eliminate work from a conversion to make it faster, especially when converting
 *               to a format without an alpha channel.  If the alpha-is-one hint is non-zero, it indicates that the alpha channel is fully opaque.
 *
 *               The alpha-is-one hint is a hint.  It can not be absent in a way that will prevent conversion. If it is not set or is zero, and
 *               the image format has alpha, then the alpha channel will be included in the calculation. If the result format has alpha, the alpha
 *               will propagate there. If the result format does not have alpha, the image will be flattened against the indicated background color
 *               for the conversion.
 *
 *               There are a few image formats that have room for a small alpha channel (kCVPixelFormatType_16BE555, kCVPixelFormatType_16LE555,
 *               kCVPixelFormatType_30RGB) but which do not have an alpha channel. Setting the alpha-is-one hint to 0 does not add an alpha
 *               channel to these image types.  If this behavior is desired, such image formats can generally be described using a vImage_CGImageFormat.
 *               If so, you can set the vImage_CGImageFormat.bitmap info to an appropriate CGImageAlphaInfo for the desired treatment for the alpha
 *               channel and convert using vImageConverter_CreateWithCGImageFormat() + vImageConvert_AnyToAny().
 *
 *  @param format       The vImageCVImageFormatRef for which the colorspace is to be set.
 *  @parma alphaIsOne   The new value for the alpha-is-one hint.
 *  @return  kvImageNoError             Success.
 *
 *           kvImageInvalidParameter    format is NULL
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_SetAlphaHint(format: vImageCVImageFormat, _ alphaIsOne: Int32) -> vImage_Error

/*!
 *  @function vImageCVImageFormat_GetChannelDescription
 *  @abstract Get the channel description for a particular channel type
 *  @discussion  The channel description gives information about the range of values and clamping for a image color channel.
 *
 *  @param format       The vImageCVImageFormatRef that the channel description is for.
 *  @parma type         The type of the channel that you wish information about. Example: kvImageBufferTypeCode_Luminance
 *  @return  A const pointer to a vImageChannelDescription struct. The data in the structure may not be modified and belongs to the vImageCVImageFormatRef.
 *           It is destroyed when the vImageCVImageFormatRef is destroyed.
 *  @seealso vImageChannelDescription
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetChannelDescription(format: vImageConstCVImageFormat, _ type: vImageBufferTypeCode) -> UnsafePointer<vImageChannelDescription>

/*!
 *  @function vImageCVImageFormat_CopyChannelDescription
 *  @abstract Set the channel description for a particular channel type
 *  @discussion  The channel description gives information about the range of values and clamping for a image color channel.
 *
 *  @param format       The vImageCVImageFormatRef that the channel description is for.
 *  @param desc         A pointer to a new vImageChannelDescription to use for the channel type.  The data is copied into the vImageCVImageFormatRef.
 *  @param type         The type of the channel that you wish to set information about. Example: kvImageBufferTypeCode_Luminance
 *  @return  kvImageNoError     Success
 *
 *           kvImageInvalidParameter    An invalid vImageBufferTypeCode, either out of range, or the channel type does not appear in the image format
 *  @seealso vImageChannelDescription
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_CopyChannelDescription(format: vImageCVImageFormat, _ desc: UnsafePointer<vImageChannelDescription>, _ type: vImageBufferTypeCode) -> vImage_Error

/*!
 *  @function vImageCVImageFormat_GetUserData
 *  @abstract Get the user info pointer attached to the image format
 *  @discussion  There may be extra information that you wish to attach to a vImageCVImageFormatRef.  It might be a pthread_rwlock_t to help prevent
 *               concurrent access to the vImageCVImageFormatRef while it is being modified, or perhaps additional metadata about the image format 
 *               that you may need later. It may even just a pointer to an object you wrote which wraps the vImageCVImageFormatRef. 
 *
 *               The user data pointer is available for you to use to store a reference to this information. The token is opaque to vImage. vImage
 *               only returns it when asked via vImageCVImageFormat_GetUserData.  It can be set with vImageCVImageFormat_SetUserData.
 *
 *  @param format       The vImageCVImageFormatRef to get the userData from.
 *  @return  The address of the userData. It will be NULL if no userData has been set.
 *  @seealso vImageCVImageFormat_SetUserData
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_GetUserData(format: vImageConstCVImageFormat) -> UnsafeMutablePointer<Void>

/*!
 *  @function vImageCVImageFormat_SetUserData
 *  @abstract  Sets the userData pointer and a userDataReleaseCallback function
 *  @seealso vImageCVImageFormat_SetUserData
 *  @discussion  The userDataReleaseCallback is called when the vImageCVImageFormatRef is destroyed. You may access the vImageCVImageFormatRef
 *               during the callback function. However vImageCVImageFormat_Retain() will not prevent the destruction of the object in that context.
 *               The userDataReleaseCallback will also be called on the previous user data in the event that vImageCVImageFormat_SetUserData
 *               is called to replace one set of user date with another. 
 *
 *              CAUTION: vImage does not attempt to do anything smart when the old and new userData are actually the same or differ only by callback.
 *
 *              vImage does not attempt to free the user data when the vImageCVImageFormatRef is destroyed. If the userData needs to
 *              be freed/released/etc. at this time, then you should do so in your userDataReleaseCallback.
 *
 *              vImageCVImageFormat_SetUserData function is not atomic. vImageCVImageFormat_SetUserData is not safe to call reentrantly.
 *
 *              Since there can be only one userData attached to a vImageCVImageFormatRef, the userData field is reserved by convention
 *              for exclusive use by the app/framework/library that created the vImageCVImageFormatRef.  If you need to attach your own
 *              userData to a vImageCVImageFormatRef that you did not create, make a copy of it with vImageCVImageFormat_Copy.  The new 
 *              copy will not have userData attached to it.
 *
 *  @param format       The vImageCVImageFormatRef to get the userData from.
 *  @param userdata     The new userData pointer.
 *  @return  kvImageNoError - Success
 *
 *           kvImageInvalidImageFormat  -format is NULL
 *  @param     userDataReleaseCallback   The callback that is called when the vImageCVImageFormatRef is destroyed, or when the userData is replaced with
 *                                      another one.
 *  @param     callback_fmt The vImageCVImageFormatRef that the userData is attached to.
 *  @param     callback_userData    The userData field attached to callback_fmt.
 *
 */
@available(OSX 10.10, *)
func vImageCVImageFormat_SetUserData(format: vImageCVImageFormat, _ userData: UnsafeMutablePointer<Void>, _ userDataReleaseCallback: (@convention(c) (vImageCVImageFormat!, UnsafeMutablePointer<Void>) -> Void)!) -> vImage_Error

/*! @functiongroup  Low level colorspace initialization */
struct vImageTransferFunction {
  var c0: CGFloat
  var c1: CGFloat
  var c2: CGFloat
  var c3: CGFloat
  var gamma: CGFloat
  var cutoff: CGFloat
  var c4: CGFloat
  var c5: CGFloat
  init()
  init(c0: CGFloat, c1: CGFloat, c2: CGFloat, c3: CGFloat, gamma: CGFloat, cutoff: CGFloat, c4: CGFloat, c5: CGFloat)
}
struct vImageRGBPrimaries {
  var red_x: Float
  var green_x: Float
  var blue_x: Float
  var white_x: Float
  var red_y: Float
  var green_y: Float
  var blue_y: Float
  var white_y: Float
  init()
  init(red_x: Float, green_x: Float, blue_x: Float, white_x: Float, red_y: Float, green_y: Float, blue_y: Float, white_y: Float)
}

/*!
 * @function vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction
 *
 * @abstract Create a RGB colorspace based on primitives typically found in Y'CbCr specifications
 *
 * @discussion This function may be used to create a CGColorSpaceRef to correspond with a given set of color
 * primaries and transfer function. This defines a RGB colorspace. (A Y'CbCr colorspace is defined as a RGB
 * colorspace and a conversion matrix from RGB to Y'CbCr.) The color primaries give the extent of a colorspace
 * in x,y,z space and the transfer function gives the transformation from linear color to non-linear color that
 * the pixels actually reside in.
 *
 *   <pre>
 *   @textblock
 *      Example:  ITU-R BT.709-5
 *
 *          const vImageTransferFunction f709 =
 *          {  // 1.2 transfer function
 *              .c0 = 1.099,
 *              .c1 = 1.0,
 *              .c2 = 0.0,
 *              .c3 = -0.099,
 *              .gamma = 0.45,
 *              .cutoff = 0.018,
 *              .c4 = 4.5,
 *              .c5 = 0
 *          };
 *
 *          const vImageRGBPrimaries p709 =
 *          {
 *              .red_x = .64,               // 1.3 red
 *              .green_x = .30,             // 1.3 green
 *              .blue_x = .15,              // 1.3 blue
 *              .white_x = 0.3127,          // 1.4 white
 *
 *              .red_y = .33,               // 1.3 red
 *              .green_y = .60,             // 1.3 green
 *              .blue_y = .06,              // 1.3 blue
 *              .white_y = 0.3290           // 1.4 white
 *          };
 *
 *          vImage_Error err = kvImageNoError;
 *          CGColorSpaceRef colorSpace = vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction( &p709, &f709, kvImageNoFlags, &err );
 *          @/textblock
 *          </pre>
 *
 *  Other methods to create a RGB colorspace:
 *
 *      You may find it easier to use CVImageBufferCreateColorSpaceFromAttachments or CVImageBufferGetColorSpace, in some cases.
 *      If there is enough color information attached to a CVPixelBuffer, you can also get one using vImageCVImageFormat_CreateWithCVPixelBuffer().
 *      There are also many ways to create a RGB CGColorSpace in CoreGraphics/CGColorSpace.h.
 *
 *   <pre>
 *   @textblock
 *      Note: This low level function does not conform to CoreVideo practice of automatically substituting gamma 1/1.961
 *      for kCVImageBufferTransferFunction_ITU_R_709_2 and kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using
 *      the ITU-R BT.709-5 specified transfer function. (vImageBuffer_InitWithCVPixelBuffer and vImageBuffer_CopyToCVPixelBuffer
 *      do.) If you would like that behavior, you can use the following transfer function:
 *
 *      const vImageTransferFunction f709_Apple =
 *      {
 *          .c0 = 1.0,
 *          .c1 = 1.0,
 *          .c2 = 0.0,
 *          .c3 = 0,
 *          .gamma = 1.0/1.961,
 *          .cutoff = -INFINITY,
 *          .c4 = 1,
 *          .c5 = 0
 *      };
 *    @/textblock
 *    </pre>
 *
 *
 *  @param  primaries   A set of x, y tristimulus values to defined the color primaries for the RGB colorspace. Here:
 *
 *          <pre>
 *          @textblock
 *                          x = X/(X+Y+Z),  y = Y/(X+Y+Z)
 *          @/textblock
 *          </pre>
 *
 *                      where X, Y, and Z are from CIEXYZ. z is derived automatically from x and y.
 *  
 *  @param  tf          The transfer function to convert from linear RGB (using above primaries) to non-linear RGB.
 *                      The transfer function here is defined in the style of ITU-R BT.709 and is the inverse
 *                      operation of what appears in a ICC color profile.
 *
 *  @param  flags       Currently the only flag recognized here is  kvImagePrintDiagnosticsToConsole, which may be used to
 *                      debug the colorspace creation when it fails. 
 *
 *  @param  error       May be NULL. If not NULL, a vImage_Error code is written to the memory pointed to by error to
 *                      indicate success or failure of the operation.
 *
 *
 *  @result On success, a non-NULL RGB CGColorSpaceRef will be returned.  The color space has a reference count of 1.
 *          You are responsible for releasing the colorspace when you are done with it to return the memory back
 *          to the system. If error is not NULL, kvImageNoError is written to *error.
 *
 *          On failure, NULL will be returned and one of the following errors is written to *error if error is non-NULL:
 *
 *          <pre>
 *          @textblock
 *          Errors:
 *
 *              kvImageInvalidParameter         tf->gamma = 0       (transfer function is not round-trippable)
 *              kvImageInvalidParameter         primaries define XYZ <-> RGB matrix which is not invertible
 *          @/textblock
 *          </pre>
 *
 *
 */
@available(OSX 10.10, *)
func vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction(primaries: UnsafePointer<vImageRGBPrimaries>, _ tf: UnsafePointer<vImageTransferFunction>, _ intent: CGColorRenderingIntent, _ flags: vImage_Flags, _ error: UnsafeMutablePointer<vImage_Error>) -> Unmanaged<CGColorSpace>!
struct vImageWhitePoint {
  var white_x: Float
  var white_y: Float
  init()
  init(white_x: Float, white_y: Float)
}
@available(OSX 10.10, *)
func vImageCreateMonochromeColorSpaceWithWhitePointAndTransferFunction(whitePoint: UnsafePointer<vImageWhitePoint>, _ tf: UnsafePointer<vImageTransferFunction>, _ intent: CGColorRenderingIntent, _ flags: vImage_Flags, _ error: UnsafeMutablePointer<vImage_Error>) -> Unmanaged<CGColorSpace>!

/*!
 *  @function vImageConverter_CreateForCGToCVImageFormat
 *
 *  @abstract Create a vImageConverterRef that converts a CoreGraphics formatted image to CoreVideo formatted image
 *
 *  @discussion  This creates a vImageConverterRef which may be used with vImageConvert_AnyToAny to convert a
 *              CoreGraphics formatted image, as described by a vImage_CGImageFormat to CV image data, the format of 
 *              which is given by a vImageCVImageFormatRef.
 *
 *
 *  @param  srcFormat       The vImage_CGImageFormat that describes the pixel format associated with the source image buffers.
 *
 *  @param  destFormat      The vImageCVImageFormatRef that describes the pixel format associated with the destination buffers.
 *
 *  @param  backgroundColor In cases where the source format has an alpha channel and the destination does not (or is kCGImageAlphaNoneSkipFirst/Last)
 *                               the conversion will remove the alpha channel by flattening it against an opaque background color. The background color
 *                               is given as CGFloat[3] {red, green, blue} (sRGB).
 *
 *  @param  flags           The following flags are honored:
 *
 *          <pre>
 *          @textblock
 *              kvImagePrintDiagnosticsToConsole    cause extra information to be sent to Apple System Logger (Console) in case of failure
 *
 *              kvImageHighQualityResampling        In some cases, chroma may have to be up or downsampled as part of the conversion
 *                                                  When this flag bit is set, it instructs the converter to spend extra time to achieve better
 *                                                  image quality.
 *
 *              kvImageDoNotTile                    Disable multithreading in the conversion step when this converter is used with vImageConvert_AnyToAny.
 *          @/textblock
 *          </pre>
 *
 *
 *  @param  error           An optional pointer to a vImage_Error in which the returned error code is written.  
 *                          Error be NULL, in which case no error value will be written.
 *          
 *
 *  @result On success, a non-NULL vImageConverteRef will be returned, suitable for use with vImageConvert_AnyToAny(). If
 *          error is non-NULL, kvImageNoError will be written to *error, indicating success. You must release the 
 *          vImageConverterRef when you are done with it, to return its resources to the system.  It has a reference count of 1.
 *
 *          On failure, a NULL vImageConverteRef will be returned. If error is non-NULL, an error code will be written to 
 *          *error.  Some possible error values:
 *          
 *          <pre>
 *          @textblock
 *          kvImageNoError                      Success. No error occurred. A non-NULL vImageConverterRef will be returned.
 *
 *          kvImageInternalError                Your usage was likely correct, but something appears to be very wrong inside
 *                                              vImage. Please file a bug, with a reproducible example of this failure. Please
 *                                              also try the kvImagePrintDiagnosticsToConsole flag for more information.
 *
 *          kvImageInvalidImageFormat           The vImage_CGImageFormat is invalid. kvImagePrintDiagnosticsToConsole may provide
 *                                              more information.
 *
 *          kvImageInvalidCVImageFormat         The vImageCVImageFormatRef is invalid. Probably, the vImageCVImageFormatRef is
 *                                              incomplete. This can happen when a vImageCVImageFormatRef is created from a 
 *                                              CVPixelBufferRef and that itself has incomplete conversion information. Please 
 *                                              see "vImageCVImageFormatRef Repair" above. kvImagePrintDiagnosticsToConsole
 *                                              may provide more information.
 *
 *          kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the vImageCVImageFormatRef. Please add one.
 *          kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the vImageCVImageFormatRef. Please add.
 *          kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the vImageCVImageFormatRef.
 *          @/textblock
 *          </pre>
 *
 *  @seealso    vImageBuffer_InitForCopyToCVPixelBuffer When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains multiple data planes which are in turn represented by multiple vImage_Buffers.
 *  @seealso    vImageConverter_GetDestinationBufferOrder for manual ordering information
 */
@available(OSX 10.10, *)
func vImageConverter_CreateForCGToCVImageFormat(srcFormat: UnsafePointer<vImage_CGImageFormat>, _ destFormat: vImageCVImageFormat, _ backgroundColor: UnsafePointer<CGFloat>, _ flags: vImage_Flags, _ error: UnsafeMutablePointer<vImage_Error>) -> Unmanaged<vImageConverter>!

/*!
 *  @function vImageConverter_CreateForCVToCGImageFormat
 *
 *  @abstract Create a vImageConverterRef that converts a CoreVideo formatted image to a CoreGraphics formatted image
 *
 *  @discussion  This creates a vImageConverterRef which may be used with vImageConvert_AnyToAny to do conversions of
 *              CV image data, as described by a vImageCVImageFormatRef to CoreGraphics formatted image data, as 
 *              described by a vImage_CGImageFormat.
 *
 *
 *  @param  srcFormat       The vImageCVImageFormatRef that describes the pixel format associated with the source image buffers.
 *
 *  @param  destFormat      The vImage_CGImageFormat that describes the pixel format associated with the destination buffers.
 *
 *  @param  backgroundColor In cases where the source format has an alpha channel and the destination does not (or is kCGImageAlphaNoneSkipFirst/Last)
 *                               the conversion will remove the alpha channel by flattening it against an opaque background color. The background color
 *                               is given as CGFloat[3] {red, green, blue} (sRGB).
 *
 *  @param  flags           The following flags are honored:
 *
 *          <pre>
 *          @textblock
 *              kvImagePrintDiagnosticsToConsole    cause extra information to be sent to Apple System Logger (Console) in case of failure
 *
 *              kvImageHighQualityResampling        In some cases, chroma may have to be up or downsampled as part of the conversion
 *                                                  When this flag bit is set, it instructs the converter to spend extra time to achieve better
 *                                                  image quality.
 *
 *              kvImageDoNotTile                    Disable multithreading in the conversion step when this converter is used with vImageConvert_AnyToAny.
 *          @/textblock
 *          </pre>
 *
 *
 *  @param  error           An optional pointer to a vImage_Error in which the returned error code is written.
 *                          Error be NULL, in which case no error value will be written.
 *
 *
 *  @result On success, a non-NULL vImageConverteRef will be returned, suitable for use with vImageConvert_AnyToAny(). If
 *          error is non-NULL, kvImageNoError will be written to *error, indicating success. You must release the
 *          vImageConverterRef when you are done with it, to return its resources to the system.  It has a reference count of 1.
 *
 *          On failure, a NULL vImageConverteRef will be returned. If error is non-NULL, an error code will be written to
 *          *error.  Some possible error values:
 *
 *          <pre>
 *          @textblock
 *          kvImageNoError                      Success. No error occurred. A non-NULL vImageConverterRef will be returned.
 *
 *          kvImageInternalError                Your usage was likely correct, but something appears to be very wrong inside
 *                                              vImage. Please file a bug, with a reproducible example of this failure. Please
 *                                              also try the kvImagePrintDiagnosticsToConsole flag for more information.
 *
 *          kvImageInvalidImageFormat           The vImage_CGImageFormat is invalid. kvImagePrintDiagnosticsToConsole may provide
 *                                              more information.
 *
 *          kvImageInvalidCVImageFormat         The vImageCVImageFormatRef is invalid. Probably, the vImageCVImageFormatRef is
 *                                              incomplete. This can happen when a vImageCVImageFormatRef is created from a
 *                                              CVPixelBufferRef and that itself has incomplete conversion information. Please
 *                                              see "vImageCVImageFormatRef Repair" above. kvImagePrintDiagnosticsToConsole
 *                                              may provide more information.
 *
 *          kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the vImageCVImageFormatRef. Please add one.
 *          kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the vImageCVImageFormatRef. Please add.
 *          kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the vImageCVImageFormatRef.
 *          @/textblock
 *          </pre>
 *
 *  @seealso    vImageBuffer_InitForCopyFromCVPixelBuffer When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains multiple data planes which are in turn represented by multiple vImage_Buffers.
 *  @seealso    vImageConverter_GetSourceBufferOrder for manual ordering information
 */
@available(OSX 10.10, *)
func vImageConverter_CreateForCVToCGImageFormat(srcFormat: vImageCVImageFormat, _ destFormat: UnsafePointer<vImage_CGImageFormat>, _ backgroundColor: UnsafePointer<CGFloat>, _ flags: vImage_Flags, _ error: UnsafeMutablePointer<vImage_Error>) -> Unmanaged<vImageConverter>!

/*!
 * @function vImageBuffer_InitForCopyToCVPixelBuffer
 *
 * @abstract Initialize an array of vImage_Buffers in the right order to convert a image to a CV formatted image
 *
 * @discussion When converting to CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains 
 * multiple data planes which are in turn represented by multiple vImage_Buffers. (These are passed in as an array 
 * of vImage_Buffers to vImageConvert_AnyToAny().)  To make it easier to order the buffers correctly, we provide
 * vImageBuffer_InitForCopyToCVPixelBuffer, which initializes an array vImage_Buffer structs  in the order expected by
 * vImageConvert_AnyToAny. With appropriate flags, the conversion can be made to occur directly into the CVPixelBufferRef 
 * backing store.
 *
 * You are responsible for updating any missing / incorrect color information in the pixelBuffer after writing to it.
 *
 * @param buffers   A pointer to an array of vImage_Buffer structs to be overwritten. The buffers will be initialized 
 *                  in the correct order for use with vImageConvert_AnyToAny and the provided converter. On entry, 
 *                  buffers must point to a valid region of memory of size no smaller than number_of_buffers * 
 *                  sizeof(vImage_Buffer). The number_of_buffers is given by vImageConverter_GetNumberOfDestinationBuffers.
 *                  The buffers pointer may not be NULL.
 *
 * @param converter The converter that will be used to do the conversion.  May not be NULL.
 *
 * @param pixelBuffer   A locked (use CVPixelBufferLockBaseAddress) CVPixelBufferRef.
 *
 * @param  flags    kvImageNoAllocate must be used.  The following flags are allowed:
 *
 *          <pre>
 *          @textblock
 *              kvImageNoFlags                      Default operation.
 *
 *              kvImagePrintDiagnosticsToConsole    Print diagnostic messages to the console in the event an error occurs
 *
 *              kvImageNoAllocate                   Instructs the function to initialized the buffers to directly write to a
 *                                                  locked CVPixelBufferRef. You  may unlock the CVPixelBufferRef after 
 *                                                  vImageConvert_AnyToAny has returned. Once the pixelBuffer is unlocked, 
 *                                                  the vImage_Buffers initialized by this function are no longer valid and 
 *                                                  must be reinitialized.
 *
 *          @/textblock
 *          </pre>
 *
 * @return  The following error codes may be returned:
 *
 *          <pre>
 *          @textblock
 *      kvImageNoError                  Success
 *
 *      kvImageNullPointerArgument      buffers is NULL.
 *      kvImageNullPointerArgument      converter is NULL.
 *
 *      kvImageInvalidParameter         pixelBuffer is not NULL but kvImageNoAllocate was not passed in flags. See pixelBuffer description above.
 *
 *      kvImageUnknownFlagsBit          An unknown / unhandled flags bit was set in flags.
 *
 *      kvImageInternalError            Something is very wrong inside vImage. This shouldn't happen. Please file a bug, along with a 
 *                                      reproducible failure case.
 *          @/textblock
 *          </pre>
 *
 * @seealso ImageConverter_GetDestinationBufferOrder for another method to initialize the vImage_Buffers in the right order for vImageConvert_AnyToAny.
 *
 */
@available(OSX 10.10, *)
func vImageBuffer_InitForCopyToCVPixelBuffer(buffers: UnsafeMutablePointer<vImage_Buffer>, _ converter: vImageConverter, _ pixelBuffer: CVPixelBuffer, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageBuffer_InitForCopyFromCVPixelBuffer
 *
 * @abstract Initialize an array of vImage_Buffers in the right order to convert CV formatted image to another image format
 *
 * @discussion When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains
 * multiple data planes which are in turn represented by multiple vImage_Buffers. (These are passed in as an array
 * of vImage_Buffers to vImageConvert_AnyToAny().)  To make it easier to order the buffers correctly, we provide
 * vImageBuffer_InitForCopyFromCVPixelBuffer, which initializes an array vImage_Buffer structs  in the order expected by
 * vImageConvert_AnyToAny. With appropriate flags, the conversion can be made to occur directly from the CVPixelBufferRef
 * backing store.
 *
 * @param buffers   A pointer to an array of vImage_Buffer structs to be read. The buffers will be initialized
 *                  in the correct order for use with vImageConvert_AnyToAny and the provided converter. On entry,
 *                  buffers must point to a valid region of memory of size no smaller than number_of_buffers *
 *                  sizeof(vImage_Buffer). The number_of_buffers is given by vImageConverter_GetNumberOfSourceBuffers.
 *                  The buffers pointer may not be NULL.
 *
 * @param converter The converter that will be used to do the conversion.  May not be NULL.
 *
 * @param pixelBuffer   A locked (use CVPixelBufferLockBaseAddress) CVPixelBufferRef.
 *
 * @param  flags    kvImageNoAllocate must be used. The following flags are allowed:
 *
 *          <pre>
 *          @textblock
 *              kvImageNoFlags                      Default operation.
 *
 *              kvImagePrintDiagnosticsToConsole    Print diagnostic messages to the console in the event an error occurs
 *
 *              kvImageNoAllocate                   Instructs the function to initialized the buffers to directly read from a
 *                                                  locked CVPixelBufferRef. You  may unlock the CVPixelBufferRef after
 *                                                  vImageConvert_AnyToAny has returned. Once the pixelBuffer is unlocked,
 *                                                  the vImage_Buffers initialized by this function are no longer valid and
 *                                                  must be reinitialized.
 *
 *          @/textblock
 *          </pre>
 *
 * @return  The following error codes may be returned:
 *
 *          <pre>
 *          @textblock
 *      kvImageNoError                  Success
 *
 *      kvImageNullPointerArgument      buffers is NULL.
 *      kvImageNullPointerArgument      converter is NULL.
 *
 *      kvImageInvalidParameter         pixelBuffer is not NULL but kvImageNoAllocate was not passed in flags. See pixelBuffer description above.
 *
 *      kvImageUnknownFlagsBit          An unknown / unhandled flags bit was set in flags.
 *
 *      kvImageInternalError            Something is very wrong inside vImage. This shouldn't happen. Please file a bug, along with a
 *                                      reproducible failure case.
 *          @/textblock
 *          </pre>
 *
 * @seealso  vImageConverter_GetSourceBufferOrder vImageConverter_GetSourceBufferOrder for another method to initialize the vImage_Buffers in the right order for vImageConvert_AnyToAny.
 *
 */
@available(OSX 10.10, *)
func vImageBuffer_InitForCopyFromCVPixelBuffer(buffers: UnsafeMutablePointer<vImage_Buffer>, _ converter: vImageConverter, _ pixelBuffer: CVPixelBuffer, _ flags: vImage_Flags) -> vImage_Error

/*!
    @typedef vImagePixelCount
    @discussion A number of pixels.  Typically, this is the height or width of an image.
 */
typealias vImagePixelCount = UInt

/*!
    @typedef vImage_Buffer
    @field  data        A pointer to the top left corner of the buffer contain image pixels.
    @field  height      The number of pixels in a column of the image. 
    @field  width       The number of visible pixels in a row of an image (excluding padding at the ends of rows)
    @field  rowBytes    The number of bytes from a pixel to the next pixel down in the same column.
    @discussion The vImage_Buffer describes a rectangular region within a regular array of pixels. It may describe
                the entire image, or just a sub rectangle of it.  The vImage_Buffer struct is not a complete description
                of an image. Other aspects like pixel format, color space, channel ordering, etc. are generally given
                by the names of functions that operate on the vImage_Buffer or by parameters passed to those functions.
                A vImage_Buffer may contain multiple color channels interleaved with one another, or a single color channel
                (or alpha) as a planar buffer.  vImage_Buffers are often initialized directly by you, by setting fields
                to appropriate values to point to image data you already own. Convenience methods are also available as
                vImageBuffer_Init, vImageBuffer_InitWithCGImage and vImageBuffer_InitWithCVPixelBuffer
 */
struct vImage_Buffer {
  var data: UnsafeMutablePointer<Void>
  var height: vImagePixelCount
  var width: vImagePixelCount
  var rowBytes: Int
  init()
  init(data: UnsafeMutablePointer<Void>, height: vImagePixelCount, width: vImagePixelCount, rowBytes: Int)
}

/*!
    @typedef vImage_AffineTransform
    @field  a        top left cell in 3x2 transform matrix
    @field  b        top right cell in 3x2 transform matrix
    @field  c        middle left cell in 3x2 transform matrix
    @field  d        middle right cell in 3x2 transform matrix
    @field  tx       The x coordinate translation
    @field  ty       The y coordinate translation
    @discussion      This 3x2 matrix generally operates the same as the CGAffineTransform, except that the fields
                     are all float, not CGFloat. If you are looking for CGAffineTransform compatibility, it is 
                     recommended that you use vImage_CGAffineTransform and associated APIs instead.
 */
struct vImage_AffineTransform {
  var a: Float
  var b: Float
  var c: Float
  var d: Float
  var tx: Float
  var ty: Float
  init()
  init(a: Float, b: Float, c: Float, d: Float, tx: Float, ty: Float)
}
var VIMAGE_AFFINETRANSFORM_DOUBLE_IS_AVAILABLE: Int32 { get }
struct vImage_AffineTransform_Double {
  var a: Double
  var b: Double
  var c: Double
  var d: Double
  var tx: Double
  var ty: Double
  init()
  init(a: Double, b: Double, c: Double, d: Double, tx: Double, ty: Double)
}
var VIMAGE_CGAFFINETRANSFORM_IS_AVAILABLE: Int32 { get }
typealias vImage_CGAffineTransform = vImage_AffineTransform_Double

/*!
 @typedef   Pixel_8
 @abstract   An 8-bit per component unsigned planar pixel value.
*/
typealias Pixel_8 = UInt8

/*!
 @typedef   Pixel_F
 @abstract   A single precision floating-point planar pixel value.
 @discussion Typically, these have range [0,1] though other values are generally allowed.
*/
typealias Pixel_F = Float

/*!
 @typedef   Pixel_8888
 @abstract  A four channel, 8-bit per channel pixel.
 @discussion The channel order is generally given by the function that consumes the value.
 */
typealias Pixel_8888 = (UInt8, UInt8, UInt8, UInt8)

/*!
 @typedef   Pixel_FFFF
 @abstract  A four channel, single precision floating-point per channel pixel. 
 @discussion The channel order is generally given by the function that consumes the value.
 */
typealias Pixel_FFFF = (Float, Float, Float, Float)

/*!
 @typedef   Pixel_16U
 @abstract  A 16-bit per channel unsigned pixel.  
 @discussion Typical range is [0,USHRT_MAX] meaning [0.0, 1.0], though most functions tolerate other ranges.
*/
typealias Pixel_16U = UInt16

/*!
 @typedef   Pixel_16S
 @abstract  A 16-bit per channel signed pixel.  
 @discussion Typical range is [SHRT_MIN,SHRT_MAX] meaning [-1.0, 1.0], though most functions tolerate other ranges.
*/
typealias Pixel_16S = Int16

/*!
 @typedef   Pixel_16Q12
 @abstract  A signed 16 bit fixed point number with 12 bits of fractional precision.
 @discussion Normal range is [-4096,4096] meaning [-1.0, 1.0]. Values in the range [-8.0, 8.0) are representable.
 */
typealias Pixel_16Q12 = Int16

/*!
 @typedef   Pixel_ARGB_16U
 @abstract  A four channel, 16-bit unsigned per channel pixel.  
 @discussion The channel order is generally given by the function that consumes the value. It is not necessarily ARGB.
 */
typealias Pixel_ARGB_16U = (UInt16, UInt16, UInt16, UInt16)

/*!
 @typedef   Pixel_ARGB_16S
 @abstract  A four channel, 16-bit signed per channel pixel.  
 @discussion The channel order is generally given by the function that consumes the value. It is not necessarily ARGB.
*/
typealias Pixel_ARGB_16S = (Int16, Int16, Int16, Int16)

/*!
 @typedef ResamplingFilter
 @abstract A ResamplingFilter is an opaque structure used by vImage to hold precalculated filter coefficients for a resampling filter,
             such as a Lanczos or Gaussian resampling filter. 
 @discussion It is created with vImageNewResamplingFilter or vImageNewResamplingFilterUsingBuffer and is consumed by various vertical 
             and horizontal shear functions in vImage/Geometry.h. When possible, for better performance, reuse ResamplingFilters over 
             multiple vImage calls, instead of allocating a new one each time.
*/
typealias ResamplingFilter = UnsafeMutablePointer<Void>

/*!
 @typedef GammaFunction
 @discussion A GammaFunction is an opaque structure used by vImage to represent an approximation of a non-linear curve. It is created with
             vImageCreateGammaFunction, and destroyed with vImageDestroyGammaFunction. When possible, for better performance,
             reuse GammaFunctions over multiple vImage function calls, instead of creating a new one each time.
 */
typealias GammaFunction = UnsafeMutablePointer<Void>

/*!
     @typedef   vImage_Error 
     @abstract  An error code returned by a vImage function.
     @discussion    All negative values are errors.
                    Positive return values are likely to be the result of kvImageGetTempBufferSize.
                    Zero indicates no error, or quasi-ambiguously a zero temp buffer size, if that
                    flag was passed. Please see the documentation for the function that returned the
                    error code for additional information about the error.
 
    @constant   kvImageNoError      Success.  If kvImageGetTempBufferSize is set in flags, then
                                    it indicates the temp buffer size is 0 and the function did
                                    nothing else.
    @constant   kvImageRoiLargerThanInputBuffer     The size or positioning of the result buffer 
                                    was such that pixels were needed in the source buffer, were
                                    found to be missing and could not be discovered using an edging
                                    process like kvImageEdgeExtend. Typically, this means that the
                                    source image was smaller than the destination image. 
    @constant   kvImageInvalidKernelSize    The size of a kernel was invalid. Typically, kernels have
                                    have an odd number of rows and columns. The kernel might also have
                                    been too large or of zero dimension. Typically only returned by
                                    convolutions and morphological operations.
 
    @constant   kvImageInvalidEdgeStyle   The edging style {kvImageBackgroundColorFill, kvImageCopyInPlace, kvImageEdgeExtend, kvImageTruncateKernel}
                                    was invalid. Typically, the edging style is either missing or the edging style 
                                    is not supported by this function.
 
    @constant   kvImageInvalidOffset_X   Some functions take an integer offset in the horizontal dimension. This indicates
                                    how far from the left edge of the vImage_Buffer we shoud consider the origin to be.
                                    The offset allows real pixel data to be used where an edging method like kvImageEdgeExtend
                                    might otherwise have to be used to generate missing pixels. An X offset is essential to
                                    obtaining correct results for tiled image processing when the tile is not at the left
                                    edge of the (whole) image and the function has a kernel or ResamplingFilter.
                                    Typically, this can happen when the offset is negative or larger than the source vImage_Buffer.width.
 
    @constant   kvImageInvalidOffset_Y   Some functions take an integer offset in the vertical dimension. This indicates
                                    how far from the top edge of the vImage_Buffer we shoud consider the origin to be.
                                    The offset allows real pixel data to be used where an edging method like kvImageEdgeExtend
                                    might otherwise have to be used to generate missing pixels. A Y offset is essential to
                                    obtaining correct results for tiled image processing when the tile is not at the top
                                    edge of the (whole) image and the function has a kernel or ResamplingFilter.
                                    Typically, this can happen when the offset is negative or larger than the source vImage_Buffer.height.
 
    @constant   kvImageMemoryAllocationError    vImage attempted to allocate memory and the allocator failed, returning NULL.
 
    @constant   kvImageNullPointerArgument      One or more arguments to the function are NULL, which are not allowed to be NULL.
                                    Typically, arguments that are not allowed to be NULL are listed in the VIMAGE_NON_NULL() attribute
                                    that follows the function declaration.
 
    @constant   kvImageInvalidParameter         A function parameter has an invalid value. This is the fallback error code when there is not
                                    an error code that more precisely describes the invalid parameter value such as kvImageNullPointerArgument,
                                    kvImageInvalidEdgeStyle, kvImageInvalidRowBytes, etc.
 
    @constant   kvImageBufferSizeMismatch       This most often occurs when a set of planar buffers are not the same size.  Most often
                                    this occurs when the destination image is planar and the destination planes are not the same size.
                                    It may also occur in rare cases when chunk sizes mismatch for some high level conversions.
 
    @constant   kvImageUnknownFlagsBit      A bit in the flags field is set, which the function does not understand or currently support.
                                    Please check flags enum availability info to make sure the flag is supported on the target OS revision.
 
    @constant   kvImageInternalError    A serious error occured inside vImage, which prevented vImage from continuing. This error is
                                    probably a problem with vImage itself, and not how it is being used. Please file a bug with a
                                    reproducible test case attached, if possible!
 
    @constant   kvImageInvalidRowBytes  The vImage_Buffer.rowBytes field is invalid. In some circumstances, rowBytes of 0 is not supported, 
                                    particularly with destination images or when vImage is asked to initialize a vImage_Buffer and the
                                    rowBytes is too small to hold a row of image data.
 
    @constant   kvImageInvalidImageFormat  Usually a vImage_CGImageFormat or vImageCVImageFormatRef contains an invalid format. It might be a
                                    NULL pointer, a description which is not allowed according to rules of CG or CV image format encodings.
 
    @constant   kvImageColorSyncIsAbsent    ColorSync.framework is completely missing. Certain operations will not work.
 
    @constant   kvImageOutOfPlaceOperationRequired   The source images and destination images may not alias the same image data. This will
                                    be returned by vImageCGConverter_MustOperateOutOfPlace(). However, there are many functions in vImage
                                    that do not work in place which do not check to see if the buffers overlap. Please inspect the documentation
                                    of each function for notes on in-place usage before using them that way.
 
    @constant   kvImageInvalidImageObject   An invalid CGImageRef or CVPixelBufferRef was passed to the function.  Typically, the object was NULL.
                                    A non-NULL invalid CGImageRef or CVPixelBufferRef will result in undefined behavior.
 
    @constant   kvImageInvalidCVImageFormat A vImageCVImageFormatRef contains an invalid format. It might be a NULL pointer, or an image format
                                    which is not allowed according to rules of CV image format encodings.
 
    @constant   kvImageUnsupportedConversion    Some lower level conversion APIs only support conversion among a sparse matrix of image formats.
 */
typealias vImage_Error = Int
var kvImageNoError: Int { get }
var kvImageRoiLargerThanInputBuffer: Int { get }
var kvImageInvalidKernelSize: Int { get }
var kvImageInvalidEdgeStyle: Int { get }
var kvImageInvalidOffset_X: Int { get }
var kvImageInvalidOffset_Y: Int { get }
var kvImageMemoryAllocationError: Int { get }
var kvImageNullPointerArgument: Int { get }
var kvImageInvalidParameter: Int { get }
var kvImageBufferSizeMismatch: Int { get }
var kvImageUnknownFlagsBit: Int { get }
var kvImageInternalError: Int { get }
var kvImageInvalidRowBytes: Int { get }
var kvImageInvalidImageFormat: Int { get }
var kvImageColorSyncIsAbsent: Int { get }
var kvImageOutOfPlaceOperationRequired: Int { get }
var kvImageInvalidImageObject: Int { get }
var kvImageInvalidCVImageFormat: Int { get }
var kvImageUnsupportedConversion: Int { get }
var kvImageCoreVideoIsAbsent: Int { get }

/*!
 @typedef   vImage_Flags
 @abstract      vImage_Flags is a 32-bit bitfield of options of general use to vImage functions.
 @discussion    Multiple bits may be set concurrently. kvImageUnknownFlagsBit may be returned by
                a function if a flag bit is set (1) but the function does not know what the flag
                bit means (e.g. your new code on an older version of vImage) or if the flag should
                cause a behavior that is unsupported by the function, for example, kvImageHighQualityResampling
                to a function that does not do image resampling.
 @constant  kvImageNoFlags   Use the default behavior. Internal multithreading is enabled. Debug 
                messages are generally not printed to the console. No edging method is specified. 
                Normal quality resampling methods are used (Lanczos3, probably). Do the function,
                instead of returning a temp buffer size. Allocate memory as needed.
 
 @constant  kvImageLeaveAlphaUnchanged   Some functions that operate on ARGB data in place allow
                you to operate on just the RGB components and leave the alpha channel unmodified.
                These are typically histogram and gamma functions.
 
 @constant  kvImageCopyInPlace  One of four edging modes. This one tells vImage to do nothing for
                destination pixels that need source pixels that are missing. The corresponding source
                pixel is copied to the destination image. This is only used for image filters that take a
                kernel, such as convolutions. It is not allowed for Morphology filters.
 
 @constant kvImageBackgroundColorFill  One of four edging modes. This one tells vImage to use the
                backgroundColor parameter of the function as the color of any missing pixels in
                a source image. Missing pixels occur when a filter needs to read off the edge of
                a source image. 
 
 @constant kvImageEdgeExtend    One of four edging modes.  This one tells vImage to use the nearest
                existing source image pixel when it needs source data but finds it needs a non-existant
                pixel off the edge of the provided source image. 
 
 @constant kvImageDoNotTile     Do not internally subdivide the image for processing on multiple CPUs
                or other compute devices. If this flag is set, the function will run single threaded
                on the current thread. Usually this flag may be expected to cause a significant increase
                in the execution time of a vImage function. However, if you are calling the function
                from a heavily multithreaded context (such as your own tiling engine) and CPU occupancy
                is high, this may lead to small performance improvements due to reduced CPU contention.
 
 @constant kvImageHighQualityResampling  Use a more expensive image resampling method than what is available
                by default. Typically this is Lanczos5. Note that as vImage resampling already leans towards
                quality over performance -- the GPU texture unit is your friend if you just want raw performance
                -- the additional quality from kvImageHighQualityResampling may be difficult to see in some images. 
                It is best suited to background rendering tasks.
 
 @constant kvImageTruncateKernel    One of four edging modes. This one tells vImage to use only the pixels it 
                has and reweight the kernel accordingly. The reweighting process can be expensive.  It can 
                also lead to difficulties if a contiguous sub-rectangle of the kernel sums to zero. In this
                case, the area of the kernel is zero and you have formally asked vImage to do division by zero,
                in which case vImage behavior is undefined.
 
 @constant kvImageGetTempBufferSize  Instead of performing the function requested, return (as a vImage_Error)
                the size of the temp buffer requried by the function for this set of parameters. The image pixels
                are not touched. If the function does not take a temp buffer, then 0 will be returned and the 
                function will do nothing. Some functions may return a 0 sized temp buffer for some sets of parameters 
                an not others. The size of the temporary buffer may change for different parameters, and for
                different OS revisions.
 
 @constant kvImagePrintDiagnosticsToConsole Some of the high level functions in vImage_Utilities.h and 
                vImage_CVUtilities.h have complex failure modes that could prove baffling with just a 
                error code return.  This flag instructions these functions to also print a human readable
                diagnostic message to the Apple System Logger when an error is encountered. The output 
                should be visible in Console.app.
 
 @constant kvImageNoAllocate    Some vImage functions may allocate memory, possibly returning it to you.
                This flag instructs the function to use the memory provided instead. For example, instead of
                overwriting vImage_Buffer.data with a newly allocated pointer to memory, use the memory
                pointed to by vImage_Buffer.data directly. In other cases, it may cause the function to
                assume ownership of a buffer, rather than allocating a copy. You are responsible for making
                sure the buffer that you allocate instead of vImage is large enough to hold the image. Most 
                vImage functions do not allocate memory and assume that vImage_Buffer.data is already allocated, 
                and in the case of source image buffers, contain valid pixel data.
 
 @constant kvImageHDRContent    The pixels described in the input image may contain high dymanic range content.
                HDR pixels may have value outside of [-2,2.0]. This flag is generally only applicable to 
                floating-point images. Most 8- and 16-bit pixels can not represent values outside [0,1] and
                functions that operate on 16Q12 formats are designed to operate over the full range of [-8,8).
                Most floating-point functions in vImage are linear in behavior and so work equally well 
                on any float.  Some non-linear functions like polynomials (or by extension colorspace conversion)
                are only valid over a limited range (typically [-2,2]) and will return incorrect answers 
                for values outside that range.  In addition, certain IIR or FFT algorithms in convolution may
                encounter precision issues with HDR content.  For these cases, if you know you have HDR content,
                pass kvImageHDRContent and a (typically slower) alternative method will be used for these
                sources.
 */
typealias vImage_Flags = UInt32
var kvImageNoFlags: Int { get }
@available(OSX 10.3, *)
var kvImageLeaveAlphaUnchanged: Int { get }
@available(OSX 10.3, *)
var kvImageCopyInPlace: Int { get }
@available(OSX 10.3, *)
var kvImageBackgroundColorFill: Int { get }
@available(OSX 10.3, *)
var kvImageEdgeExtend: Int { get }
@available(OSX 10.3, *)
var kvImageDoNotTile: Int { get }
@available(OSX 10.3, *)
var kvImageHighQualityResampling: Int { get }
@available(OSX 10.4, *)
var kvImageTruncateKernel: Int { get }
@available(OSX 10.4, *)
var kvImageGetTempBufferSize: Int { get }
@available(OSX 10.9, *)
var kvImagePrintDiagnosticsToConsole: Int { get }
@available(OSX 10.9, *)
var kvImageNoAllocate: Int { get }
@available(OSX 10.11, *)
var kvImageHDRContent: Int { get }

/*!
    @class vImageConverterRef
    @abstract   An opaque type which contains a decription of a conversion from one CoreGraphics image format to another.
 
    @discussion The vImageConverter is an opaque type which contains information needed to do a rapid conversion from
    one image type to another. Sometimes, it can take a significant amount of time to figure out how to convert
    from one format to another. It wouldn't be good to do that redundantly for a bunch of small images. The
    vImageConversionSetup allows us to set up the conversion once and reuse the information many times, to
    keep net latencies low.
 
    Note that creating a vImageConverter can at times take a while. While usually it is quick, it might have
    to do things like load other frameworks in the system (e.g. Colorsync) if they are not loaded already,
    or build a lookup table. It is a good idea to setup your conversions in advance and reuse the conversion
    objects.  The objects are thread safe. You can use the same object in multiple threads concurrently. They
    follow standard retain / release semantics and can be used as CFTypeRefs.
 
    @superclass CFTypeRef
 
    @seealso Please see vImage_Utilities.h for interfaces that operate on the vImageConverterRef
 */
class vImageConverter {
}

/*!
    @class vImageConverterRef
    @abstract   An opaque type which contains a decription of a conversion from one CoreGraphics image format to another.
 
    @discussion The vImageConverter is an opaque type which contains information needed to do a rapid conversion from
    one image type to another. Sometimes, it can take a significant amount of time to figure out how to convert
    from one format to another. It wouldn't be good to do that redundantly for a bunch of small images. The
    vImageConversionSetup allows us to set up the conversion once and reuse the information many times, to
    keep net latencies low.
 
    Note that creating a vImageConverter can at times take a while. While usually it is quick, it might have
    to do things like load other frameworks in the system (e.g. Colorsync) if they are not loaded already,
    or build a lookup table. It is a good idea to setup your conversions in advance and reuse the conversion
    objects.  The objects are thread safe. You can use the same object in multiple threads concurrently. They
    follow standard retain / release semantics and can be used as CFTypeRefs.
 
    @superclass CFTypeRef
 
    @seealso Please see vImage_Utilities.h for interfaces that operate on the vImageConverterRef
 */
typealias vImageConverterRef = vImageConverter

/*!
    @class vImageCVImageFormatRef
    @abstract   An opaque type which contains a decription of a conversion from a CoreGraphics image format to a CVPixelBuffer, or the reverse.
 
    @superclass CFTypeRef
    @discussion The vImageCVImageFormatRef describes how the image is encoded in a CVPixelBufferRef. vImage uses this information to construct converters that
    are capable of converting to and from this image encoding.  The format stores a description of the pixels in the image (planar/color representation/
    bit depth/number of channels, etc.) but not the image size, location of the base pointer or rowbytes. It is intended for the vImageCVImageFormatRef
    to be reused for other CVPixelBufferRefs of the same format, such as other frames from the same movie.
 
    vImageCVImageFormatRefs are capable of holding an incomplete encoding representation. You may be required to provide addition information such
    as colorspace and (YCbCr only) chroma siting or conversion matrix before the vImageCVImageFormatRef can be used for image conversion to other
    formats.
 
    The vImageCVImageFormatRef is a CFTypeRef. CFEqual does not test for equivalence of the userData field. You should use vImageCVImageFormat_Retain/Release
    when working with vImageCVImageFormatRef to manage ownership of the object.

        <pre>
        @textblock
        Thread Safety:

            The vImageCVImageFormatRef may be safely read from multiple threads concurrently.  However,
            it makes no attempt to keep its internal state coherent when multiple threads write to it,
            or when one thread writes to it while one or more threads are reading from it at the same
            time. This can be trivially handled by keeping the knowledge of the vImageCVImageFormatRef
            limited to a single thread while it is being created / configured and then treat it as
            immutable thereafter.  If necessary, you can also use a read/write lock to limit reentrant
            access.
        @/textblock
        </pre>
 
 
    Information tracked by vImageCVImageFormatRef:
 
 <pre>
 @textblock
    imageFormatType     A CVPixelFormatType such as '2vuy'. See CVPixelBuffer.h for the complete list.
 
    number_of_channels  How many  color + alpha channels are encoded in the image. An alpha channel is included in this count
                        if it takes up space in the image, even if its value is described always 1.0, for example by /Last
                        kCGImageAlphaNoneSkipFirst or kCVImageBufferAlphaChannelIsOpaque.  This field is automatically initialized
                        based on the imageFormatType (see above) and is never missing.
 
    channel_names       A list of vImageBufferTypeCodes corresponding to the channels in the image. Unlike what happens for
                        vImageConverterRefs, the type codes used here always encode a single color channel.  vImageConverterRefs
                        use the channel names to encode what is in each vImage_Buffer. Here it is used to describe each channel.
                        So, an ARGB buffer might be described as kvImageBufferTypeCode_CGFormat but will be described as
                        { kvImageBufferTypeCode_RGB_Red, kvImageBufferTypeCode_RGB_Green, kvImageBufferTypeCode_RGB_Blue,
                        kvImageBufferTypeCode_Alpha, kvImageBufferTypeCode_EndOfList }. The order of the channels in the list
                        may not match the order of the channels in the buffer.  This field is automatically initialized based on
                        the imageFormatType (see above) and is never missing.
 
   matrix               (YpCbCr only.)  A YpCbCr image has an associated 3x3 matrix that encodes how it was converted to YpCbCr from
                        a reference RGB colorspace (see colorspace below). The matrix is encoded as a NULL pointer when missing.
                        This field is ignored for non-YpCbCr formats.
 
 
   chroma_siting        Some YpCbCr formats store their chroma components as a smaller image than the luminance component.
                        This describes where the subsampled chroma samples are positioned relative to the luminance component.
                        This field is encoded as a NULL CFStringRef when missing. The field is ignored for RGB, monochrome,
                        indexed and 4:4:4 YpCbCr image formats.
 
   colorspace           For RGB, indexed and grayscale images, this is the colorspace that describes the image encoding.
                        For YpCbCr images, this is the colorspace of the RGB image that you get once the matrix (see above)
                        is unapplied. Thus, the colorspace encodes for the underlying primaries and transfer function of the
                        YpCbCr image. See also vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction.  This field is required
                        for all image formats. A colorspace of NULL indicates a missing colorspace. (This is inconsistent with
                        the shorthand used in vImage_Utilities.h where NULL maps to sRGB.)  Since vImage has no concept of
                        a current graphics device, deviceRGB maps to sRGB and device gray maps to gray 2.2. If you wish to
                        ensure no color correction / conversion, you should match this colorspace with the one in the
                        vImage_CGImageFormat to / from which you are converting.
 
   channel_description  Some CVPixelBuffer formats do not use the entire representable range of the format to encode image data.
                        For example, a 'yuvs' "video range" buffer only uses the range [16,235] for luminance and [16,240] for
                        chroma. Values outside that range are considered to have value equal to the nearest in-range value. In
                        addition, we add additionional fields to leave open the possibility that some formats can encode information
                        outside of the traditional [0,1.0] range ([-1.0,1.0] for chroma) so reference values for the encoding for 0
                        and 1.0 are also described. (See vImageChannelDescription below.) The zero/one fields are analogous in function
                        to the decode arrays provided by CG. It is possible to use the channel description to create formats that are
                        not correctly understood by CoreVideo. These are provided to allow for interoperation with custom video formats.
                        The channel description is initialized automatically for known image format types (see imageFormatType above)
                        and probably only very rarely needs to be changed. It is never missing.
 
  alpha_is_one_hint     Some images are encoded with an alpha channel. However, you may have additional information that the image is
                        really completely opaque. The "alpha is one hint" tells vImage that the alpha channel is always 1.0 (opaque)
                        across the entire image. Setting the hint to 1 may allow vImage to avoid work and run faster in some cases.
                        There is no vImageCVImageFormatRef representation for premultiplied alpha, currently. Since it is a hint,
                        the hint may never be missing from a vImageCVImageFormatRef.  The hint is ignored for image formats that do
                        not contain an alpha channel.
 
  user_data             The vImageCVImageFormatRef has a userData field to allow you to easily reference your data starting from
                        a handle to the object. vImage does  not attempt to interact with the memory pointed to by the userData
                        pointer. It simply holds on to the pointer for you and will call a destructor callback function when the
                        vImageCVImageFormatRef to allow you to free that memory, and do any other post processing needed when the
                        vImageCVImageFormatRef is destroyed. Since there is only one userData pointer, by convention its use is
                        considered private to the application/library/framework that created the vImageCVImageFormatRef, including
                        cases where the creator does not set the userData field. If you need to attach your own data to a
                        vImageCVImageFormatRef created by someone else, you can make  a copy of it or wrap it with your own object.
 @/textblock
 </pre>
 
    @seealso Please see vImage_CVUtilities.h for interfaces that operate on the vImageCVImageFormatRef
 */
typealias vImageCVImageFormatRef = vImageCVImageFormat

/*!
    @class vImageCVImageFormatRef
    @abstract   An opaque type which contains a decription of a conversion from a CoreGraphics image format to a CVPixelBuffer, or the reverse.
 
    @superclass CFTypeRef
    @discussion The vImageCVImageFormatRef describes how the image is encoded in a CVPixelBufferRef. vImage uses this information to construct converters that
    are capable of converting to and from this image encoding.  The format stores a description of the pixels in the image (planar/color representation/
    bit depth/number of channels, etc.) but not the image size, location of the base pointer or rowbytes. It is intended for the vImageCVImageFormatRef
    to be reused for other CVPixelBufferRefs of the same format, such as other frames from the same movie.
 
    vImageCVImageFormatRefs are capable of holding an incomplete encoding representation. You may be required to provide addition information such
    as colorspace and (YCbCr only) chroma siting or conversion matrix before the vImageCVImageFormatRef can be used for image conversion to other
    formats.
 
    The vImageCVImageFormatRef is a CFTypeRef. CFEqual does not test for equivalence of the userData field. You should use vImageCVImageFormat_Retain/Release
    when working with vImageCVImageFormatRef to manage ownership of the object.

        <pre>
        @textblock
        Thread Safety:

            The vImageCVImageFormatRef may be safely read from multiple threads concurrently.  However,
            it makes no attempt to keep its internal state coherent when multiple threads write to it,
            or when one thread writes to it while one or more threads are reading from it at the same
            time. This can be trivially handled by keeping the knowledge of the vImageCVImageFormatRef
            limited to a single thread while it is being created / configured and then treat it as
            immutable thereafter.  If necessary, you can also use a read/write lock to limit reentrant
            access.
        @/textblock
        </pre>
 
 
    Information tracked by vImageCVImageFormatRef:
 
 <pre>
 @textblock
    imageFormatType     A CVPixelFormatType such as '2vuy'. See CVPixelBuffer.h for the complete list.
 
    number_of_channels  How many  color + alpha channels are encoded in the image. An alpha channel is included in this count
                        if it takes up space in the image, even if its value is described always 1.0, for example by /Last
                        kCGImageAlphaNoneSkipFirst or kCVImageBufferAlphaChannelIsOpaque.  This field is automatically initialized
                        based on the imageFormatType (see above) and is never missing.
 
    channel_names       A list of vImageBufferTypeCodes corresponding to the channels in the image. Unlike what happens for
                        vImageConverterRefs, the type codes used here always encode a single color channel.  vImageConverterRefs
                        use the channel names to encode what is in each vImage_Buffer. Here it is used to describe each channel.
                        So, an ARGB buffer might be described as kvImageBufferTypeCode_CGFormat but will be described as
                        { kvImageBufferTypeCode_RGB_Red, kvImageBufferTypeCode_RGB_Green, kvImageBufferTypeCode_RGB_Blue,
                        kvImageBufferTypeCode_Alpha, kvImageBufferTypeCode_EndOfList }. The order of the channels in the list
                        may not match the order of the channels in the buffer.  This field is automatically initialized based on
                        the imageFormatType (see above) and is never missing.
 
   matrix               (YpCbCr only.)  A YpCbCr image has an associated 3x3 matrix that encodes how it was converted to YpCbCr from
                        a reference RGB colorspace (see colorspace below). The matrix is encoded as a NULL pointer when missing.
                        This field is ignored for non-YpCbCr formats.
 
 
   chroma_siting        Some YpCbCr formats store their chroma components as a smaller image than the luminance component.
                        This describes where the subsampled chroma samples are positioned relative to the luminance component.
                        This field is encoded as a NULL CFStringRef when missing. The field is ignored for RGB, monochrome,
                        indexed and 4:4:4 YpCbCr image formats.
 
   colorspace           For RGB, indexed and grayscale images, this is the colorspace that describes the image encoding.
                        For YpCbCr images, this is the colorspace of the RGB image that you get once the matrix (see above)
                        is unapplied. Thus, the colorspace encodes for the underlying primaries and transfer function of the
                        YpCbCr image. See also vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction.  This field is required
                        for all image formats. A colorspace of NULL indicates a missing colorspace. (This is inconsistent with
                        the shorthand used in vImage_Utilities.h where NULL maps to sRGB.)  Since vImage has no concept of
                        a current graphics device, deviceRGB maps to sRGB and device gray maps to gray 2.2. If you wish to
                        ensure no color correction / conversion, you should match this colorspace with the one in the
                        vImage_CGImageFormat to / from which you are converting.
 
   channel_description  Some CVPixelBuffer formats do not use the entire representable range of the format to encode image data.
                        For example, a 'yuvs' "video range" buffer only uses the range [16,235] for luminance and [16,240] for
                        chroma. Values outside that range are considered to have value equal to the nearest in-range value. In
                        addition, we add additionional fields to leave open the possibility that some formats can encode information
                        outside of the traditional [0,1.0] range ([-1.0,1.0] for chroma) so reference values for the encoding for 0
                        and 1.0 are also described. (See vImageChannelDescription below.) The zero/one fields are analogous in function
                        to the decode arrays provided by CG. It is possible to use the channel description to create formats that are
                        not correctly understood by CoreVideo. These are provided to allow for interoperation with custom video formats.
                        The channel description is initialized automatically for known image format types (see imageFormatType above)
                        and probably only very rarely needs to be changed. It is never missing.
 
  alpha_is_one_hint     Some images are encoded with an alpha channel. However, you may have additional information that the image is
                        really completely opaque. The "alpha is one hint" tells vImage that the alpha channel is always 1.0 (opaque)
                        across the entire image. Setting the hint to 1 may allow vImage to avoid work and run faster in some cases.
                        There is no vImageCVImageFormatRef representation for premultiplied alpha, currently. Since it is a hint,
                        the hint may never be missing from a vImageCVImageFormatRef.  The hint is ignored for image formats that do
                        not contain an alpha channel.
 
  user_data             The vImageCVImageFormatRef has a userData field to allow you to easily reference your data starting from
                        a handle to the object. vImage does  not attempt to interact with the memory pointed to by the userData
                        pointer. It simply holds on to the pointer for you and will call a destructor callback function when the
                        vImageCVImageFormatRef to allow you to free that memory, and do any other post processing needed when the
                        vImageCVImageFormatRef is destroyed. Since there is only one userData pointer, by convention its use is
                        considered private to the application/library/framework that created the vImageCVImageFormatRef, including
                        cases where the creator does not set the userData field. If you need to attach your own data to a
                        vImageCVImageFormatRef created by someone else, you can make  a copy of it or wrap it with your own object.
 @/textblock
 </pre>
 
    @seealso Please see vImage_CVUtilities.h for interfaces that operate on the vImageCVImageFormatRef
 */
class vImageCVImageFormat {
}
class vImageConstCVImageFormat {
}
typealias vImageConstCVImageFormatRef = vImageConstCVImageFormat

/*!
    @typedef    vImageARGBType
    @abstract   An encoding of an image format type to be used with RGB <-> Y'CbCr conversions in vImage/Conversions.h
    @discussion These formats enumerate different vImage ARGB pixel formats.
 */
struct vImageARGBType : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
@available(OSX 10.0, *)
var kvImageARGB8888: vImageARGBType { get }
@available(OSX 10.0, *)
var kvImageARGB16U: vImageARGBType { get }
@available(OSX 10.0, OSX 10.0, *)
var kvImageARGB16Q12: vImageARGBType { get }

/*!
    @typedef    vImageYpCbCrType
    @abstract   An encoding of an image format type to be used with RGB <-> Y'CbCr conversions in vImage/Conversions.h
    @discussion These formats enumerate different vImage/CoreVideo Y'CbCr pixel formats.
    @seealso    CVPixelBuffer OSTypes in CVPixelBuffer.h
 */
struct vImageYpCbCrType : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
@available(OSX 10.0, *)
var kvImage422CbYpCrYp8: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage422YpCbYpCr8: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage422CbYpCrYp8_AA8: vImageYpCbCrType { get }
@available(OSX 10.0, OSX 10.0, *)
var kvImage420Yp8_Cb8_Cr8: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage420Yp8_CbCr8: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage444AYpCbCr8: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage444CrYpCb8: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage444CbYpCrA8: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage444CrYpCb10: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage422CrYpCbYpCbYpCbYpCrYpCrYp10: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage422CbYpCrYp16: vImageYpCbCrType { get }
@available(OSX 10.0, *)
var kvImage444AYpCbCr16: vImageYpCbCrType { get }

/*!
 @struct    vImage_YpCbCrToARGBMatrix
 
 @field Yp      matrix[0][0].  Typically 1.
 @field Cr_R    matrix[0][2].
 @field Cb_G    matrix[1][1].
 @field Cr_G    matrix[1][2].
 @field Cb_B    matrix[2][1]
 
 @abstract   A 3x3 converson matrix for converting Y'CbCr signals to RGB
 @discussion The matrix is sparse. The 3x3 matrix is given by:
 
            <pre>
            @textblock
                    | R |   | Yp    0     Cr_R |   | Y' |
                    | G | = | Yp   Cb_G   Cr_G | * | Cb |
                    | B |   | Yp   Cb_B     0  |   | Cr |
            @/textblock
            </pre>
 
            Limits on the range of the fields in the matrix may apply.
 
 @seealso    vImage_ARGBToYpCbCrMatrix, which is the inverse matrix
 */
struct vImage_YpCbCrToARGBMatrix {
  var Yp: Float
  var Cr_R: Float
  var Cr_G: Float
  var Cb_G: Float
  var Cb_B: Float
  init()
  init(Yp: Float, Cr_R: Float, Cr_G: Float, Cb_G: Float, Cb_B: Float)
}

/*! @const      kvImage_YpCbCrToARGBMatrix_ITU_R_601_4
    @abstract   Y'CbCr->RGB conversion matrix for ITU-Recommendation BT.601-4 */
@available(OSX 10.10, *)
var kvImage_YpCbCrToARGBMatrix_ITU_R_601_4: UnsafePointer<vImage_YpCbCrToARGBMatrix>

/*! @const      kvImage_YpCbCrToARGBMatrix_ITU_R_709_2
    @abstract   Y'CbCr->RGB conversion matrix for ITU-Recommendation BT.709-2 */
@available(OSX 10.10, *)
var kvImage_YpCbCrToARGBMatrix_ITU_R_709_2: UnsafePointer<vImage_YpCbCrToARGBMatrix>

/*!
 @typedef    vImage_YpCbCrToARGB
 @abstract   An opaque representation of a 3x3 converson matrix for converting Y'CbCr signals to RGB.
             It is used to do the actual conversions. Please attempt to reuse these rather than making
             new ones each time.
 @discussion The representation also includes the range of the input and output pixels from the matrix and
             clamping information.
 
 @seealso    vImage_ARGBToYpCbCr, which is the inverse matrix
 */
struct vImage_YpCbCrToARGB {
  var opaque: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8)
  init()
  init(opaque: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8))
}

/*!
 @typedef    vImage_ARGBToYpCbCrMatrix
 @abstract   A 3x3 converson matrix for converting RGB signals to Y'CbCr
 @discussion The matrix has one repeating parameter. The 3x3 matrix is given by:
 
 @textblock
        | Y' |   | R_Yp        G_Yp  B_Yp      |   | R |
        | Cb | = | R_Cb        G_Cb  B_Cb_R_Cr | * | G |
        | Cr |   | B_Cb_R_Cr   G_Cr  B_Cr      |   | B |
 @/textblock
 
 Typically, these matrix coefficients come from a conversion of form:
 
 @textblock
    Y' = R_Yp * R + G_Yp * G + B_Yp * B         0 <= Y' <= 1
    Cb = k0 * (B - Y')                          -0.5 <= Cb <= 0.5
    Cr = k1 * (R - Y')                          -0.5 <= Cr <= 0.5
 @/textblock
 
 {R_Yp, G_Yp, B_Yp} are typically derived from the perceived brightness for red, green and blue.
 k0 and k1 are typically scaled so that Cb and Cr have the indicated range. Because of these
 relationships, {R_Yp, G_Yp, B_Yp} are usually positive, and B_Cb_R_Cr is usually 0.5.
 Limits on the range of the fields in the matrix may apply.
 @field R_Yp    matrix[0][0]
 @field G_Yp    matrix[0][1]
 @field B_Yp    matrix[0][2]
 @field R_Cb    matrix[1][0]
 @field G_Cb    matrix[1][1]
 @field B_Cb_R_Cr matrix[1][2] and matrix[2][0]
 @field G_Cr    matrix[2][1]
 @field B_Cr    matrix[2][2]
 @seealso    vImage_YpCbCrToARGBMatrix, which is the inverse matrix
 
 */
struct vImage_ARGBToYpCbCrMatrix {
  var R_Yp: Float
  var G_Yp: Float
  var B_Yp: Float
  var R_Cb: Float
  var G_Cb: Float
  var B_Cb_R_Cr: Float
  var G_Cr: Float
  var B_Cr: Float
  init()
  init(R_Yp: Float, G_Yp: Float, B_Yp: Float, R_Cb: Float, G_Cb: Float, B_Cb_R_Cr: Float, G_Cr: Float, B_Cr: Float)
}

/*! @const      kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4
    @abstract   RGB->Y'CbCr conversion matrix for ITU-Recommendation BT.601-4 */
@available(OSX 10.10, *)
var kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4: UnsafePointer<vImage_ARGBToYpCbCrMatrix>

/*! @const      kvImage_ARGBToYpCbCrMatrix_ITU_R_709_2
    @abstract   RGB->Y'CbCr conversion matrix for ITU-Recommendation BT.709-2 */
@available(OSX 10.10, *)
var kvImage_ARGBToYpCbCrMatrix_ITU_R_709_2: UnsafePointer<vImage_ARGBToYpCbCrMatrix>

/*!
 @typedef    vImage_ARGBToYpCbCr
 @abstract   An opaque representation of a 3x3 converson matrix for converting RGB signals to Y'CbCr.
 It is used to do the actual conversions. Please attempt to reuse these rather than making
 new ones each time.
 @discussion The representation also includes the range of the input and output pixels from the matrix and
 clamping information.
 
 @seealso    vImage_ARGBToYpCbCr, which is the inverse matrix
 */
struct vImage_ARGBToYpCbCr {
  var opaque: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8)
  init()
  init(opaque: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8))
}

/*! 
 @typedef vImage_YpCbCrPixelRange
 @abstract  Range and clamping information for Y'CbCr pixel formats
 @discussion Y'CbCr formats frequently don't use the entire representable range available to 
             them to represent image data. While a "full range" video format does use the
             entire range, a "video range" format often leaves the extrema unused, except perhaps
             to represent values outside of the standard Y'=[0,1] CbCr = [-0.5, 0.5] range. 
             For example, a 8-bit video range format typically uses the range [16,235] for
             Y' and [16, 240] for Cb and Cr. 
 
 
             Some examples:
    
 @textblock
                (vImage_YpCbCrPixelRange){ 16, 128, 235, 240, 255, 0, 255, 1 }      // video range 8-bit, unclamped
                (vImage_YpCbCrPixelRange){ 16, 128, 235, 240, 235, 16, 240, 16 }    // video range 8-bit, clamped to video range
                (vImage_YpCbCrPixelRange){ 0, 128, 255, 255, 255, 1, 255, 0 }       // full range 8-bit, clamped to full range
 @/textblock
 
            The bias will be the prebias for YUV -> RGB and postbias for RGB -> YUV.
 
 @field Yp_bias The encoding for Y' = 0.0 for this video format (varies by bitdepth)
 @field CbCr_bias The encoding for {Cb,Cr} = 0.0 for this video format. This is usually the MIDDLE of the range of CbCr, not the low end. 
 @field YpRangeMax The encoding for Y' = 1.0 for this video format. For video range, this is typically less than the maximum representable value.
 @field CbCrRangeMax The encoding for {Cb,Cr} = 0.5 for this video format. This is usually near the high end of the encodable range (e.g. 0xf0), if not the maximum encodable value (e.g. 0xff)
 @field YpMax  The encoding for the maximum allowed Y' value. All values larger than this will be clamped to this value.
 @field YpMin   The encoding of the minimum allowed Y' value. All values less than this will be clamped to this value.
 @field CbCrMax The encoding of the maximum allowed {Cb, Cr} value. All chroma values greater than this value will be clamped to this value.
 @field CbCrMin The encoding of the minimum allowed {Cb, Cr} value. All chroma values less than this value will be clamped to this value.
 @seealso vImageChannelDescription
*/
struct vImage_YpCbCrPixelRange {
  var Yp_bias: Int32
  var CbCr_bias: Int32
  var YpRangeMax: Int32
  var CbCrRangeMax: Int32
  var YpMax: Int32
  var YpMin: Int32
  var CbCrMax: Int32
  var CbCrMin: Int32
  init()
  init(Yp_bias: Int32, CbCr_bias: Int32, YpRangeMax: Int32, CbCrRangeMax: Int32, YpMax: Int32, YpMin: Int32, CbCrMax: Int32, CbCrMin: Int32)
}

/*!
 * @const kvImageDecodeArray_16Q12Format
 * @abstract Predefined decode array constant to use with 16Q12 formatted data
 * @discussion 16Q12 data is a signed 16-bit fixed point integer. The format is implicitly divided by 2**12
 *             to give a range of [-8,8)  (SHRT_MIN/4096,SHRT_MAX/4096). The type is present to allow 
 *             8-bit content to be converted into other colorspaces and operated on without undue
 *             loss of precision or loss of color gamut due to clamping. This constant is "magic" in the
 *             sense that it is identified by address. Copying the values here will cause a CG format to
 *             be instead interpreted as a _unsigned_ 16 bit format. 
 *
 *             16Q12 pixels do not follow CG image format conventions in two respects. The format is signed.
 *             The alpha channel is subject to the decode array transform too, meaning that 0 is transparent 
 *             and 4096 opaque. Consequently, ALL buffers that use this format must be tagged with the 
 *             kvImageDecodeArray_16Q12Format decode array.
 *
 */
var kvImageDecodeArray_16Q12Format: UnsafePointer<CGFloat>

/*!
 * @struct vImage_CGImageFormat
 * @abstract A pixel format
 * @discussion A vImage_CGImageFormat describes the ordering of the color channels, how many there are,
 * the size and type of the data in the color channels and whether the data is premultiplied by alpha or not.
 * This format mirrors the image format descriptors used by CoreGraphics to create things like CGImageRef and
 * CGBitmapContextRef.
 *
 * This vImage_CGImageFormat:
 *
 *  <pre>@textblock
 *      vImage_CGImageFormat format = {
 *          .bitsPerComponent = 8,
 *          .bitsPerPixel = 32,
 *          .colorSpace = CGColorSpaceCreateDeviceRGB(),                                    // don't forget to release this!
 *          .bitmapInfo = kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Little,
 *          .version = 0,                                                                   // must be 0
 *          .decode = NULL,
 *          .renderingIntent = kCGRenderingIntentDefault
 *      };
 *  @/textblock</pre>
 *
 * codes for a little endian ARGB8888 pixel, or what is called in the rest of vImage, BGRA8888. Note: for 16-
 * and 32-bits per component formats (int16_t, uint16_t, half-float, float) most vImage image filters assume
 * the data is in host-endian format. (The APIs in this header do not.) Host-endian is little endian for Intel
 * and ARM, big endian for PowerPC. If the data is not in host-endian format, then you may use
 * vImagePermuteChannels_ARGB8888 or vImageByteSwap_Planar16U to swap the image data byte ordering.
 *
 * Some examples:
 *  <pre>@textblock
 *      ARGB8888     ->  {8, 32, NULL, alpha first, 0, NULL, kCGRenderingIntentDefault}     alpha first = { kCGImageAlphaFirst, kCGImageAlphaPremultipliedFirst, kCGImageAlphaNoneSkipFirst }
 *      RGBA8888     ->  {8, 32, NULL, alpha last,  0, NULL, kCGRenderingIntentDefault}     alpha last  = { kCGImageAlphaLast,  kCGImageAlphaPremultipliedLast,  kCGImageAlphaNoneSkipLast }
 *      BGRA8888     ->  {8, 32, NULL, alpha first | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault}
 *      RGB888       ->  {8, 24, NULL, kCGImageAlphaNone | kCGBitmapByteOrderDefault, 0, NULL, kCGRenderingIntentDefault}
 *      RGB565       ->  {5, 16, NULL, kCGImageAlphaNone | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault}
 *      ARGB1555     ->  {5, 16, NULL, alpha first | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault}
 *      RGBA16F      ->  {16, 64, NULL, alpha last | kCGBitmapFloatComponents | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault }
 *      CMYK8888     ->  {8, 32, CGColorSpaceCreateDeviceCMYK(), kCGImageAlphaNone, 0, NULL, kCGRenderingIntentDefault  }
 *      ARGBFFFF premultiplied    ->  {32, 128, NULL, kCGImageAlphaPremultipliedFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }
 *      ARGBFFFF not-premultiplied -> {32, 128, NULL, kCGImageAlphaFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }
 *      ARGBFFFF, alpha = 1 ->        {32, 128, NULL, kCGImageAlphaNoneSkipFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }
 *  @/textblock</pre>
 *
 *  Note that some of these formats, particularly RGB565 and 16F formats are supported by vImage but
 *  not necessarily CoreGraphics. They will be converted to a higher precision format as necessary by
 *  vImage in vImageCreateCGImageFromBuffer().
 *
 *  By C rules, uninitialized struct parameters are set to zero. The last three parameters are usually zero, so can usually be omitted.
 *
 *  <pre>@textblock
 *      vImage_CGImageFormat srgb888 = (vImage_CGImageFormat){
 *          .bitsPerComponent = 8,
 *          .bitsPerPixel = 24,
 *          .colorSpace = NULL,
 *          .bitmapInfo = kCGImageAlphaNone | kCGBitmapByteOrderDefault };
 *  @/textblock</pre>
 *
 * To understand how these various parameters relate to one another, we can look at the process of converting from
 * one vImage_CGImageFormat format to another:
 *
 *  1) transform endianness of src format given by bitmapInfo to host endian  (except 8 bitPerComponent content)
 *  2) remove decode array transformation, and up convert to a higher range format as necessary to preserve precision / range
 *  3) convert src colorspace to reference XYZ colorspace (may cause upconvert to preserve range / precision)
 *  4) convert XYZ to destination colorspace + rendering intent
 *  5) convert to destination precision (given by bitsPerComponent)
 *  6) deal with any alpha changes (given by bitmapInfo) or flattening that needs to occur
 *  7) Apply any channel reordering requested, if it didn't happen at an earlier step. (As indicated by src and dest bitmapInfo)
 *  8) Apply destination decode array
 *  9) Apply endianness transform given by dest bitmapInfo
 *
 * Clearly, for most common transformations not all steps need to occur and multiple steps can be collapsed into a compound operation.
 *
 *  @field  bitsPerComponent    The number of bits needed to represent one channel of data in one pixel. For ARGB8888, this would be 8. Expected values: {1, 2, 4, 5, 8, 10, 12, 16, 32}
 *  @field  bitsPerPixel        The number of bits needed to represent one pixel. For ARGB8888, this would be 32.
 *                              It is possible that bitsPerPixel > bitsPerComponent * number of components, but in practice this is rare.
 *                              The number of color components is given by the colorspace and the number of alpha components (0 or 1) is given by
 *                              by the bitmapInfo.
 *  @field  colorSpace          A description of how the pixel data in the image is positioned relative to a reference XYZ color space.
 *                                  See CoreGraphics/CGColorSpace.h.  Pass NULL as a shorthand for sRGB. The vImage_CGImageFormat is not
 *                                  capable of managing the memory held by the colorSpace. If you created the colorspace, you must
 *                                  be sure to release it before all references to it disappear from scope.
 *  @field  bitmapInfo          The CGBitmapInfo describing the color channels. See CoreGraphics/CGImage.h.
 *                                  ARGB8888 is kCGImageAlphaFirst | kCGBitmapByteOrderDefault
 *                                  BGRA8888 is kCGImageAlphaFirst | kCGBitmapByteOrder32Little
 *  @field  version             The struct is versioned for future expansion.  Pass 0 here.
 *  @field  decode              Prior to transformations caused by the colorspace, color channels are subject to a linear transformation.
 *                              This allows for a different range than the typical [0,1.0]. NULL indicates default behavior of [0,1.0]
 *                              range, and is what you should use if you don't understand this parameter. See description of CGImageCreate()
 *                              for a discussion of decode arrays. See also Decode Arrays section of Chapter 4.8 of the PDF specification.
 *                              The vImage_CGImageFormat is not capable of managing the memory held by the decode array. If you created a
 *                              decode array on the heap, you must be sure to release it before all references to it disappear from scope.
 *
 *  @field renderingIntent      See CGColorSpace.h. kCGRenderingIntentDefault is typical here. By convention, rendering intent changes that
 *                              are not accompanied by a colorspace change are ignored.
 */
struct vImage_CGImageFormat {
  var bitsPerComponent: UInt32
  var bitsPerPixel: UInt32
  var colorSpace: Unmanaged<CGColorSpace>!
  var bitmapInfo: CGBitmapInfo
  var version: UInt32
  var decode: UnsafePointer<CGFloat>
  var renderingIntent: CGColorRenderingIntent
  init()
  init(bitsPerComponent: UInt32, bitsPerPixel: UInt32, colorSpace: Unmanaged<CGColorSpace>!, bitmapInfo: CGBitmapInfo, version: UInt32, decode: UnsafePointer<CGFloat>, renderingIntent: CGColorRenderingIntent)
}

/*!
*  @function vImageBuffer_Init
*  @abstract Convenience function to allocate a vImage_Buffer of desired size
*  @discussion This function is a convenience method to help initialize a vImage_Buffer struct with a buffer sized
*  and aligned for best performance. It will initialize the height, width and rowBytes fields, and allocate 
*  the pixel storage for you. You are responsible for releasing the memory pointed to by buf->data back to 
*  the system when you are done with it using free(). If no such allocation is desired, pass  
*  kvImageNoAllocate in the flags to cause buf->data to be set to NULL and the preferred alignment 
*  to be returned from the left hand side of the function.
*
*  Here is an example of typical usage:
*
*  <pre>@textblock
*      vImage_Buffer buf;
*      vImage_Error err = vImageBuffer_Init( &buf, height, width, 8 * sizeof(pixel), kvImageNoFlags);
*      ...
*  @/textblock</pre>
*
*  And typical usage using your own allocator (posix_memalign in this case):
*
*  <pre>@textblock
*      vImage_Buffer buf;
*      ssize_t alignment = vImageBuffer_Init( &buf, height, width, 8 * sizeof(pixel), kvImageNoAllocate);
*      if( alignment >= 0 )  // <0 is an error
*          error = posix_memalign( &buf.data, alignment, buf.height * buf.rowBytes );  // An allocator
*  @/textblock</pre>
*
*      On return, buf is initialized to contain the provided height and width and best rowBytes for the image.
*      buf->data will also be allocated by default. If kvImageNoAllocate is passed then allocation is skipped,
*      buf->data is set to NULL, and the preferred alignment is returned out the left hand side of the
*      function.
*
*  @param buf              A valid empty vImage_Buffer struct. On return, all fields will be initialized.
*                          Please see behavior of kvImageNoAllocate in the flags parameter below.
*
*  @param height           The desired height of the image
*  @param width            The desired width of the image
*
*  @param pixelBits        The number of bits in a pixel of image data. If the image is in a planar format
*                          then this is the number of bits per color component. If pixelBits is not divisible
*                          by 8, then vImage will pad the scanline out to a multiple of a byte so that
*                          two scanlines can not share the same byte and all scanlines start at the start of 
*                          a byte.
*
*  @param flags            Must be from the following list:
*
*  <pre>@textblock
*                          kvImageNoAllocate -- on return buf->data is initialized to NULL. A preferred
*                              alignment suitable for use with posix_memalign is returned out the left hand 
*                              side of the function and buf->rowBytes will be set to the preferred rowBytes. 
*                              If the left hand side return is negative, it is an error code, not a size. 
*                          
*                              If the kvImageNoAllocate flag is not passed, then on return buf->data will point 
*                              to a newly allocated buffer with preferred alignment and rowBytes. An appropriate 
*                              error code will be returned from the left hand side.
*
*                          kvImagePrintDiagnosticsToConsole -- directs the function to print diagnostic information
*                              to the console in the event of failure. 
*  @/textblock</pre>
*
*  @return  One of the following error codes will be returned out the left hand side.
*
*  <pre>@textblock
*      >0                              kvImageNoAllocate was passed. The value returned indicates the
*                                      preferred alignment (in bytes) for buf->data. buf->data is NULL.
*
*      kvImageNoError                  Success
*
*      kvImageMemoryAllocationError    you requested that buf->data be allocated but the allocation failed
*
*      kvImageUnknownFlagsBit          flags was not from the list above
*  @/textblock</pre>
*/
@available(OSX 10.9, *)
func vImageBuffer_Init(buf: UnsafeMutablePointer<vImage_Buffer>, _ height: vImagePixelCount, _ width: vImagePixelCount, _ pixelBits: UInt32, _ flags: vImage_Flags) -> vImage_Error

/*!
 *  @function vImageBuffer_GetSize
 *  @abstract Returns size of a vImage_Buffer as a CGSize.
 *  @discussion The CGSize / NSSize is rounded down to the nearest representable
 *  CGFloat that is less than or equal to the actual size of the image. In practice
 *  the conversion will always be exact, except for really, really big images. In
 *  that case, some part of the bottom or right edge might be truncated.
 *
 *  <pre>@textblock
 *  Rationale: If you attempt your own home-made conversion to CGSize / NSSize by
 *            ordinary C rules and the value rounds, it will round up half the time.
 *            This could lead to a crash later because the height or width
 *            will be reported to be larger than it really is and an ensuing image
 *            operation will attempt to touch scanlines that don't exist.
 *  @/textblock</pre>
 *
 *  @param buf  A pointer to a valid vImage_Buffer
 *
 *  @return  The largest CGSize that will fit in the buffer. In typical usage, this
 *           is equal to the size of the buffer.
 */
@available(OSX 10.9, *)
func vImageBuffer_GetSize(buf: UnsafePointer<vImage_Buffer>) -> CGSize

/*!
 * @function vImageCGImageFormat_GetComponentCount
 * @abstract Calculate the number of channels (color + alpha) for a given image format
 * @discussion  The number of channels may not be safely calculated as bitsPerPixel / bitsPerComponent.
 *              Use this routine instead. 
 * @param    format     A pointer to a valid vImage_CGImageFormat.  If format->colorspace is NULL,
 *                      the format is assumed to belong to the sRGB colorspace.
 *
 * @return   Returns the number of color + alpha channels in the image.
 */
@available(OSX 10.9, *)
func vImageCGImageFormat_GetComponentCount(format: UnsafePointer<vImage_CGImageFormat>) -> UInt32

/*!
 * @function vImageCGImageFormat_IsEqual
 * @abstract Test to see if two vImage_CGImageFormats are equivalent
 * @discussion Returns nonzero if two vImage_CGImageFormats are the same
 *              If either operand is NULL, the result is false.
 *              If vImage_CGImageFormat.colorSpace is NULL, sRGB is used.
 *
 * @param f1    A pointer to the first vImage_CGImageFormat
 * @param f2    A pointer to the second vImage_CGImageFormat
 *
 * @return  nonzero if two vImage_CGImageFormats are the same
 */
@available(OSX 10.9, *)
func vImageCGImageFormat_IsEqual(f1: UnsafePointer<vImage_CGImageFormat>, _ f2: UnsafePointer<vImage_CGImageFormat>) -> Bool

/*!
 * @function vImageBuffer_InitWithCGImage
 * @abstract Initialize a vImage_Buffer struct with the contents of a CGImageRef
 * @discussion This function will initialize a vImage_Buffer struct with an image from a CGImageRef.
 * By default, a new region of memory to hold the image data will be allocated by this function.  You may
 * optionally allocate the memory region yourself by passing in the kvImageNoAllocate flag. 
 *
 * You may release the CGImageRef and format->colorspace upon successful return of this function.
 *
 * You are responsible for returning the memory referenced by buf->data to the system using free() when you are done with it.
 * The CGImage may have other metadata associated with it, such as camera orientiation, which may require further
 * processing downstream.  vImage just does 1:1 pixel conversions from the raw image source.
 *
 *
 * To create a CGImageRef from a image file on disk:
 *
 *  <pre>@textblock
 *     CFURLRef path = ...;  // path to image
 *     CGImageSourceRef imageSource = CGImageSourceCreateWithURL( path, optionsDictionary ); // optionsDictionary may be NULL
 *     CGImageRef imageRef = CGImageSourceCreateImageAtIndex( imageSource, imageIndex, optionsDictionary );
 *  @/textblock</pre>
 *
 * Similarly, with a chunk of compressed image data in memory:
 *
 *  <pre>@textblock
 *     CFDataRef data = ...;
 *     CGImageSourceRef imageSource = CGImageSourceCreateWithData( path, optionsDictionary );
 *     CGImageRef imageRef = CGImageSourceCreateImageAtIndex( imageSource, imageIndex, optionsDictionary );
 *  @/textblock</pre>
 *
 * You can do similar things through AppKit / UIKit with [NSImage initWithContentsOfFile:],
 * [NSImage initWithContentsOfURL:], or [NSImage initWithData:],  and use [NSImage CGImageForProposedRect:context:hints:]
 * to get out a CGImageRef.
 *
 * @param buf   A pointer to a valid vImage_Buffer struct. The fields of the structure pointed to by buf will
 *              be updated to point to a vImage_Buffer representation of the CGImage. By default, a newly
 *              allocated piece of memory will be used to hold the image. You are responsible
 *              for releasing the memory pointed to by buf->data back to the system using free().
 *
 *                  If you want to allocate the buf->data and initialize rowBytes yourself, then you may pass 
 *                  kvImageNoAllocate in the flags parameter. This will cause the buf->data and rowBytes values  
 *                  passed into the function to be used directly without modification.  You may find vImageBuffer_Init,  
 *                  vImageCGImageFormat_GetPixelBits, CGImageGetWidth and CGImageGetHeight helpful in sizing your buffer.
 *
 * @param format  A pointer to a valid vImage_CGImageFormat specifying the desired image format associated with the 
 *                  output buf. If format->colorspace is NULL, sRGB will be used.
 *
 * @param backgroundColor If the CGImageRef encodes an alpha (or mask) and the output format does not have alpha then the
 *                  result will be flattened against a background color. See vImageConverter_CreateWithCGImageFormat
 *                  and functions like vImageFlatten_ARGB8888ToRGB888 for more on flattening. The background color here is
 *                  a series of values of range [0,1] interpreted according to the colorspace passed in format. Example: If 
 *                  the format encodes for a AGBR 8-bit image (kCGImageAlphaLast, kCGBitmapByteOrder32Little), then this would be
 *                  {red, green, blue}, the canonical ordering for a RGB colorspace, as an array of three CGFloats.  
 *                  If NULL is passed, an array full of zeros is used. The backgroundColor must have at least as many
 *                  CGFloats in it as the colorspace has color channels. See CGColorSpaceGetNumberOfComponents.
 *
 * @param image     A valid CGImageRef to be used as source data.
 *
 * @param flags     You may set the following flags:
 *
 *  <pre>@textblock
 *                  kvImageNoAllocate       the buf->data and buf->rowBytes values passed in are used without modification.
 *                                          This allows you to allocate your own buffer to hold the result. See buf description
 *                                          above.
 *
 *                  kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
 *
 *                  kvImageDoNoTile         It is possible that vImage will have to do an image format conversion from the
 *                                          image native format to the desired format. This will turn off multithreading for
 *                                          that step and any other vImage work that is multithreaded. Since any such conversions
 *                                          are likely happening outside your tiling engine, use of this flag here is 
 *                                          probably counterproductive. In rare cases, it might be valuable as a method to 
 *                                          leave unoccupied some cores for other tasks, if you have other multithreaded time 
 *                                          sensitive tasks running. Likewise, if you are converting multiple images concurrently,
 *                                          it might be helpful to avoid oversubscribing the system.
 *  @/textblock </pre>
 *
 *
 *  @return If the call succeeds, kvImageNoError is returned and the memory region pointed to by buf will be initialized to
 *      describe a valid repesentation of the CGImageRef. 
 *
 *      If the call fails, then one of the following error codes will be returned and buf->data will be set to NULL.
 *
 *  <pre>@textblock
 *          kvImageUnknownFlagsBit              flags must be kvImageNoFlags or kvImageNoAllocate
 *          kvImageMemoryAllocationError        Not enough memory to allocate buf->data 
 *          kvImageInvalidParameter             format->bitmapInfo has unknown bits set
 *          kvImageInvalidParameter             format->version is not 0
 *          kvImageInvalidParameter             format->decode is not NULL
 *          kvImageInvalidParameter             format->bitsPerComponent is not in {0,1,2,4,5,8,16,32}
 *          kvImageInvalidImageFormat           format->renderingIntent is not a known value
 *          kvImageInvalidImageFormat           The format called for conversion to an input-only colorspace. Some color profiles
 *                                              (e.g. those arising from a scanner) are described as input only, because the device can
 *                                              not produce image output.
 *          kvImageNullPointerArgument          format may not be NULL
 *          kvImageNullPointerArgument          image may not be NULL
 *          kvImageInternalError                Something unexpected went wrong. Please file a bug. 
 *  @/textblock </pre>
 *
 */
@available(OSX 10.9, *)
func vImageBuffer_InitWithCGImage(buf: UnsafeMutablePointer<vImage_Buffer>, _ format: UnsafeMutablePointer<vImage_CGImageFormat>, _ backgroundColor: UnsafePointer<CGFloat>, _ image: CGImage, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageCreateCGImageFromBuffer
 * @abstract Create a CGImageRef from a vImage_Buffer.
 * @discussion This function creates a CGImageRef using the image data in a vImage_Buffer. The CGImageRef has a retain count of 1.
 * By default, a copy of the image data is made. This allows the function to convert to a CG-friendly format as necessary
 * and allows you to continue to use the vImage_Buffer without causing problems for the CGImageRef. 
 *
 *  <pre>@textblock
 * No copy mode
 * ------------
 * When the kvImageNoAllocate flag is passed, then "no-copy" operation is said to occur. Ownership of the memory region  
 * pointed to by buf->data is transferred to the CGImageRef and it becomes private to and owned by that object and will 
 * be used without modification. The memory region pointed to by buf->data will be destroyed when the CGImageRef is 
 * destroyed. Caution: CGImageRefs are defined to be immutable once created. Behavior is undefined if you create
 * a CGImageRef then modify the pixels in its backing store.
 *
 * No-copy mode can be a little fussy about formats. When a format is rejected, kvImageInvalidImageFormat will be returned. 
 * Formats that are likely to succeed are 8-bit unsigned, 16-bit unsigned and 32-bit floating-point. The image should be 
 * kCGImageAlphaNone, kCGImageAlphaLast, kCGImageAlphaPremultipliedLast or kCGImageAlphaNoneSkipLast, and decode = NULL. 
 * The image should be in host endian mode. This is kCGBitmapByteOrderDefault for 8-bit per component images, and or larger 
 * types, the endianness is given by the endianness of the host system and the size is given by the size of the pixel 
 * (bitsPerComponent < 8) or channel (bitsPerComponent > 8). For example RGB565 data should be kCGBitmapByteOrder16Little 
 * and 32-bit floating point data should be kCGBitmapByteOrder32Little on little endian processors. 
 *
 * It is recommended that if no-copy mode fails, that you try again without the kvImageNoAllocate flag. The call probably 
 * will succeed.
 *  @/textblock </pre>
 *
 * CGImage Debugging Note:
 *      The format parameter describes the image data you pass in, but there is no requirement that this is the
 *      format that is actually used to represent the image data held by the CGImage. You should be able to get
 *      back the data in any format you like with vImageBuffer_InitWithCGImage. However, understand that if you
 *      request the data through another API like CGDataProviderCopyData(), it will be formatted as described by
 *      that API -- for CGDataProviderCopyData(), that would be as described by: CGImageGetBitmapInfo, CGImageGetDecode,
 *      CGImageGetRenderingIntent, CGImageGetColorSpace, CGImageGetBytesPerRow, CGImageGetBitsPerPixel,
 *      CGImageGetBitsPerComponent, etc.  Furthermore, the format that those APIs report is also not necessarily
 *      the format of the data held by the CGImageRef.  Common image data consumers like CoreAnimation and
 *      CoreGraphics have their format preferences and vImage caters to them in order to deliver good performance.
 *
 *      CGImageRefs can also be made from vImage_Buffers using CGImageCreate() and CGDataProviderCreateWithData().
 *
 *  @param buf             The vImage_Buffer from which to make the CGImageRef
 *
 *  @param format          The image format of the vImage_Buffer. format may not be NULL.  format->colorspace may be NULL,
 *                  in which case sRGB will be used.  The colorspace is retained as needed by the new CGImage.
 *
 *  @param callback        In no-copy mode, this callback is called to destroy the buf->data when the CGImageRef no longer needs it.
 *                  If NULL is passed for the callback, then free() will be used to destroy buf->data.  userData will be 
 *                  passed to the callback function as the userData parameter and buf->data passed as the buf_data parameter.
 *
 *                  This parameter has no effect if kvImageNoAllocate is not in flags. 
 *
 *                  The callback may be called at any time from any thread. It is possible for it to be called before 
 *                  vImageCreateCGImageFromBuffer returns.  
 *
 *                  The callback will not be called if the returned CGImageRef is NULL.
 *
 *  @param userData        The value to pass to the callbacks userData parameter. If callback is NULL or kvImageNoAllocate
 *                  is passed in flags, this value is ignored.  
 *                  
 *  @param flags           The following flags are allowed:
 *  <pre>@textblock
 *                  kvImageNoAllocate                   Causes vImageCreateCGImageFromBuffer to run in no-copy mode.
 *                                                      Ownership of the memory pointed to by buf->data is transferred 
 *                                                      to the CGImageRef.  You'll need to set up a callback and userData
 *                                                      to manage releasing the memory back to the system when the CGImage
 *                                                      is done with it.
 *
 *                  kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
 *
 *                  kvImageHighQualityResampling        Sometimes the system will ask for the image to be resamled to
 *                                                      a smaller size. If that happens vImageAffineWarp_<fmt>" will be
 *                                                      called. In that case, the value of this bit will be used to
 *                                                      determine whether Lanczos3 or Lanczos5 resampling is used.
 *
 *                  kvImageDoNotTile                    Disables multithreading in any conversions that need to be done.
 *                                                      Since it seems likely any such conversions will not be running in
 *                                                      the context of your tiling engine (if you wrote one) in this case, 
 *                                                      this flag is probably counterproductive in this context. Conversions
 *                                                      can happen later, after this call returns, when the image is drawn.
 *  @/textblock </pre>
 *  @param error           if not NULL, points to a more informative error code to describe what went wrong on exit. May be NULL.
 *                  Testing the result against NULL is sufficient to detect success or failure. kvImagePrintDiagnosticsToConsole
 *                  is another way to get error information.
 *
 * @return  On success, the returned CGImageRef will be non-NULL. If error is not NULL, kvImageNoError will be written there.
 *      On failure, NULL will be returned, and if error is not NULL, a more informative error code will be written there. 
 *          
 *  <pre>@textblock
 *  Error Values:
 *      kvImageUnknownFlagsBit              flags was not from the list described in the flags parameter above
 *      kvImageMemoryAllocationError        Not enough memory to allocate the new CGImageRef
 *      kvImageInvalidParameter             format->bitmapInfo has unknown bits set
 *      kvImageInvalidParameter             format->bitsPerComponent is not in {5,8,16,32}
 *      kvImageInvalidImageFormat           format->renderingIntent is not a known value
 *      kvImageNullPointerArgument          format may not be NULL
 *      kvImageNullPointerArgument          buf may not be NULL
 *  @/textblock </pre>
 *
 */
@available(OSX 10.9, *)
func vImageCreateCGImageFromBuffer(buf: UnsafePointer<vImage_Buffer>, _ format: UnsafePointer<vImage_CGImageFormat>, _ callback: (@convention(c) (UnsafeMutablePointer<Void>, UnsafeMutablePointer<Void>) -> Void)!, _ userData: UnsafeMutablePointer<Void>, _ flags: vImage_Flags, _ error: UnsafeMutablePointer<vImage_Error>) -> Unmanaged<CGImage>!

/*!
 *  @function vImageConverter_CreateWithCGImageFormat
 *  @abstract Create a vImageConverterRef to convert from ome vImage_CGImageFormat to another
 *  @discussion vImageConverter_CreateWithCGImageFormat creates a vImageConverter to convert between
 *              image formats describable with a vImage_CGImageFormat.  The vImageConverter is intended
 *              to be used (and reused, possibly reentrantly) with vImageConvert_AnyToAny() to convert 
 *              images from one format to another.
 *
 *  <pre>@textblock
 *  Image Format Notes:
 *      CG Integer images map the range [0,1.0] (black to full color intensity) to the range [0, TYPE_MAX]. A 8-bit unsigned image
 *  has a range [0,255] and a 16-bit signed image has a range [0,32767]. Floating point images map [0,1.0] to [0,1.0]. Some formats,
 *  like floating-point and signed integers are capable of representing values outside of that range. Conversions involving these
 *  formats will occasionally produce results outside of [0,1]. If the conversion causes a value to go out of the representable range
 *  for the underlying type, it will be clamped to the nearest representable value. This can happen in normal operation during color
 *  correction. You can clamp floating-point results back into [0,1] using vImageClip_PlanarF, if you like.
 *
 *      Usually, colors must be direct mapped. Indexed color is supported format->bitsPerComponent and format->.bitsPerPixel are 1,2,4
 *  or 8, and equal (i.e. grayscale) only. Indexed color is not supported for the destination image. Images with indexed color must use
 *  (kCGImageAlphaNone | kCGBitmapByteOrderDefault) as the bitmapInfo. It is usually faster with indexed color spaces to use
 *  vImageConvert_AnyToAny to convert the color table rather than the image itself when possible, because the table is usually much
 *  smaller than the image. vImageConvert_AnyToAny can not do that automatically for you behind the scenes because it does not return
 *  a modified colorspace.
 *
 *  Device Colorspaces:
 *  Because vImage has no concept of a rendering context or destination graphics device, vImage maps device RGB, device grayscale
 *  and device CMYK to a virtual device which is not your display. The virtual device uses kColorSyncGenericGrayGamma22Profile,
 *  kColorSyncSRGBProfile and kColorSyncGenericCMYKProfile respectively. If you want the image to be converted to the right colorspace
 *  for your display device, you will need to pass in the CGColorSpaceRef for that device obtained from an API like CGDisplayCopyColorSpace().
 *
 *  Black Point Compensation:
 *  By default, BPC is off for this function. If you want black point compensation or other advanced ColorSync effects, construct your
 *  own ColorSyncTransformRef and pass the associated "code fragment" to vImageConverter_CreateWithColorSyncCodeFragment.
 *  See Apple Sample Code "Converting an Image with Black Point Compensation" https://developer.apple.com/library/mac/samplecode/convertImage/Introduction/Intro.html
 *  @/textblock </pre>
 *
 *  See also vImageConverter_CreateForCGToCVImageFormat and vImageConverter_CreateForCVToCGImageFormat for converters
 *  that can operate on CoreVideo formats.
 *
 *  @param srcFormat    A pointer to a populated vImage_CGImageFormat struct describing the image format
 *                      of the source image. If the CGColorSpaceRef is NULL, sRGB will be used
 *                      as the default value. The CGColorSpaceRef will be retained by this function. It
 *                      will be released when the vImageConverter is destroyed.
 *
 *  @param destFormat   A pointer to a populated vImage_CGImageFormat struct describing the image format
 *                      of the destination image. If the CGColorSpaceRef is NULL, sRGB will be
 *                      used as the default value. The CGColorSpaceRef will be retained by this function.
 *                      It will be released when the vImageConverter is destroyed.
 *
 *  @param  backgroundColor Points to an array of floats to be used as a background color if one is needed. The
 *                      backgroundColor range is assumed to be [0,1]. The channel ordering and number of color 
 *                      channels must match the natural order of the destination colorSpace (e.g. RGB or CMYK). 
 *                      The backgroundColor may be NULL if no background color is needed. 
 *
 *                      A background color is used when the image is converted from an alpha-containing format 
 *                      to an alpha-none format, in which case the alpha is removed by compositing against the 
 *                      opaque background color pointed to by this parameter. If the image is instead converted 
 *                      from one alpha containing format to another, then the image will be premultiplied or 
 *                      unpremultiplied as necessary and no background color is necessary. (For unpremultiplication, 
 *                      the result color value for pixels with alpha 0 is 0.)  Likewise, when converting between
 *                      alpha-none formats, a background color is not use. In the case of kCGImageAlphaNone ->
 *                      kCGImageAlphaNoneSkipFirst/Last, the vacant alpha channel is filled in with 1.0. If NULL
 *                      is passed here, then 0 will be used for the color channels. 
 *
 *                      The vImageConverter will contain a copy of the data passed in this field.  
 *
 *  @param flags        Any of the following flags are allowed:
 *
 *  <pre>@textblock
 *           kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug
 *                                               messages.
 *
 *           kvImageDoNotTile                    A converter created with this flag will operate as if
 *                                               kvImageDoNotTile was passed to vImageConvert_AnyToAny
 *                                               whether it was or not.
 *  @/textblock </pre>
 *
 *  @param error        May be NULL.  If not NULL, then a vImage_Error is returned at the address pointed to by error. 
 *                      The vImage_Error will be less than 0 if an error condition occurred. Checking the vImageConverter 
 *                      returned to make sure it is non-NULL is sufficient to verify success or failure of the function.
 *
 *                      The following error values can occur:
 *  <pre>@textblock
 *      kvImageNoError                      Success.
 *
 *      kvImageNullPointerArgument          srcFormat and/or destFormat is NULL.
 *
 *      kvImageUnknownFlagsBit              Currently only kvImagePrintDiagnosticsToConsole and kvImageDoNotTile are
 *                                          allowed. All other bits in the flags field must be 0.
 *
 *      kvImageInvalidParameter             backgroundColor is NULL and the conversion needed a backgroundColor
 *
 *      kvImageInvalidImageFormat           bitsPerComponent must be in {1,2,4,5,8,12,16,32}.
 *      kvImageInvalidImageFormat           The base colorspace must be grayscale for destination images using indexed color.
 *      kvImageInvalidImageFormat           The colorspace may be indexed color for images only if it is {1,2,4,8} bitsPerComponent
 *                                          and kCGImageAlphaNone.
 *      kvImageInvalidImageFormat           vImage_CGImageFormat.bitmapInfo & kCGBitmapAlphaInfoMask  does not encode a valid alpha
 *      kvImageInvalidImageFormat           floating point formats must be 16 or 32 bits per component. 16-bit floats are
 *                                          IEEE-754-2008 binary16 interchange format  (a.k.a. OpenEXR half float). 32-bit floats
 *                                          are the standard IEEE-754-2008 binary32 interchange format. (a.k.a float in C/C++/ObjC)
 *      kvImageInvalidImageFormat           format->renderingIntent is not a known value
 *      kvImageInvalidImageFormat           The conversion called for conversion to an input-only colorspace. Some color profiles
 *                                          (e.g. those arising from a scanner) are described as input only, because the device can
 *                                          not produce image output.
 *
 *      kvImageInternalError                The converter was unable to find a path from the source format to the destination format.
 *                                          This should not happen and indicates incorrect operation of the function. Please file a bug.
 *                                          The kvImagePrintDiagnosticsToConsole flag will provide additional diagnostic info.
 *  @/textblock </pre>
 *
 *          In cases where the error code is not sufficient to quickly determine the problem, the kvImagePrintDiagnosticsToConsole flag
 *          should provide additional diagnostic info.
 *
 *  @return  A vImageConverter object with reference count of 1 is created. If the call fails due to an error, then NULL
 *  will be returned. Use vImageConverter_Release to release your reference to it and allow the resources used
 *  by the converter to be returned to the system.
 *
 *  If error is not NULL, an error code will be written to that address on return.
 */
@available(OSX 10.9, *)
func vImageConverter_CreateWithCGImageFormat(srcFormat: UnsafePointer<vImage_CGImageFormat>, _ destFormat: UnsafePointer<vImage_CGImageFormat>, _ backgroundColor: UnsafePointer<CGFloat>, _ flags: vImage_Flags, _ error: UnsafeMutablePointer<vImage_Error>) -> Unmanaged<vImageConverter>!

/*!
 * @function vImageConverter_CreateWithColorSyncCodeFragment
 * @abstract Create a vImageConverterRef substituting in a custom ColorSync transform for the one vImage usually generates for the color conversion steps.
 * @discussion vImageConverter_CreateWithColorSyncCodeFragment is like vImageConverter_CreateWithCGImageFormat, except that
 *  instead of creating its own colorspace transform for any colorspace conversions, it uses the one you pass in.
 *  This gives you greater control over the fine details of colorspace conversion, for exacting color fidelity.
 *  The colorspaces for source and destination images must refer to colorspaces that have the same number of channels
 *  as the codeFragment is designed to accept / produce.
 *
 *  See Apple Sample Code "Converting an Image with Black Point Compensation" https://developer.apple.com/library/mac/samplecode/convertImage/Introduction/Intro.html
 *  for an example of usage.
 *
 *  @param codeFragment A code fragment created with ColorSyncTransformCopyProperty( kColorSyncTransformFullConversionData,
 *                      kColorSyncTransformParametricConversionData or kColorSyncTransformSimplifiedConversionData)
 *                      May be NULL.  If NULL, no colorspace conversion / correction is done. In this case,
 *                      behavior is undefined if the colorspaces do not have the same channel order or have a
 *                      different number of channels or the colorspaces are not from the same family.
 *                      kColorSyncTransformFullConversionData is required for black point compensation.
 *                      CAUTION: vImageConverter_CreateWithColorSyncCodeFragment does not verify that the
 *                      codeFragment is actually appropriate for the srcFormat and destFormat provided. Nor
 *                      does it attempt to append additional color space transformation steps to make the 
 *                      codeFragment appropriate to the images provided. If the colorspace of the srcFormat 
 *                      and destFormat do not correspond to the ColorSyncProfileRefs used to create the 
 *                      ColorSync transform in at least colorspace model, then the behavior is undefined. 
 *                      See CGColorSpaceModel CoreGraphics/CGColorSpace.h
 *
 *  @param srcFormat    A pointer to a populated vImage_CGImageFormat struct describing the image format
 *                      of the source image. If the CGColorSpaceRef is NULL, sRGB will be used
 *                      as the default value. The CGColorSpaceRef will be retained by this function. It
 *                      will be released when the vImageConverter is destroyed.
 *
 *  @param destFormat   A pointer to a populated vImage_CGImageFormat struct describing the image format
 *                      of the destination image. If the CGColorSpaceRef is NULL, sRGB will be
 *                      used as the default value. The CGColorSpaceRef will be retained by this function.
 *                      It will be released when the vImageConverter is destroyed.
 *
 *  @param  backgroundColor Points to an array of floats to be used as a background color if one is needed. The
 *                      backgroundColor range is assumed to be [0,1]. The channel ordering and number of color
 *                      channels must match the natural order of the destination colorSpace (e.g. RGB or CMYK).
 *                      The backgroundColor may be NULL if no background color is needed.
 *
 *                      A background color is used when the image is converted from an alpha-containing format
 *                      to an alpha-none format, in which case the alpha is removed by compositing against the
 *                      opaque background color pointed to by this parameter. If the image is instead converted
 *                      from one alpha containing format to another, then the image will be premultiplied or
 *                      unpremultiplied as necessary and no background color is necessary. (For unpremultiplication,
 *                      the result color value for pixels with alpha 0 is 0.)  Likewise, when converting between
 *                      alpha-none formats, a background color is not use. In the case of kCGImageAlphaNone ->
 *                      kCGImageAlphaNoneSkipFirst/Last, the vacant alpha channel is filled in with 1.0. If NULL
 *                      is passed here, then 0 will be used for the color channels.
 *
 *                      The vImageConverter will contain a copy of the data passed in this field.
 *
 *  @param flags        Any of the following flags are allowed:
 *
 *  <pre>@textblock
 *           kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug
 *                                               messages.
 *
 *           kvImageDoNotTile                    A converter created with this flag will operate as if
 *                                               kvImageDoNotTile was passed to vImageConvert_AnyToAny
 *                                               whether it was or not.
 *  @/textblock </pre>
 *
 *  @param error        May be NULL.  If not NULL, then a vImage_Error is returned at the address pointed to by error.
 *                      The vImage_Error will be less than 0 if an error condition occurred. Checking the vImageConverter
 *                      returned to make sure it is non-NULL is sufficient to verify success or failure of the function.
 *
 *                      The following error values can occur:
 *  <pre>@textblock
 *      kvImageNoError                      Success.
 *
 *      kvImageNullPointerArgument          srcFormat and/or destFormat is NULL.
 *
 *      kvImageUnknownFlagsBit              Currently only kvImagePrintDiagnosticsToConsole and kvImageDoNotTile are
 *                                          allowed. All other bits in the flags field must be 0.
 *
 *      kvImageInvalidParameter             backgroundColor is NULL and the conversion needed a backgroundColor
 *
 *      kvImageInvalidImageFormat           bitsPerComponent must be in {1,2,4,5,8,12,16,32}.
 *      kvImageInvalidImageFormat           The base colorspace must be grayscale for destination images using indexed color.
 *      kvImageInvalidImageFormat           The colorspace may be indexed color for images only if it is {1,2,4,8} bitsPerComponent
 *                                          and kCGImageAlphaNone.
 *      kvImageInvalidImageFormat           vImage_CGImageFormat.bitmapInfo & kCGBitmapAlphaInfoMask  does not encode a valid alpha
 *      kvImageInvalidImageFormat           floating point formats must be 16 or 32 bits per component. 16-bit floats are
 *                                          IEEE-754-2008 binary16 interchange format  (a.k.a. OpenEXR half float). 32-bit floats
 *                                          are the standard IEEE-754-2008 binary32 interchange format. (a.k.a float in C/C++/ObjC)
 *      kvImageInvalidImageFormat           format->renderingIntent is not a known value
 *      kvImageInvalidImageFormat           The conversion called for conversion to an input-only colorspace. Some color profiles
 *                                          (e.g. those arising from a scanner) are described as input only, because the device can
 *                                          not produce image output.
 *
 *      kvImageInvalidImageFormat           codeFragment was found to be otherwise invalid / unusable
 *
 *      kvImageInternalError                The converter was unable to find a path from the source format to the destination format.
 *                                          This should not happen and indicates incorrect operation of the function. Please file a bug.
 *                                          The kvImagePrintDiagnosticsToConsole flag will provide additional diagnostic info.
 *  @/textblock </pre>
 *
 *          In cases where the error code is not sufficient to quickly determine the problem, the kvImagePrintDiagnosticsToConsole flag
 *          should provide additional diagnostic info.
 *
 *  @return  A vImageConverter object with reference count of 1 is created. If the call fails due to an error, then NULL
 *  will be returned. Use vImageConverter_Release to release your reference to it and allow the resources used
 *  by the converter to be returned to the system.
 *
 *  If error is not NULL, an error code will be written to that address on return.
 *
 */
@available(OSX 10.9, *)
func vImageConverter_CreateWithColorSyncCodeFragment(codeFragment: AnyObject, _ srcFormat: UnsafePointer<vImage_CGImageFormat>, _ destFormat: UnsafePointer<vImage_CGImageFormat>, _ backgroundColor: UnsafePointer<CGFloat>, _ flags: vImage_Flags, _ error: UnsafeMutablePointer<vImage_Error>) -> Unmanaged<vImageConverter>!

/*!
 * @function  vImageConverter_MustOperateOutOfPlace
 * @abstract  Determine whether a converter is capable of operating in place. 
 * @discussion  Some conversions will work if the src and destination image buffer
 *              scanlines start at the same address. Others will not. In such cases, 
 *              you need to allocate additional storage to hold the destination buffer.
 *              This function returns kvImageOutOfPlaceOperationRequired if the conversion 
 *              requires out of place operation. 
 *
 *  <pre>@textblock
 *       In-place operation is considered to mean srcs[i].data = dests[i].data
 *       and srcs[i].rowBytes = dests[i].rowBytes. Other styles of partial buffer
 *       overlap produce undefined behavior.
 *  @/textblock </pre>
 *
 *  The list of source and destination buffers is optional. Results are as follows:
 *
 *  <pre>@textblock
 *      srcs = dests = NULL         kvImageNoError if any conversion with this converter is guaranteed to work in place,
 *                                  provided that srcs[i].data = dests[i].data and srcs[i].rowBytes = dests[i].rowBytes.
 *                                  If there exists at least one combination of height and width for which in place operation
 *                                  is not possible with this converter, then kvImageOutOfPlaceOperationRequired will be returned. 
 *
 *      srcs != NULL, dests = NULL  kvImageNullPointerArgument
 *      srcs = NULL, dests != NULL  kvImageNullPointerArgument
 *  
 *      srcs != NULL, dests != NULL kvImageNoError if the conversion will successfully operate in place for this particular 
 *                                  combination of heights, widths and rowBytes. In this case, vImage does not check to see if the 
 *                                  buffers overlap. It presumes that srcs[i].data = dests[i].data.  This is intended to allow 
 *                                  you to defer allocation until later.  If in place operation will not work, then 
 *                                  kvImageOutOfPlaceOperationRequired is returned. 
 *  @/textblock </pre>
 *
 *  In no case during this function call does vImage examine the contents of the memory pointed to by srcs[i].data or dests[i].data. 
 *
 *  @param converter           The converter to check
 *
 *  @param srcs                The list of source buffers you plan to use with vImageConvert_AnyToAny. May be NULL.
 *  @param dests               The list of destination buffers you plan to use with vImageConvert_AnyToAny. May be NULL.
 *
 *  @param flags               The flags you plan to pass to vImageConvert_AnyToAny.
 *
 *  <pre>@textblock
 *                              Note: in the case of kvImagePrintDiagnosticsToConsole, the flag means print
 *                              error information to the console for errors caught by vImageConverter_MustOperateOutOfPlace,  
 *                              not vImageConvert_AnyToAny. At times, vImageConverter_MustOperateOutOfPlace may fail because 
 *                              it detects an error condition that would cause vImageConvert_AnyToAny to fail.
 *  @/textblock </pre>
 *
 *  @return Error Codes:
 *  <pre>@textblock
 *      kvImageNoError                      In-place operation will work
 *      kvImageNullPointerArgument          The converter may not be NULL
 *      kvImageNullPointerArgument          srcs and dests must either both be NULL or neither must be NULL. 
 *      kvImageInvalidParameter             The converter is invalid
 *      kvImageUnknownFlagsBit              An unknown / unsupported flag was used
 *      kvImageOutOfPlaceOperationRequired  vImageConvert_AnyToAny requires separate buffers be used for this operation
 *  @/textblock </pre>
 */
@available(OSX 10.9, *)
func vImageConverter_MustOperateOutOfPlace(converter: vImageConverter, _ srcs: UnsafePointer<vImage_Buffer>, _ dests: UnsafePointer<vImage_Buffer>, _ flags: vImage_Flags) -> vImage_Error

/*!
 * @function vImageConverter_GetNumberOfSourceBuffers
 * @abstract Get the number of source buffers consumed by the converter.
 * @discussion  All formats discribed by a vImage_CGImageFormat just consume one vImage_Buffer
 *              and produce one vImage_Buffer. There are no multi-plane vImage_CGImageFormats.
 *              However, some video formats (see vImage/vImage_CVUtilities) have planar 
 *              data formats with data in more than one plane. For such conversions, it may be
 *              necessary to know how many input buffers are consumed by a converter.
 *
 *              For older operating systems, where these functions are not available, 
 *              the number of source and destination buffers is always 1.
 *
 * @param converter The conversion for which you wish to know the number of source buffers
 *
 * @return On success, the number of source buffers is returned.  On failure, 0 is returned.
 */
@available(OSX 10.10, *)
func vImageConverter_GetNumberOfSourceBuffers(converter: vImageConverter) -> UInt

/*!
 * @function vImageConverter_GetNumberOfDestinationBuffers
 * @abstract Get the number of destination buffers written to by the converter.
 * @discussion  All formats discribed by a vImage_CGImageFormat just consume one vImage_Buffer
 *              and produce one vImage_Buffer. There are no multi-plane vImage_CGImageFormats.
 *              However, some video formats (see vImage/vImage_CVUtilities) have planar
 *              data formats with data in more than one plane. For such conversions, it may be
 *              necessary to know how many out buffers are overwritten by a converter.
 *
 *              For older operating systems, where these functions are not available,
 *              the number of source and destination buffers is always 1.
 *
 * @param converter The conversion for which you wish to know the number of result buffers
 *
 * @return On success, the number of result buffers is returned.  On failure, 0 is returned.
 */
@available(OSX 10.10, *)
func vImageConverter_GetNumberOfDestinationBuffers(converter: vImageConverter) -> UInt

/*!
 * @enum vImageBufferTypeCode
 *
 * @abstract Type codes for what is in a vImage_Buffer, such as red or luminance or chunky
 *
 * @discussion In rare circumstances, it may be necessary to introspect a vImageConverterRef that consumes
 *             or produces multiple image planes to find out which color channels go into which planes.
 *             See vImageConverter_GetSourceBufferOrder and vImageConverter_GetDestinationBufferOrder.
 *             (This is typically only necessary with video content, because no CG formatted buffers have
 *             multiple planes.)  The vImageBufferTypeCode encodes what kind of data goes into each channel.
 *
 * @constant kvImageBufferTypeCode_Alpha  The buffer contains the alpha channel / coverage component
 *
 * @constant kvImageBufferTypeCode_Indexed  The buffer contains data in an indexed colorspace. This is a 
 *                      planar buffer that is used to index a lookup table of color values. The color 
 *                      values in the table may belong to more than one color component.  Typically the
 *                      colorspace will have a color model of kCGColorSpaceModelIndexed and you will need 
 *                      use CGColorSpaceGetBaseColorSpace to find out what to what color model the lookup
 *                      table maps.
 *
 * @constant kvImageBufferTypeCode_CVPixelBuffer_YCbCr  The buffer contains luminance, and both chroma channels
 *                      interleaved according to the vImageConstCVImageFormatRef image type.
 *
 * @constant kvImageBufferTypeCode_Luminance   The buffer contains only luminance data. 
 *
 * @constant kvImageBufferTypeCode_Chroma       The buffer contains both chrominance channels, interleaved.
 *
 * @constant kvImageBufferTypeCode_Cb           The buffer contains the blue chrominance channel
 *
 * @constant kvImageBufferTypeCode_Cr           The buffer contains the red chrominance channel
 *
 * @constant kvImageBufferTypeCode_CGFormat     The buffer contains data describable as a vImage_CGImageFormat as 
 *                                              a single (likely chunky) buffer
 *
 * @constant kvImageBufferTypeCode_Chunky       The buffer contains chunky data not describable as a vImage_CGImageFormat.
 *
 * @constant kvImageBufferTypeCode_RGB_Red      If the image has a RGB color model, the buffer contains the red channel.
 *
 * @constant kvImageBufferTypeCode_RGB_Green    If the image has a RGB color model, the buffer contains the green channel.
 *
 * @constant kvImageBufferTypeCode_RGB_Blue     If the image has a RGB color model, the buffer contains the blue channel.
 *
 * @constant kvImageBufferTypeCode_CMYK_Cyan    If the image has a CMYK color model, the buffer contains the cyan channel.
 *
 * @constant kvImageBufferTypeCode_CMYK_Magenta If the image has a CMYK color model, the buffer contains the magenta channel.
 *
 * @constant kvImageBufferTypeCode_CMYK_Yellow  If the image has a CMYK color model, the buffer contains the yellow channel.
 *
 * @constant kvImageBufferTypeCode_CMYK_Black   If the image has a CMYK color model, the buffer contains the black channel.
 *
 * @constant kvImageBufferTypeCode_XYZ_X        If the image has a XYZ color model, the buffer contains the X channel.
 *
 * @constant kvImageBufferTypeCode_XYZ_Y        If the image has a XYZ color model, the buffer contains the Y channel.
 *
 * @constant kvImageBufferTypeCode_XYZ_Z        If the image has a XYZ color model, the buffer contains the Z channel.
 *
 * @constant kvImageBufferTypeCode_LAB_L        If the image has a LAB color model, the buffer contains the L* channel.
 *
 * @constant kvImageBufferTypeCode_LAB_A        If the image has a LAB color model, the buffer contains the a* channel.
 *
 * @constant kvImageBufferTypeCode_LAB_B        If the image has a LAB color model, the buffer contains the b* channel.
 */
typealias vImageBufferTypeCode = UInt32
var kvImageBufferTypeCode_EndOfList: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel1: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel2: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel3: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel4: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel5: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel6: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel7: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel8: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel9: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel10: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel11: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel12: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel13: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel14: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel15: Int { get }
var kvImageBufferTypeCode_ColorSpaceChannel16: Int { get }
var kvImageBufferTypeCode_Alpha: Int { get }
var kvImageBufferTypeCode_Indexed: Int { get }
var kvImageBufferTypeCode_CVPixelBuffer_YCbCr: Int { get }
var kvImageBufferTypeCode_Luminance: Int { get }
var kvImageBufferTypeCode_Chroma: Int { get }
var kvImageBufferTypeCode_Cb: Int { get }
var kvImageBufferTypeCode_Cr: Int { get }
var kvImageBufferTypeCode_CGFormat: Int { get }
var kvImageBufferTypeCode_Chunky: Int { get }
var kvImageBufferTypeCode_UniqueFormatCount: Int { get }
var kvImageBufferTypeCode_Monochrome: Int { get }
var kvImageBufferTypeCode_RGB_Red: Int { get }
var kvImageBufferTypeCode_RGB_Green: Int { get }
var kvImageBufferTypeCode_RGB_Blue: Int { get }
var kvImageBufferTypeCode_CMYK_Cyan: Int { get }
var kvImageBufferTypeCode_CMYK_Magenta: Int { get }
var kvImageBufferTypeCode_CMYK_Yellow: Int { get }
var kvImageBufferTypeCode_CMYK_Black: Int { get }
var kvImageBufferTypeCode_XYZ_X: Int { get }
var kvImageBufferTypeCode_XYZ_Y: Int { get }
var kvImageBufferTypeCode_XYZ_Z: Int { get }
var kvImageBufferTypeCode_LAB_L: Int { get }
var kvImageBufferTypeCode_LAB_A: Int { get }
var kvImageBufferTypeCode_LAB_B: Int { get }

/*!
 *  @function vImageConverter_GetSourceBufferOrder
 *
 *  @abstract Get a list of vImage_Buffer channel names specifying the order of planes
 *
 *  @discussion These functions describe the identity of each buffer passed in the srcs parameters of vImageConvert_AnyToAny,
 *  to allow you to order the buffers correctly. It is provided for informational purposes, to help wire up image 
 *  processing pipelines to vImage that are not supported through more direct means, CGImages, CVPixelBuffers, the alternative
 *  handling of which is described at the end of this comment.
 *
 *  Prior to OS X.10 and iOS 8.0, only CG Image formats are handled by vImageConvert_AnyToAny. Had these functions existed
 *  then, the result would always be {kvImageBufferTypeCode_CGFormat, kvImageBufferTypeCode_EndOfList}
 *
 *  <pre>@textblock
 *  Simplified Common Cases
 *  -----------------------
 *    CGImageRefs:
 *      CoreGraphics formats always come as a single buffer, with one or more channels. No buffer ordering is
 *      requred. The buffer order is always kvImageBufferTypeCode_CGFormat. Prior to OS X.10 and iOS 8.0, only
 *      converters to CG image formats are available, so where these functions are not available, the answer would
 *      have always been { kvImageBufferTypeCode_CGFormat, 0}. As a point of trivia, the ordering of the channels
 *      within a buffer is by convention as follows:
 *
 *              number of channels = number of channels in colorspace + (alpha != kCGImageAlphaNone)
 *              alpha is either first or last, given by the alpha component of the CGBitmapInfo
 *              The ordering of the non-alpha channels is given by the colorspace, e.g. {R,G,B} for a RGB image.
 *              For 8-bit images, the ordering of the channels may be reversed according to
 *                  kCGBitmapByteOrderLittleEndian32 or kCGBitmapByteOrderLittleEndian16, but
 *                  the pixel size must match the endian swap chunk size. This gives you access to formats
 *                  like BGRA8888. If the endian is default or big endian, then no swap occurs.
 *
 *    CVPixelBufferRefs:
 *      Though these APIs will work for this purpose, it is expected to be simpler to use vImageBuffer_InitForCopyToCVPixelBuffer
 *      or vImageBuffer_InitForCopyFromCVPixelBuffer to set up a vImage_Buffer array for srcs and dests. Pass kvImageDoNotAllocate
 *      to have it automatically alias a locked CVPixelBuffer. The conversion will then copy the data right into or out of the
 *      CVPixelBuffer without further copying or modification.  (It may still need to be copied out to the GPU, for example, however.)
 *
 *  @/textblock</pre>
 *
 *  @param converter       The conversion for which you wish to know the ordering of source or result buffers.
 *                      converter must be a valid vImageConverterRef.
 *
 *
 *  @return The function returns a kvImageBufferTypeCode_EndOfList terminated array of buffer type codes. The type codes
 *  indicate the order that the vImage_Buffers are passed in to vImageConvert_AnyToAny. The array is valid for the
 *  lifetime of the vImageConverterRef.  It belongs to the vImageConverterRef and should not be freed by you.
 */
@available(OSX 10.10, *)
func vImageConverter_GetSourceBufferOrder(converter: vImageConverter) -> UnsafePointer<vImageBufferTypeCode>

/*!
 *  @function vImageConverter_GetDestinationBufferOrder
 *
 *  @abstract Get a list of vImage_Buffer channel names specifying the order of planes
 *
 *  @discussion These functions describe the identity of each buffer passed in the dests parameters of vImageConvert_AnyToAny,
 *  to allow you to order the buffers correctly. It is provided for informational purposes, to help wire up image
 *  processing pipelines to vImage that are not supported through more direct means, CGImages, CVPixelBuffers, the alternative
 *  handling of which is described at the end of this comment.
 *
 *  Prior to OS X.10 and iOS 8.0, only CG Image formats are handled by vImageConvert_AnyToAny. Had these functions existed
 *  then, the result would always be {kvImageBufferTypeCode_CGFormat, kvImageBufferTypeCode_EndOfList}
 *
 *  <pre>@textblock
 *  Simplified Common Cases
 *  -----------------------
 *    CGImageRefs:
 *      CoreGraphics formats always come as a single buffer, with one or more channels. No buffer ordering is
 *      requred. The buffer order is always kvImageBufferTypeCode_CGFormat. Prior to OS X.10 and iOS 8.0, only
 *      converters to CG image formats are available, so where these functions are not available, the answer would
 *      have always been { kvImageBufferTypeCode_CGFormat, 0}. As a point of trivia, the ordering of the channels
 *      within a buffer is by convention as follows:
 *
 *              number of channels = number of channels in colorspace + (alpha != kCGImageAlphaNone)
 *              alpha is either first or last, given by the alpha component of the CGBitmapInfo
 *              The ordering of the non-alpha channels is given by the colorspace, e.g. {R,G,B} for a RGB image.
 *              For 8-bit images, the ordering of the channels may be reversed according to
 *                  kCGBitmapByteOrderLittleEndian32 or kCGBitmapByteOrderLittleEndian16, but
 *                  the pixel size must match the endian swap chunk size. This gives you access to formats
 *                  like BGRA8888. If the endian is default or big endian, then no swap occurs.
 *
 *    CVPixelBufferRefs:
 *      Though these APIs will work for this purpose, it is expected to be simpler to use vImageBuffer_InitForCopyToCVPixelBuffer
 *      or vImageBuffer_InitForCopyFromCVPixelBuffer to set up a vImage_Buffer array for srcs and dests. Pass kvImageDoNotAllocate
 *      to have it automatically alias a locked CVPixelBuffer. The conversion will then copy the data right into or out of the
 *      CVPixelBuffer without further copying or modification.  (It may still need to be copied out to the GPU, for example, however.)
 *
 *  @/textblock</pre>
 *
 *  @param converter       The conversion for which you wish to know the ordering of source or result buffers.
 *                      converter must be a valid vImageConverterRef.
 *
 *
 *  @return The function returns a kvImageBufferTypeCode_EndOfList terminated array of buffer type codes. The type codes
 *  indicate the order that the vImage_Buffers are passed in to vImageConvert_AnyToAny. The array is valid for the
 *  lifetime of the vImageConverterRef. It belongs to the vImageConverterRef and should not be freed by you.
 */
@available(OSX 10.10, *)
func vImageConverter_GetDestinationBufferOrder(converter: vImageConverter) -> UnsafePointer<vImageBufferTypeCode>

/*!
 *  @function vImageConvert_AnyToAny
 *
 *  @abstract Use a vImageConverterRef to convert the pixels in a vImage_Buffer to another format
 *
 *  @discussion With an appropriately configured vImageConverter, convert the image channels found in srcs
 *  to the image channels found in dests. Whenever possible, conversion passes are vectorized and multithreaded
 *  to reduce the time and energy cost of the function.
 *
 *  Please use vImageConverter_MustOperateOutOfPlace() to determine whether a particular conversion can operate in place.
 *  For an in-place conversion to work, it is required that srcs[i].data = dests[i].data and srcs[i].rowBytes = dests[i].rowBytes.
 *
 *  All scanlines must start at an at least byte aligned address. (Some formats have 1, 2, 4 or 12 bits per channel/pixel and
 *  conceivably might not start at a byte aligned address.) A single byte may not span multiple rows of data. 
 *
 *  Some formats, particarly YUV 422 and 420 and those that have pixel size not evenly divisble by 8 bits, operate in chunks 
 *  containing multiple pixels. For example, a Y'CbCr 422 chunk may have {Y0, Cb, Y1, Cr} in the chunk. The chunk contains two
 *  pixels, each with an independent Y (luminance) component, but shared chrominance.  Even though the chunk width is two, 
 *  it is still possible for an image to have a width that is not divisible by two. This means that some part of the chunk on
 *  the rightmost edge of the scanline must refer to a non-existant pixel. When reading incomplete chunks, vImage will only
 *  touch the unused parts of the chunk when it knows it to be safe to do so. When writing incomplete chunks, vImage will 
 *  copy the rightmost valid pixel color into the unused part of the chunk. Thus, on reading the entire chunk doesn't have to
 *  be there, but on writing, it does. Conventions on this are varied among chunk using imaging pipelines and this conservative
 *  approach should interoperate with most. However, some care must be exercised when writing to chunk based formats (not to be
 *  confused with chunky formats which merely have several channels interleaved) to make sure that the buffer is large enough
 *  to tolerate the write policy.  If you are tiling chunk based data, care must be taken not to run tile boundaries 
 *  through the middle of a chunk.  Chunks are assumed to be indivisible.
 *
 *  @param converter  A valid vImageConverterRef indicating what conversion to do. The same vImageConverterRef
 *                  may be used concurrently from multiple threads. vImageConverterRefs may be created with
 *                  vImageConverter_CreateWithCGImageFormat, vImageConverter_CreateWithColorSyncCodeFragment,
 *                  vImageConverter_CreateForCGToCVImageFormat or vImageConverter_CreateForCVToCGImageFormat.
 *                  May not be NULL.
 *
 *  @param srcs     a pointer to an array of vImage_Buffer structs that describe the color planes that make
 *                  up the input image. Please see the description of the function that created the
 *                  vImageConverter for the ordering and number of input buffers. The ordering can also be
 *                  determined manually using vImageConverter_GetSourceBufferOrder.
 *
 *  @param dests    a pointer to an array of vImage_Buffer structs that describe the color planes that make
 *                  up the result image. Please see the description of the function that created the
 *                  vImageConverter for the ordering and number of output buffers. The ordering can also be
 *                  determined manually using vImageConverter_GetSourceBufferOrder. The destination buffer may
 *                  only alias the srcs buffers only if vImageConverter_MustOperateOutOfPlace() returns 0, and
 *                  only if the respective scanlines of the aliasing buffers start at the same address.
 *
 *  @param tempBuffer   May be NULL. If not NULL, the memory pointed to by tempBuffer will be used as scratch space
 *                  by the function. The size of the tempBuffer can be determined by passing kvImageGetTempBufferSize
 *                  to the in the flags parameter. See below. If NULL is passed here and a tempBuffer is needed '
 *                  (temp buffer size > 0) then the function will allocate one on the heap and free it before
 *                  returning. This may run more slowly, both because of the allocation cost and the cost of VM
 *                  faults to zero fill pages as they are used. NULL is the right option when the function is
 *                  used infrequently or convenience is valued.
 *
 *  @param flags    The following flags are allowed. Other flags will trigger an error.
 *
 *  <pre>@textblock
 *                  kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
 *
 *                  kvImageGetTempBufferSize            No image conversion work is done. The value returned out the
 *                                                      left hand side of the function is the an error code if it is
 *                                                      less than zero. Otherwise, it is the size of the tempBuffer
 *                                                      to be passed into the function. The size may be 0.
 *
 *                  kvImageDoNotTile                    Disables internal multithreading.  You may wish to pass this
 *                                                      flag if you are doing your own threading and think it will
 *                                                      conflict with vImage's attempts to do the same.
 *
 *                  kvImageNoFlags                      Default behavior.
 *  @/textblock </pre>
 *
 *  @return  The following error codes may be returned:
 *  <pre>@textblock
 *      kvImageNoError                      Success!
 *
 *      0                                   kvImageGetTempBufferSize was passed in flags, and no temp buffer is needed.
 *
 *      >0                                  kvImageGetTempBufferSize was passed in flags. The value indicates the size
 *                                          of the temp buffer needed.
 *
 *      kvImageMemoryAllocationError        NULL was passed in tempBuffer and vImage failed to allocate its own
 *                                              temp buffer
 *      kvImageBufferSizeMismatch           The source buffer(s) must be at least as large as the destination buffer(s)
 *                                           (src.height >= dest.height && src.width >= dest.width)
 *      kvImageUnknownFlagsBit              A flag was passed to the vImageConverter creation function which is
 *                                          unrecognized or not appropriate to this function
 *      kvImageNullPointerArgument          converter is NULL
 *      kvImageInvalidParameter             One of the buffers pointed to by srcs or dests has a NULL vImage_Buffer.data pointer
 *      kvImageUnknownFlagsBit              An unknown or unsupported flags bit was set.
 *      kvImageInvalidImageFormat           if a byte ordering is specified (e.g. kCGBitmapByteOrder16Little), the buffer.rowBytes
 *                                          must be multiple of 2 (kCGBitmapByteOrder16Little, kCGBitmapByteOrder16Big) or
 *                                          4 (kCGBitmapByteOrder32Little, kCGBitmapByteOrder32Big)
 *  @/textblock </pre>
 *
 */
@available(OSX 10.9, *)
func vImageConvert_AnyToAny(converter: vImageConverter, _ srcs: UnsafePointer<vImage_Buffer>, _ dests: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutablePointer<Void>, _ flags: vImage_Flags) -> vImage_Error

/*!
 @abstract
 Transpose a vector or matrix.

 @discussion
 Returns a matrix that is the transpose of the source vector or matrix.  If the
 source object is not a vector or matrix, the returned object will have status
 LA_INVALID_PARAMETER_ERROR.
 */
@available(OSX 10.10, *)
func la_transpose(matrix: la_object_t) -> la_object_t!

/*!
 @abstract
 Multiply a matrix or vector by a scalar given by a float.
 
 @discussion
 Returns a matrix whose entries are the product of the scalar and the 
 corresponding element of the source matrix.  If the source object is not
 a vector or matrix, the returned object will have status 
 LA_INVALID_PARAMETER_ERROR.
 
 If the scalar type of matrix is not float LA_PRECISION_MISMATCH_ERROR is 
 returned.
 */
@available(OSX 10.10, *)
func la_scale_with_float(matrix: la_object_t, _ scalar: Float) -> la_object_t!

/*!
 @abstract
 Multiply a matrix or vector by a scalar given by a double.

 @discussion
 Returns a matrix whose entries are the product of the scalar and the
 corresponding element of the source matrix.  If the source object is not
 a vector or matrix, the returned object will have status
 LA_INVALID_PARAMETER_ERROR.
 
 If the scalar type of matrix is not double LA_PRECISION_MISMATCH_ERROR is
 returned.
 */
@available(OSX 10.10, *)
func la_scale_with_double(matrix: la_object_t, _ scalar: Double) -> la_object_t!

/*!
 @abstract
 Compute the element-wise sum of two vectors or matrices.
 
 @discussion
 If either source operand is not a vector or matrix or splat, or if both
 operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.
 
 The two operands must have the same dimensions.  If they do not, the result
 will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
 of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
 same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
 vector will be created, otherwise orientation matches input.
 
 The result has the same dimensions as the operands, and each element in
 the result is the sum of the corresponding elements in the source operands.
 */
@available(OSX 10.10, *)
func la_sum(obj_left: la_object_t, _ obj_right: la_object_t) -> la_object_t!

/*!
 @abstract
 Compute the element-wise difference of two vectors or matrices.

 @discussion
 If either source operand is not a vector or matrix or splat, or if both
 operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.

 The two operands must have the same dimensions.  If they do not, the result
 will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
 of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
 same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
 vector will be created, otherwise orientation matches input.

 The result has the same dimensions as the operands, and each element in
 the result is given by subtracting the corresponding element of obj_right
 from the corresponding element of obj_left.
 */
@available(OSX 10.10, *)
func la_difference(obj_left: la_object_t, _ obj_right: la_object_t) -> la_object_t!

/*!
 @abstract
 Compute the element-wise product of two vectors or matrices.

 @discussion
 If either source operand is not a vector or matrix or splat, or if both
 operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.

 The two operands must have the same dimensions.  If they do not, the result
 will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
 of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
 same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
 vector will be created, otherwise orientation matches input.

 The result has the same dimensions as the operands, and each element in
 the result is the product of the corresponding elements in the source operands.
 */
@available(OSX 10.10, *)
func la_elementwise_product(obj_left: la_object_t, _ obj_right: la_object_t) -> la_object_t!

/*!
 @abstract
 Compute the inner product of two vectors.
 
 @discussion
 If either operand is a matrix that is not 1xn or nx1, the result has the
 status LA_INVALID_PARAMETER_ERROR.
 
 If either operand is not a vector or matrix or splat, or if both operands
 are splats, the result has the status LA_INVALID_PARAMETER_ERROR.

 If the lengths of the two operands do not match, the result has the status
 LA_DIMENSION_MISMATCH_ERROR.
 
 Otherwise the result is a 1x1 matrix containing the inner product:
 
        sum_{i=0...length} vector_left[i] * vector_right[i]
 */
@available(OSX 10.10, *)
func la_inner_product(vector_left: la_object_t, _ vector_right: la_object_t) -> la_object_t!

/*!
 @abstract
 Compute the outer product of two vectors.

 @discussion
 Splats are not supported by this function.  If either operand
 is a splat, the result has status LA_INVALID_PARAMETER_ERROR.

 If either operand is a matrix that is not 1xn or nx1, the result has the
 status LA_INVALID_PARAMETER_ERROR.

 If either operand is not a vector or matrix, the result has the status
 LA_INVALID_PARAMETER_ERROR.
 
 Otherwise the result is a matrix containg the outer product.  It has
 length(vector_left) rows and length(vector_right) columns.  The i,jth
 element of the matrix is vector_left[i] * vector_right[j].
 */
@available(OSX 10.10, *)
func la_outer_product(vector_left: la_object_t, _ vector_right: la_object_t) -> la_object_t!

/*!
 @abstract
 Compute a matrix product.

 @discussion
 Left splat operands are treated as 1 x rows(matrix_right) vectors and right 
 splat operands are treated as cols(matrix_left) x 1 vectors.
 
 For convenience, in certain situations vector operands may be implicitly
 transposed.  Specifically,
 
 If cols(matrix_left) == rows(matrix_right)
 	rows(matrix_left) x cols(matrix_right) = matrix_left * matrix_right
 Else if cols(matrix_left) == 1 and rows(matrix_left) == rows(matrix_right)
 	1 x cols(matrix_right) = transpose(matrix_left) * matrix_right
 Else if rows(matrix_right) == 1 and cols(matrix_left) == cols(matrix_right)
 	rows(matrix_left) x 1 = matrix_left * transpose(matrix_right)
 Else
  	result has the status LA_DIMENSION_MISMATCH_ERROR.

 If either operand is not a vector or matrix or splat, or if both operands
 are splats, the result has the status LA_INVALID_PARAMETER_ERROR.

 Otherwise the result is a matrix with 1 row if matrix_left is vector or splat 
 and rows(matrix_left) otherwise, and 1 column if matrix_right is vector or
 splat and cols(matrix_right) otherwise.
 
 If cols(matrix_left) == rows(matrix_right), the i,jth element of the matrix is:
 		sum_{k=0...cols(matrix_left)} matrix_left[i,k] * matrix_right[k,j]
 If cols(matrix_left) == 1 and rows(matrix_left) == rows(matrix_right), the 
    0,jth element of matrix is:
 		sum_{k=0...rows(matrix_right)} matrix_left[k,0] * matrix_right[k,j]
 If rows(matrix_right) == 1 and cols(matrix_left) == cols(matrix_right), the
 	i,0th element of matrix is:
 	sum_{k=0...cols(matrix_left)} matrix_left[i,k] * matrix_right[0,k]
 
 */
@available(OSX 10.10, *)
func la_matrix_product(matrix_left: la_object_t, _ matrix_right: la_object_t) -> la_object_t!
var LA_DEFAULT_ATTRIBUTES: Int32 { get }
var LA_ATTRIBUTE_ENABLE_LOGGING: UInt32 { get }
typealias la_attribute_t = UInt
var LA_SUCCESS: Int32 { get }
var LA_WARNING_POORLY_CONDITIONED: Int32 { get }
var LA_INTERNAL_ERROR: Int32 { get }
var LA_INVALID_PARAMETER_ERROR: Int32 { get }
var LA_DIMENSION_MISMATCH_ERROR: Int32 { get }
var LA_PRECISION_MISMATCH_ERROR: Int32 { get }
var LA_SINGULAR_ERROR: Int32 { get }
var LA_SLICE_OUT_OF_BOUNDS_ERROR: Int32 { get }
typealias la_status_t = Int
var LA_SCALAR_TYPE_FLOAT: Int32 { get }
var LA_SCALAR_TYPE_DOUBLE: Int32 { get }
typealias la_scalar_type_t = UInt32
typealias la_count_t = UInt
typealias la_index_t = Int
typealias la_deallocator_t = @convention(c) (UnsafeMutablePointer<Void>) -> Void

/*!
 @abstract
 Solves a system of linear equations
 
 @param matrix_system
 A matrix describing the left-hand side of the system.
 
 @param obj_rhs
 A vector or matrix describing one or more right-hand sides for which the
 equations are to be solved.
 
 @return
 A matrix of the solution(s) of the system of equations.

 @discussion
 If matrix_system represents a matrix A, and obj_rhs represents a vector
 B, la_solve returns a vector X representing a solution to the equation
 AX = B, if such a solution exists.  If obj_rhs represents a matrix, then
 la_solve returns a matrix representing the solution of the same equation.
 
 There are several different cases, and different algorithms are chosen
 depending on the specifics:
 
 If the matrix has a special structure that allows us to solve the system
 without factoring (e.g. if the matrix is diagonal or triangular), we may
 use that structure to compute the solution.
 
 If the matrix is symmetric and all diagonal entries are positive, or if we
 know, either via a hint parameter or by how earlier computations were
 structured, that the matrix is positive definite, we attempt a Cholesky
 factorization.  If this succeeds, it is used to compute the solution via
 forward- and back-substitution.
 
 If the matrix is square, we try to perform Gaussian elimination to construct
 a triangular factorization with pivoting.  If this factorization succeeds,
 we use it to solve the system.  If it fails, the returned object has the
 error status LA_SINGULAR_ERROR.
 
 If the matrix is not square, we return a least-squares solution computed by
 performing a QR factorization of the matrix.
 
 If the number of rows of the matrix does not match the number of rows of
 the right hand side object, the returned object has status 
 LA_DIMENSION_MISMATCH_ERROR.
 
 If the object describing the matrix is not a matrix, or if the right hand
 side is not a matrix or vector, the returned object has status
 LA_INVALID_PARAMETER_ERROR.
 
 If you want to solve the system XA = B, which is less common (but still
 occurs fairly frequently), you may accomplish this by transposing A and B,
 solving, and then transposing the result of the solve.
 */
@available(OSX 10.10, *)
func la_solve(matrix_system: la_object_t, _ obj_rhs: la_object_t) -> la_object_t!
var LA_NO_HINT: UInt32 { get }
var LA_SHAPE_DIAGONAL: UInt32 { get }
var LA_SHAPE_LOWER_TRIANGULAR: UInt32 { get }
var LA_SHAPE_UPPER_TRIANGULAR: UInt32 { get }
var LA_FEATURE_SYMMETRIC: UInt32 { get }
var LA_FEATURE_POSITIVE_DEFINITE: UInt32 { get }
var LA_FEATURE_DIAGONALLY_DOMINANT: UInt32 { get }
typealias la_hint_t = UInt

/*!
 @abstract
 Create a matrix using data from a buffer of floats.  Ownership of the buffer
 remains in control of the caller.

 @param buffer
 Pointer to float data providing the elements of the matrix.

 @param matrix_rows
 The number of rows in the matrix.

 @param matrix_cols
 The number of columns in the matrix.

 @param matrix_row_stride
 The offset in the buffer (measured in floats) between corresponding elements
 in consecutive rows of the matrix.  Must be positive.

 @param matrix_hint
 Flags describing special matrix structures.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the matrix.

 @discussion
 This function creates an object representing a matrix whose entries are
 copied out of the supplied buffer of floats.  Negative or zero strides
 are not supported by this function (but note that you can reverse the
 rows or columns using the la_matrix_slice function defined below).

 This routine assumes that the elements of the matrix are stored in the buffer
 in row-major order.  If you need to work with data that is in column-major
 order, you can do that as follows:

 1. Use this routine to create a matrix object, but pass the number of
 columns in your matrix for the matrix_rows parameter and vice-versa.  For
 the matrix_row_stride parameter, pass the column stride of your matrix.

 2. Make a new matrix transpose object from the object created in step 1.  The
 resulting object represents the matrix that you want to work with.
 */
@available(OSX 10.10, *)
func la_matrix_from_float_buffer(buffer: UnsafePointer<Float>, _ matrix_rows: la_count_t, _ matrix_cols: la_count_t, _ matrix_row_stride: la_count_t, _ matrix_hint: la_hint_t, _ attributes: la_attribute_t) -> la_object_t!

/*!
 @abstract
 Create a matrix using data from a buffer of doubles.  Ownership of the buffer
 remains in control of the caller.

 @param buffer
 Pointer to double data providing the elements of the matrix.

 @param matrix_rows
 The number of rows in the matrix.

 @param matrix_cols
 The number of columns in the matrix.

 @param matrix_row_stride
 The offset in the buffer (measured in doubles) between corresponding elements
 in consecutive rows of the matrix.  Must be positive.

 @param matrix_hint
 Flags describing special matrix structures.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the matrix.

 @discussion
 This function creates an object representing a matrix whose entries are
 copied out of the supplied buffer of doubles.  Negative or zero strides
 are not supported by this function (but note that you can reverse the
 rows or columns using the la_matrix_slice function defined below).

 This routine assumes that the elements of the matrix are stored in the buffer
 in row-major order.  If you need to work with data that is in column-major
 order, you can do that as follows:

 1. Use this routine to create a matrix object, but pass the number of
 columns in your matrix for the matrix_rows parameter and vice-versa.  For
 the matrix_row_stride parameter, pass the column stride of your matrix.

 2. Make a new matrix transpose object from the object created in step 1.  The
 resulting object represents the matrix that you want to work with.
 */
@available(OSX 10.10, *)
func la_matrix_from_double_buffer(buffer: UnsafePointer<Double>, _ matrix_rows: la_count_t, _ matrix_cols: la_count_t, _ matrix_row_stride: la_count_t, _ matrix_hint: la_hint_t, _ attributes: la_attribute_t) -> la_object_t!

/*!
 @abstract
 Create a matrix using data from a buffer of floats.  Ownership of the buffer
 is transferred from the caller to the returned object.

 @param buffer
 Pointer to float data providing the elements of the matrix.

 @param matrix_rows
 The number of rows in the matrix.

 @param matrix_cols
 The number of columns in the matrix.

 @param matrix_row_stride
 The offset in the buffer (measured in floats) between corresponding elements
 in consecutive rows of the matrix.  Must be positive.

 @param matrix_hint
 Flags describing special matrix structures.

 @param deallocator
 Callback to be used to deallocate the buffer when the returned matrix object
 is destroyed.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the matrix.

 @discussion
 This function creates an object representing a matrix whose entries are
 copied out of the supplied buffer of floats.  Negative or zero strides
 are not supported by this function (but note that you can reverse the
 rows or columns using the la_matrix_slice function defined below).

 This routine assumes that the elements of the matrix are stored in the buffer
 in row-major order.  If you need to work with data that is in column-major
 order, you can do that as follows:

 1. Use this routine to create a matrix object, but pass the number of
 columns in your matrix for the matrix_rows parameter and vice-versa.  For
 the matrix_row_stride parameter, pass the column stride of your matrix.

 2. Make a new matrix transpose object from the object created in step 1.  The
 resulting object represents the matrix that you want to work with.
 */
@available(OSX 10.10, *)
func la_matrix_from_float_buffer_nocopy(buffer: UnsafeMutablePointer<Float>, _ matrix_rows: la_count_t, _ matrix_cols: la_count_t, _ matrix_row_stride: la_count_t, _ matrix_hint: la_hint_t, _ deallocator: la_deallocator_t!, _ attributes: la_attribute_t) -> la_object_t!

/*!
 @abstract
 Create a matrix using data from a buffer of doubles.  Ownership of the buffer
 is transferred from the caller to the returned object.

 @param buffer
 Pointer to double data providing the elements of the matrix.

 @param matrix_rows
 The number of rows in the matrix.

 @param matrix_cols
 The number of columns in the matrix.

 @param matrix_row_stride
 The offset in the buffer (measured in doubles) between corresponding elements
 in consecutive rows of the matrix.  Must be positive.

 @param matrix_hint
 Flags describing special matrix structures.

 @param deallocator
 Callback to be used to deallocate the buffer when the returned matrix object
 is destroyed.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the matrix.

 @discussion
 This function creates an object representing a matrix whose entries are
 copied out of the supplied buffer of doubles.  Negative or zero strides
 are not supported by this function (but note that you can reverse
 the rows or columns using the la_matrix_slice function defined below).

 This routine assumes that the elements of the matrix are stored in the buffer
 in row-major order.  If you need to work with data that is in column-major
 order, you can do that as follows:

 1. Use this routine to create a matrix object, but pass the number of
 columns in your matrix for the matrix_rows parameter and vice-versa.  For
 the matrix_row_stride parameter, pass the column stride of your matrix.

 2. Make a new matrix transpose object from the object created in step 1.  The
 resulting object represents the matrix that you want to work with.
 */
@available(OSX 10.10, *)
func la_matrix_from_double_buffer_nocopy(buffer: UnsafeMutablePointer<Double>, _ matrix_rows: la_count_t, _ matrix_cols: la_count_t, _ matrix_row_stride: la_count_t, _ matrix_hint: la_hint_t, _ deallocator: la_deallocator_t!, _ attributes: la_attribute_t) -> la_object_t!

/*!
 @abstract
 Stores the elements of a matrix to a buffer.
 
 @param buffer
 Pointer to the destination buffer.
 
 @param buffer_row_stride
 Offset (measured in floats) between the destinations of corresponding elements
 of consecutive rows of the matrix.  Must be positive.
 
 @param matrix
 The matrix to store.
 
 @discussion
 The buffer must be large enough to accomodate the matrix being stored.
 Specifically, it must have sufficient space to hold
 
    buffer_row_stride*(la_matrix_rows(matrix)-1) + la_matrix_cols(matrix)
 
 float elements.
 
 This function supports storing the contents of a vector as well as a matrix.
 A vector of length n will be interpreted as a rows(matrix) x cols(matrix) by 
 this function.  If the object is a vector or matrix and does not have an error 
 status, its contents are stored to the buffer.  If it has an error status, NaNs 
 are stored to the buffer.
 
 If the object is not a matrix or vector, nothing is written to the buffer and
 LA_INVALID_PARAMETER_ERROR is returned.
 */
@available(OSX 10.10, *)
func la_matrix_to_float_buffer(buffer: UnsafeMutablePointer<Float>, _ buffer_row_stride: la_count_t, _ matrix: la_object_t) -> la_status_t

/*!
 @abstract
 Stores the elements of a matrix to a buffer.

 @param buffer
 Pointer to the destination buffer.

 @param buffer_row_stride
 Offset (measured in doubles) between the destinations of corresponding elements
 of consecutive rows of the matrix.  Must be positive.

 @param matrix
 The matrix to store.

 @discussion
 The buffer must be large enough to accomodate the matrix being stored.
 Specifically, it must have sufficient space to hold

    buffer_row_stride*(la_matrix_rows(matrix)-1) + la_matrix_cols(matrix)

 double elements.
 
 This function supports storing the contents of a vector as well as a matrix.
 A vector of length n will be interpreted as a rows(matrix) x cols(matrix) by
 this function.  If the object is a vector or matrix and does not have an error
 status, its contents are stored to the buffer.  If it has an error status, NaNs
 are stored to the buffer.

 If the object is not a matrix or vector, nothing is written to the buffer and
 LA_INVALID_PARAMETER_ERROR is returned.
 */
@available(OSX 10.10, *)
func la_matrix_to_double_buffer(buffer: UnsafeMutablePointer<Double>, _ buffer_row_stride: la_count_t, _ matrix: la_object_t) -> la_status_t

/*!
 @abstract
 Get the number of rows in a matrix.
 
 @discussion
 If the argument has an error status, zero is returned.
 If the argument is a vector, the number of rows may be 1 or length(vector) 
 depending on the orientation of the vector.
 If the argument is a matrix, the number of rows is returned.
 Otherwise, zero is returned.
 */
@available(OSX 10.10, *)
@effects(readnone) func la_matrix_rows(matrix: la_object_t) -> la_count_t

/*!
 @abstract
 Get the number of columns in a matrix.

 @discussion
 If the argument has an error status, zero is returned.
 If the argument is a vector, the number of columns may be 1 or length(vector)
 depending on the orientation of the vector.
 If the argument is a matrix, the number of columns is returned.
 Otherwise, zero is returned.
 */
@available(OSX 10.10, *)
@effects(readnone) func la_matrix_cols(matrix: la_object_t) -> la_count_t

/*!
 @abstract
 Create a slice of a matrix.
 
 @param matrix
 The matrix to be sliced.
 
 @param matrix_first_row
 The index of the row of the source matrix containing the first element of
 new slice matrix.
 
 @param matrix_first_col
 The index of the column of the source matrix containing the first element
 of the slice matrix.
 
 @param matrix_row_stride
 The offset in the source matrix between rows that will be consecutive in
 the slice matrix.
 
 @param matrix_col_stride
 The offset in the source matrix between columns that will be consecutve in
 the slice matrix.
 
 @param slice_rows
 The number of rows in the slice matrix.
 
 @param slice_cols
 The number of columns in the slice matrix.
 
 @return
 A new matrix with size slice_rows x slice_cols whose elements are taken
 from the source matrix.
 
 @discussion
 The result object is the slice_rows x slice_cols matrix whose i,jth entry is:
 
    matrix[matrix_first_row + i*matrix_row_stride,
           matrix_first_col + j*matrix_col_stride]
 
 Slices provide an efficient means to operate on tiles and strides.  These are
 lightweight objects that reference the storage of the matrix from which they
 originate.  In most cases, creating a slice does not require any allocation
 beyond the object representing the slice, nor require copying.  In some 
 less common cases, a copy may be required.
 
 This function supports slicing a vector (interpreted as 
 rows(matrix) x cols(matrix)) or a matrix.  If the object is not a matrix or 
 vector, the returned object will have status LA_INVALID_PARAMETER_ERROR.

 If the slice references indices that are less than zero or greater than or
 equal to the dimensions of the matrix, LA_SLICE_OUT_OF_BOUNDS_ERROR is 
 returned.
 */
@available(OSX 10.10, *)
func la_matrix_slice(matrix: la_object_t, _ matrix_first_row: la_index_t, _ matrix_first_col: la_index_t, _ matrix_row_stride: la_index_t, _ matrix_col_stride: la_index_t, _ slice_rows: la_count_t, _ slice_cols: la_count_t) -> la_object_t!
@available(OSX 10.10, *)
func la_identity_matrix(matrix_size: la_count_t, _ scalar_type: la_scalar_type_t, _ attributes: la_attribute_t) -> la_object_t!

/*!
 @abstract
 Create a matrix with a specified diagonal provided by a vector, and zeros in
 all the other entries.
 
 @param vector
 Vector providing the data for the non-zero diagonal.
 
 @param matrix_diagonal
 The index of the non-zero diagonal.
 
 @discussion
 Creates a new matrix with entries on the specified diagonal taken from the
 vector argument, and zeros in the other entries.  The matrix is square, and
 has size length(vector) + abs(matrix_diagonal).
 
 If matrix_diagonal is zero, the main diagonal is set.  If matrix_diagonal is
 +1, the first superdiagonal is set.  If matrix_diagonal is -2, the second
 subdiagonal is set.
 
 The diagonal may be specified by a vector or by a matrix that has only one
 row or only one column.  If the provided object is not a vector or matrix,
 or is a matrix with both dimensions larger than one, the returned object
 will have status LA_INVALID_PARAMETER_ERROR.
 */
@available(OSX 10.10, *)
func la_diagonal_matrix_from_vector(vector: la_object_t, _ matrix_diagonal: la_index_t) -> la_object_t!

/*!
 @abstract
 Creates a vector from the specified row of the matrix.
 
 @param matrix
 Matrix from which to create the row vector.
 
 @param matrix_row.
 The zero-based index of the row to create the vector from.  
 
 @return
 The resulting vector is a 1 x cols(matrix) vector.
 
 @discussion
 Creates a vector from the specified row of the matrix.  If the value for 
 matrix_row is less than zero or greater than rows(matrix)-1,
 LA_INVALID_PARAMETER_ERROR is returned.  
 
 If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.

 Always returns a 1 x vector_length vector.
 */
@available(OSX 10.10, *)
func la_vector_from_matrix_row(matrix: la_object_t, _ matrix_row: la_count_t) -> la_object_t!

/*!
 @abstract
 Creates a vector from the specified column of the matrix.
 
 @param matrix
 Matrix from which to create the column vector.
 
 @param matrix_col.
 The zero-based index of the column to create the vector from.
 
 @return
 The resulting vector is a rows(matrix) x 1 vector.
 
 @discussion
 Creates a vector from the specified column of the matrix.  If the value for
 matrix_col is less than zero or greater than cols(matrix)-1,
 LA_INVALID_PARAMETER_ERROR is returned.
 
 If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.

 Always returns a vector_length x 1 vector.
 */
@available(OSX 10.10, *)
func la_vector_from_matrix_col(matrix: la_object_t, _ matrix_col: la_count_t) -> la_object_t!

/*!
 @abstract
 Creates a vector from the specified diagonal of the matrix.
 
 @param matrix
 Matrix from which to create the vector.
 
 @param matrix_diagonal.
 The index of the diagonal to create the vector from.
 
 @return
 The resulting vector is a length x 1 vector where length is 
 min(rows(matrix),cols(matrix)-abs(matrix_diagonal)
 
 @discussion
 Creates a new vector with entries on the specified diagonal taken from the
 vector argument, and zeros in the other entries.  The matrix is square, and
 has size length(vector) + abs(matrix_diagonal).
 
 If matrix_diagonal is zero, the main diagonal is set.  If matrix_diagonal is
 +1, the first superdiagonal is set.  If matrix_diagonal is -2, the second
 subdiagonal is set.
 
 Creates a vector from the specified diagonal of the matrix.  If the value for
 matrix_diagonal is less than zero and abs(matrix_diagonal) > rows(matrix)-1,
 or if matrix_diagonal is greater than zero and matrix_diagonal > 
 cols(matrix)-1, LA_INVALID_PARAMETER_ERROR is returned.
 
 If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.

 Always returns a vector_length x 1 vector.
 */
@available(OSX 10.10, *)
func la_vector_from_matrix_diagonal(matrix: la_object_t, _ matrix_diagonal: la_index_t) -> la_object_t!
var LA_L1_NORM: Int32 { get }
var LA_L2_NORM: Int32 { get }
var LA_LINF_NORM: Int32 { get }
typealias la_norm_t = UInt

/*!
 @abstract
 Compute a norm of a vector or matrix.

 @discussion
 "vector" refers to the fact that this function computes the norm of its
 argument considered as a vector, and not an operator norm.  The actual
 argument may be either a vector or a matrix.  If it is not a vector or
 matrix, or if the vector_norm parameter is not a supported value, NAN is
 returned.
 */
@available(OSX 10.10, *)
func la_norm_as_float(vector: la_object_t, _ vector_norm: la_norm_t) -> Float
@available(OSX 10.10, *)
func la_norm_as_double(vector: la_object_t, _ vector_norm: la_norm_t) -> Double

/*!
 @abstract
 "Normalizes" a vector or matrix.
 
 @discussion
 The returned object has the same direction as the first operand, and has
 norm 1 in the specified vector norm.  If the input vector is zero, it cannot
 be meaningfully normalized and the returned object is also zero.  If the
 parameter vector is not a vector or matrix, or if the vector_norm parameter
 is not a supported value, the returned object has status
 LA_INVALID_PARAMETER_ERROR.
 */
@available(OSX 10.10, *)
func la_normalized_vector(vector: la_object_t, _ vector_norm: la_norm_t) -> la_object_t!
protocol OS_la_object : ObjectProtocol {
}
typealias la_object_t = OS_la_object

/*!
 @abstract
 Increment the reference count of a la_object_t object.

 @param object
 The object to retain.

 @result
 The retained object.

 @discussion
 On a platform with the modern Objective-C runtime this is exactly equivalent
 to sending the object the -[retain] message.
 */
@available(OSX 10.10, *)
func la_retain(object: la_object_t) -> la_object_t!

/*!
 @abstract
 Decrement the reference count of an la_object_t object.

 @param object
 The object to release.

 @discussion
 On a platform with the modern Objective-C runtime this is exactly equivalent
 to sending the object the -[release] message.
 */
@available(OSX 10.10, *)
func la_release(object: la_object_t)

/*!
 @abstract
 Add attributes to an la_object_t object.

 @param object
 The object that will have its attributes modified.

 @param attributes
 Attributes which are to be added to the object's existing attributes
 to create its new set of attributes.  This value should be constructed by
 or'ing together LA_ATTRIBUTE_* constants.

 @discussion
 This operation does not remove any existing attributes from the LinearAlgebra 
 object, though it is possible that some attributes will override others (if so, 
 this will be documented in the discussion of those attributes above).  
 Following this function call, the specified object has all of the attributes it 
 had before the call, plus any new attributes specified by the second parameter.
 
 Adding an attribute that the object already has does not change the object.
 
 This function is not reentrant or thread-safe.  Attempting to add or remove
 attributes from multiple threads will have unpredictable results.
 */
@available(OSX 10.10, *)
func la_add_attributes(object: la_object_t, _ attributes: la_attribute_t)

/*!
 @abstract
 Remove attributes from an la_object_t object.

 @param object
 The object that will have its attributes modified.

 @param attributes
 Attributes which are to be removed from the object's existing attributes
 to create its new set of attributes.  This value should be constructed by
 or'ing together LA_ATTRIBUTE_* constants.
 
 @discussion
 This function removes the specified attributes from the LinearAlgebra object.
 Removing an attribute that the object does not have is harmless and does not
 change the object.

 This function is not reentrant or thread-safe.  Attempting to add or remove
 attributes from multiple threads will have unpredictable results.
 */
@available(OSX 10.10, *)
func la_remove_attributes(object: la_object_t, _ attributes: la_attribute_t)

/*!
 @abstract Query the status of an la_object.
 
 @param object
 The object whose status is being requested.
 
 @return
 The status of the supplied object.

 @discussion Returns the status of a LinearAlgebra object.  The status will be 
 one of the codes defined in LinearAlgebra/base.h.  New status codes may be
 added in the future, but the following basic principle will continue to hold: 
 zero indicates success, status codes greater than zero are warnings, and
 status codes less than zero are errors.  Thus, careful error handling
 might look like the following:

 <pre>
 @textblock
 la_status_t status = la_status(result_object);
 if (status == LA_SUCCESS) {
    // Everything is copacetic.  Get your data from result_object.
 } else if (status > 0) {
    // No errors occured, but the result does not have full accuracy due to
    // numerical considerations.  Here, you might re-compute the result using
    // a more careful or stable algorithm.
 } else {
    // An error occured.  Something is seriously amiss and you will need
    // to handle it however makes sense for your application.
 }
 @/textblock
 </pre>

 Note that errors and warnings are propagated.  In general, there is no need
 to check the status of each subcomputation.  Rather, the preferred idiom is
 to do a complete computation, then check to see if anything went wrong.
 Querying status may force evaluation of parts of your computation that might
 otherwise be deferred until their results were actually needed.
 */
@available(OSX 10.10, *)
func la_status(object: la_object_t) -> la_status_t
@available(OSX 10.10, *)
func la_splat_from_float(scalar_value: Float, _ attributes: la_attribute_t) -> la_object_t!
@available(OSX 10.10, *)
func la_splat_from_double(scalar_value: Double, _ attributes: la_attribute_t) -> la_object_t!
@available(OSX 10.10, *)
func la_splat_from_vector_element(vector: la_object_t, _ vector_index: la_index_t) -> la_object_t!
@available(OSX 10.10, *)
func la_splat_from_matrix_element(matrix: la_object_t, _ matrix_row: la_index_t, _ matrix_col: la_index_t) -> la_object_t!
@available(OSX 10.10, *)
func la_vector_from_splat(splat: la_object_t, _ vector_length: la_count_t) -> la_object_t!
@available(OSX 10.10, *)
func la_matrix_from_splat(splat: la_object_t, _ matrix_rows: la_count_t, _ matrix_cols: la_count_t) -> la_object_t!

/*!
 @abstract
 Stores the elements of a vector to a buffer.

 @param buffer
 Pointer to the destination buffer.

 @param buffer_stride
 Offset (in floats) between the destinations of consecutive vector elements
 in the buffer.  Negative strides are not supported (you can get the same
 effect by reversing the vector before calling this function).

 @param vector
 The vector to store.

 @discussion
 The buffer must be large enough to accomodate the vector being stored.
 Specifically, it must have have sufficient space to hold

 buffer_stride*(la_vector_length(vector)-1) + 1

 float elements.  Real usage in the most common case (stride = 1) will
 look roughly like this:

 <pre>
 @textblock
 la_count_t length = la_vector_length(vector);
 if (!length) {
 	// an error occured.
 }
 float *buffer = malloc(length * sizeof buffer[0]);
 la_vector_to_float_buffer(buffer, 1, vector);
 @/textblock
 </pre>

 This function supports storing the contents of a vector, or a matrix that
 has only one row or only one column.  If the object satisfies those
 requirements, and it does not have an error status, its contents are stored
 to the buffer.  If it has an error status, NaNs are stored to the buffer.

 If the object is not a matrix or vector, or if it is a matrix with both
 dimensions larger than one, nothing is written to the buffer and
 LA_INVALID_PARAMETER_ERROR is returned.
 */
@available(OSX 10.10, *)
func la_vector_to_float_buffer(buffer: UnsafeMutablePointer<Float>, _ buffer_stride: la_index_t, _ vector: la_object_t) -> la_status_t

/*!
 @abstract
 Stores the elements of a vector to a buffer.

 @param buffer
 Pointer to the destination buffer.

 @param buffer_stride
 Offset (in doubles) between the destinations of consecutive vector elements
 in the buffer.  Negative strides are not supported (you can get the same
 effect by reversing the vector before calling this function).

 @param vector
 The vector to store.

 @return
 If vector is a valid vector object, its status is returned.  Otherwise
 the return value is LA_INVALID_PARAMETER_ERROR.

 @discussion
 The buffer must be large enough to accomodate the vector being stored.
 Specifically, it must have have sufficient space to hold

 buffer_stride*(la_vector_length(vector)-1) + 1

 double elements.  Real usage in the most common case (stride = 1) will
 look roughly like this:

 <pre>
 @textblock
 la_count_t length = la_vector_length(vector);
 if (!length) {
 	// an error occured.
 }
 double *buffer = malloc(length * sizeof buffer[0]);
 la_vector_to_double_buffer(buffer, 1, vector);
 @/textblock
 </pre>

 This function supports storing the contents of a vector, or a matrix that
 has only one row or only one column.  If the object satisfies those
 requirements, and it does not have an error status, its contents are stored
 to the buffer.  If it has an error status, NaNs are stored to the buffer.

 If the object is not a matrix or vector, or if it is a matrix with both
 dimensions larger than one, nothing is written to the buffer and
 LA_INVALID_PARAMETER_ERROR is returned.
 */
@available(OSX 10.10, *)
func la_vector_to_double_buffer(buffer: UnsafeMutablePointer<Double>, _ buffer_stride: la_index_t, _ vector: la_object_t) -> la_status_t

/*!
 @abstract
 Get the length of a vector.

 @discussion
 If the argument has an error status, zero is returned.
 If the argument is a vector, its length is returned.
 If the argument is a matrix with only one row or only one column, the other
 dimension is returned.
 Otherwise, zero is returned.
 */
@available(OSX 10.10, *)
@effects(readnone) func la_vector_length(vector: la_object_t) -> la_count_t

/*!
 @abstract
 Create a slice of a vector.

 @param vector
 The vector to be sliced.

 @param vector_first
 The index of the source vector element that will become the first element
 of the new slice vector.

 @param vector_stride
 The offset in the source vector between elements that will be consecutive in
 the new slice vector.

 @param slice_length
 The length of the resulting slice vector.

 @return
 A new vector with length slice_length whose elements are taken from vector.

 @discussion
 The result object is the vector:

 [ vector[vector_first], vector[vector_first+vector_stride], ...
 ... , vector[vector_first + (slice_length-1)*vector_stride] ]
 
 Slices provide an efficient means to operate on subvectors and strides.
 These are lightweight objects that reference the storage of the vector from
 which they originate.  Creating a vector slice does not require any allocation
 beyond the object representing the slice, nor does it require copying.

 This function supports slicing a vector, or a matrix that has only one row
 or only one column.  If the object is not a matrix or vector, or if it is
 a matrix with both dimensions larger than one, the returned object will have
 status LA_INVALID_PARAMETER_ERROR.

 If the slice references indices that are less than zero or greater than or
 equal to the length of the vector, LA_SLICE_OUT_OF_BOUNDS_ERROR is returned.
 
 Always return a vector with the same orientation as the input.  If input is
 vector_length x 1, output is vector_length x 1 and if input is
 1 x vector_length, output is 1 x vector_length.
 */
@available(OSX 10.10, *)
func la_vector_slice(vector: la_object_t, _ vector_first: la_index_t, _ vector_stride: la_index_t, _ slice_length: la_count_t) -> la_object_t!

/*!
 @abstract
 Compute the inner product of sparse vector x with dense vector y.
 
 @param nz
 The number of nonzero entries in the sparse vector x.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nz values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param y
 Pointer to the dense vector y.  Accessed as y[indx[0..nz-1]*incy], so dimension 
 must be compatible with largest index value in indx.  Behavior undefined if 
 this is not met.  Negative strides are supported.  Note, unlike dense BLAS 
 routines, the pointer points to the last element when stride is negative.
 
 @param incy
 Increment between valid values in the dense vector y.  Negative strides are
 supported.
 
 @result
 On exit the result of the inner product is returned.
 
 @discussion
 Compute the inner product of sparse vector x with dense vector y.  Returns zero 
 if nz is less than or equal to zero.
 
 */
func sparse_inner_product_dense_float(nz: sparse_dimension, _ x: UnsafePointer<Float>, _ indx: UnsafePointer<sparse_index>, _ y: UnsafePointer<Float>, _ incy: sparse_stride) -> Float
func sparse_inner_product_dense_double(nz: sparse_dimension, _ x: UnsafePointer<Double>, _ indx: UnsafePointer<sparse_index>, _ y: UnsafePointer<Double>, _ incy: sparse_stride) -> Double

/*!
 @abstract
 Compute the inner product of sparse vector x with sparse vector y.
 
 @param nzx
 The number of nonzero entries in the sparse vector x.
 
 @param nzy
 The number of nonzero entries in the sparse vector y.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nzx values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nzx values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param y
 Pointer to the dense storage for the values of the sparse vector y.  The
 corresponding entry in indy holds the index of the value.  Contains nzy values.
 
 @param indy
 Pointer to the dense storage for the index values of the sparse vector y.  The
 corresponding entry in y holds the values of the vector.  Contains nzy values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @result
 On exit the result of the inner product is returned.
 
 @discussion
 Compute the inner product of sparse vector x with sparse vector y.  Returns
 zero if nzx or nzy is less than or equal to zero.
 
 */
func sparse_inner_product_sparse_float(nzx: sparse_dimension, _ nzy: sparse_dimension, _ x: UnsafePointer<Float>, _ indx: UnsafePointer<sparse_index>, _ y: UnsafePointer<Float>, _ indy: UnsafePointer<sparse_index>) -> Float
func sparse_inner_product_sparse_double(nzx: sparse_dimension, _ nzy: sparse_dimension, _ x: UnsafePointer<Double>, _ indx: UnsafePointer<sparse_index>, _ y: UnsafePointer<Double>, _ indy: UnsafePointer<sparse_index>) -> Double

/*!
 @abstract
 Scales the sparse vector x by alpha and adds the result to the dense vector y.
 
 y = alpha * x + y
 
 @param nz
 The number of nonzero entries in the sparse vector x.
 
 @param alpha
 Scalar multiplier of x.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nz values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param y
 Pointer to the dense vector y.  Accessed as y[indx[0..nz-1]*incy], so dimension
 must be compatible with largest index value in indx.  Behavior undefined if
 this is not met.  Negative strides are supported.  Note, unlike dense BLAS
 routines, the pointer points to the last element when stride is negative.
 
 @param incy
 Increment between valid values in the dense vector y.  Negative strides are
 supported.
 
 @result
 On exit y has been updated as y = alpha * x + y. If nz is less than or
 equal to zero or alpha is equal to zero, y is unchanged.
 
 @discussion
 Scales the sparse vector x by alpha and adds the result to the dense vector y.
 If alpha or nz is zero, y is unchanged.
 
 If the desired operation is y = alpha * x, then an efficient option is to 
 create the y buffer of zeros as y = calloc(sizeof(..)*ySize) and then perform
 the operation with the zero filled y.
 */
func sparse_vector_add_with_scale_dense_float(nz: sparse_dimension, _ alpha: Float, _ x: UnsafePointer<Float>, _ indx: UnsafePointer<sparse_index>, _ y: UnsafeMutablePointer<Float>, _ incy: sparse_stride)
func sparse_vector_add_with_scale_dense_double(nz: sparse_dimension, _ alpha: Double, _ x: UnsafePointer<Double>, _ indx: UnsafePointer<sparse_index>, _ y: UnsafeMutablePointer<Double>, _ incy: sparse_stride)

/*!
 @abstract
 Compute the specified norm of the sparse vector x.
 
 @param nz
 The number of nonzero values in the sparse vector x.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nz values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param norm
 Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
 or SPARSE_NORM_INF.  See discussion for further details.
 
 @result
 Upon success, return the requested norm.
 
 @discussion
 Compute the specified norm of the sparse vector x.  Specify one of:
 1) SPARSE_NORM_ONE : sum over i ( | x[i] | )
 2) SPARSE_NORM_TWO : sqrt( sum over i (x[i])^2 )
 3) SPARSE_NORM_INF : max over i ( | x[i] | )
 4) SPARSE_NORM_R1  : Not supported, undefined.
 
 If norm is not one of the enumerated norm types, the default value is
 SPARSE_NORM_INF.
 
 */
func sparse_vector_norm_float(nz: sparse_dimension, _ x: UnsafePointer<Float>, _ indx: UnsafePointer<sparse_index>, _ norm: sparse_norm) -> Float
func sparse_vector_norm_double(nz: sparse_dimension, _ x: UnsafePointer<Double>, _ indx: UnsafePointer<sparse_index>, _ norm: sparse_norm) -> Double

/*!
 @abstract
 Multiplies the dense vector x by the sparse matrix A and adds the result to
 the dense vector y.
 
 y = alpha * op(A) * x + y; where op(A) is either A or the transpose of A
 
 @param transa 
 Specifies whether to perform the operation with A or the transpose of A.
 Must be one of CblasNoTrans or CblasTrans.
 
 @param alpha
 Scalar multiplier of A.
 
 @param A
 The sparse matrix.
 
 @param x
 Pointer to the dense vector x. The dimension must be the number of columns of
 the matrix A when transa is no transpose or the number of rows of the matrix A
 when transa is transpose.  Behavior undefined if this is not met.  Negative 
 strides are supported.  Note, unlike dense BLAS routines, the pointer points to 
 the last element when stride is negative. 
 
 @param incx
 Increment between valid values in the dense vector x. Negative strides are
 supported.
 
 @param y
 Pointer to the dense vector y. The dimension must be the number of rows of
 the matrix A when transa is no transpose or the number of columns of the matrix 
 A when transa is transpose.  Behavior undefined if this is not met.  Negative
 strides are supported.  Note, unlike dense BLAS routines, the pointer points to
 the last element when stride is negative.
 
 @param incy
 Increment between valid values in the dense vector y.  Negative strides are
 supported.

 @result
 On success return SPARSE_SUCCESS and y has been updated with result of the 
 operation.  Will return SPARSE_ILLEGAL_PARAMETER if transa is invalid and y will 
 be unchanged.

 @discussion
 Multiplies the dense vector x by the sparse matrix A and adds the result to
 the dense vector y (y = alpha * op(A) * x + y, where op(A) is either A
 or the transpose of A).
 
 If the desired operation is y = A * x, then an efficient option is to create
 the y buffer of zeros as y = calloc(sizeof(..)*ySize) and then perform
 the operation with the zero filled y.
 */
func sparse_matrix_vector_product_dense_float(transa: CBLAS_TRANSPOSE, _ alpha: Float, _ A: sparse_matrix_float, _ x: UnsafePointer<Float>, _ incx: sparse_stride, _ y: UnsafeMutablePointer<Float>, _ incy: sparse_stride) -> sparse_status
func sparse_matrix_vector_product_dense_double(transa: CBLAS_TRANSPOSE, _ alpha: Double, _ A: sparse_matrix_double, _ x: UnsafePointer<Double>, _ incx: sparse_stride, _ y: UnsafeMutablePointer<Double>, _ incy: sparse_stride) -> sparse_status

/*!
 @abstract
 Solve the system of equations x = alpha * T^{-1} * x for x where x is a dense
 vector and T is a triangular sparse matrix.
 
 @param transt
 Specifies whether to perform the operation with T or the transpose of T.
 Must be one of CblasNoTrans or CblasTrans.
 
 @param alpha
 Scalar multiplier of T.
 
 @param T
 The sparse triangular matrix.  Must be upper or lower triangular matrix.
 Will return SPARSE_ILLEGAL_PARAMETER if not a triangular matrix.
 
 @param x
 Pointer to the dense vector x. The dimension must match the dimension of the
 triangular matrix T. Behavior undefined if this is not met.  Negative
 strides are supported.  Note, unlike dense BLAS routines, the pointer points to
 the last element when stride is negative.  On exit holds the solution to the
 system of equations.
 
 @param incx
 Increment between valid values in the dense vector x. Negative strides are
 supported.
 
 @result
 On success, SPARSE_SUCCESS is returned and x has been updated with result of the 
 operation.  Will return SPARSE_ILLEGAL_PARAMETER if transt is invalid or if the
 matrix T is not triangular and x will be unchanged.
 
 @discussion
 Solve the system of equations x = alpha * T^{-1} * x for x where x is a dense
 vector and T is a triangular sparse matrix.  The matrix T must be an upper or
 lower triangular matrix.
 
 */
func sparse_vector_triangular_solve_dense_float(transt: CBLAS_TRANSPOSE, _ alpha: Float, _ T: sparse_matrix_float, _ x: UnsafeMutablePointer<Float>, _ incx: sparse_stride) -> sparse_status
func sparse_vector_triangular_solve_dense_double(transt: CBLAS_TRANSPOSE, _ alpha: Double, _ T: sparse_matrix_double, _ x: UnsafeMutablePointer<Double>, _ incx: sparse_stride) -> sparse_status

/*!
 @abstract
 Compute the outer product of the dense vector x and the sparse vector y and
 return a new sparse matrix in the uninitialized pointer sparse matrix pointer 
 C.  C = alpha * x * y'
 
 @param M
 The number of rows of x and the resulting matrix.
 
 @param N
 The number of columns of the resulting matrix.  The number of nonzero values 
 must be less than or equal to N.
 
 @param nz
 The number of nonzero values in the sparse vector y.  Must be less than or
 equal to N.
 
 @param alpha
 Scalar multiplier of x.
 
 @param x
 Pointer to the dense vector x.  Must be M number of elements.  Negative strides 
 are supported.  Note, unlike dense BLAS routines, the pointer points to the 
 last element when stride is negative.
 
 @param incx
 Increment between valid values in the dense vector x.  Negative strides are
 supported.
 
 @param y
 Pointer to the dense storage for the values of the sparse vector y.  The
 corresponding entry in indy holds the index of the value.  Contains nz values.
 
 @param indy
 Pointer to the dense storage for the index values of the sparse vector y.  The
 corresponding entry in y holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param C
 Pointer to an uninitialized sparse matrix object.  On success a newly allocated
 sparse matrix object is returned in this pointer.  On error, this set to NULL.
 Caller is responsible for calling sparse_matrix_destroy on this matrix object.
 
 @result
 On success SPARSE_SUCCESS is returned an C is valid matrix object.  The caller is 
 responsible for cleaning up the sparse matrix object with sparse_matrix_destroy.
 Will return SPARSE_ILLEGAL_PARAMETER if nz > N, and C will be unchanged.
 
 @discussion
 Compute the outer product of the dense vector x and the sparse vector y and
 return a new sparse matrix in the uninitialized pointer sparse matrix pointer 
 C.  C = alpha * x * y'.  Caller responsible for calling sparse_matrix_destroy on 
 the returned matrix.
 
 The matrix object returned on success is a point wise based sparse matrix.
 
 */
func sparse_outer_product_dense_float(M: sparse_dimension, _ N: sparse_dimension, _ nz: sparse_dimension, _ alpha: Float, _ x: UnsafePointer<Float>, _ incx: sparse_stride, _ y: UnsafePointer<Float>, _ indy: UnsafePointer<sparse_index>, _ C: UnsafeMutablePointer<sparse_matrix_float>) -> sparse_status
func sparse_outer_product_dense_double(M: sparse_dimension, _ N: sparse_dimension, _ nz: sparse_dimension, _ alpha: Double, _ x: UnsafePointer<Double>, _ incx: sparse_stride, _ y: UnsafePointer<Double>, _ indy: UnsafePointer<sparse_index>, _ C: UnsafeMutablePointer<sparse_matrix_double>) -> sparse_status

/*!
 @abstract
 Permute the rows of the sparse matrix A based on the provided permutation
 array.
 
 @param A
 The sparse matrix.
 
 @param perm
 The permutation array.  Holds number of rows in A values indicating the
 permutation of the matrix.  The indices in perm are expected to be 0 based 
 (first element of pointer is ptr[0]).  The indices in perm are expected to
 be within bounds of the matrix.  Undefined behavior if not met.
 
 @result
 On successful return, A has been permuted and SPARSE_SUCCESS is returned.
 
 @discussion
 Permute the rows of the sparse matrix A based on the provided permutation
 array.  For each row in A, swap rows as:
 
 tmp[:] = A[i,:];
 A[i,:] = A[perm[i],:];
 A[perm[i],:] = tmp[:];
 
 */
func sparse_permute_rows_float(A: sparse_matrix_float, _ perm: UnsafePointer<sparse_index>) -> sparse_status
func sparse_permute_rows_double(A: sparse_matrix_double, _ perm: UnsafePointer<sparse_index>) -> sparse_status

/*!
 @abstract
 Permute the columns of the sparse matrix A based on the provided permutation
 array.
 
 @param A
 The sparse matrix.
 
 @param perm
 The permutation array.  Holds number of columns in A values indicating the
 permutation of the matrix.  The indices in perm are expected to be 0 based
 (first element of pointer is ptr[0]).  The indices in perm are expected to
 be within bounds of the matrix.  Undefined behavior if not met.
 
 @result
 On successful return, A has been permuted and SPARSE_SUCCESS is returned.
 
 @discussion
 Permute the columns of the sparse matrix A based on the provided permutation
 array.  For each column in A, swap columns as:
 
 tmp[:] = A[:,j];
 A[:,j] = A[:,perm[j]];
 A[:,perm[j]] = tmp[:];
 
 */
func sparse_permute_cols_float(A: sparse_matrix_float, _ perm: UnsafePointer<sparse_index>) -> sparse_status
func sparse_permute_cols_double(A: sparse_matrix_double, _ perm: UnsafePointer<sparse_index>) -> sparse_status

/*!
 @abstract
 Compute the specified elementwise norm of the sparse matrix A.  This is the 
 norm of the matrix treated as a vector, not the operator norm.
 
 @param A
 The sparse matrix.
 
 @param norm
 Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
 SPARSE_NORM_INF, or SPARSE_NORM_R1.  See discussion for further details.
 
 @result
 Upon success, resulting norm is returned.
 
 @discussion
 Compute the specified norm of the sparse matrix A.  This is the norm of the
 matrix treated as a vector, not the operator norm.  Specify one of:
 1) SPARSE_NORM_ONE : sum over i,j ( | A[i,j] | )
 2) SPARSE_NORM_TWO : sqrt( sum over i,j (A[i,j])^2 )
 3) SPARSE_NORM_INF : max over i,j ( | A[i,j] | )
 4) SPARSE_NORM_R1  : sum over j ( sqrt ( sum over i ( A[i,j]^2 ) ) )
 
 If norm is not one of the enumerated norm types, the default value is
 SPARSE_NORM_INF.
 
 */
func sparse_elementwise_norm_float(A: sparse_matrix_float, _ norm: sparse_norm) -> Float
func sparse_elementwise_norm_double(A: sparse_matrix_double, _ norm: sparse_norm) -> Double

/*!
 @abstract
 Compute the specified operator norm of the sparse matrix A.  For elementwise
 norm use elementwise_norm routines.
 
 @param A
 The sparse matrix.
 
 @param norm
 Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
 or SPARSE_NORM_INF.  See discussion for further details.
 
 @result
 Upon success, resulting norm is returned.
 
 @discussion
 Compute the specified norm of the sparse matrix A.  This is the norm of the
 matrix treated as an linear operator, not the elementwise norm.  Specify one of:
 1) SPARSE_NORM_ONE : max over j ( sum over i ( | A[i,j] | ) )
 2) SPARSE_NORM_TWO : Maximum singular value. This is significantly more
                      expensive to compute than the other norms.
 3) SPARSE_NORM_INF : max over i ( sum over j ( | A[i,j] | ) )
 4) SPARSE_NORM_R1  : Not supported, undefined.
 
 If norm is not one of the enumerated norm types, the default value is
 SPARSE_NORM_INF.
 
 */
func sparse_operator_norm_float(A: sparse_matrix_float, _ norm: sparse_norm) -> Float
func sparse_operator_norm_double(A: sparse_matrix_double, _ norm: sparse_norm) -> Double

/*!
 @abstract
 Compute the sum along the specified diagonal of the sparse matrix A.
 
 @param A
 The sparse matrix.
 
 @param offset
 Specifies the diagonal to sum.  A zero value will sum the main diagonal
 (A[i,i]), a value greater than zero will sum diagonals above the main diagonal
 (A[i,i+offset]), and a values less than zero will sum diagonals below the main
 diagonal (A[i-offset,i]).  If offset is out of the bounds of the matrix A, 0 
 is returned.
 
 @result
 On success, the resulting trace is returned.
 
 @discussion
 Compute the sum along the specified diagonal of the sparse matrix A.  The
 diagonal is specified by the parameter offset where zero is the main diagonal,
 values greater than one refer to diagonals above the main diagonal
 (A[i,i+offset]), and values less than one refer to diagonals below the main
 diagonal (A[i-offset, i]).

 If offset is out of the bounds of the matrix A, 0 is returned.
 
 */
func sparse_matrix_trace_float(A: sparse_matrix_float, _ offset: sparse_index) -> Float
func sparse_matrix_trace_double(A: sparse_matrix_double, _ offset: sparse_index) -> Double

/*!
 @functiongroup Level 3
 @abstract Level 3 routines consisting of matrix-matrix operations
 */
/*!
 @abstract
 Multiplies the dense matrix B by the sparse matrix A and adds the result to
 the dense matrix C.
 
 C = alpha * op(A) * B + C; where op(A) is either A or the transpose of A
 
 @param order
 Specified the storage order for the dense matrices B and C. Must be one of
 CblasRowMajor or CblasColMajor.
 
 @param transa
 Specifies whether to perform the operation with A or the transpose of A.
 Must be one of CblasNoTrans or CblasTrans.
 
 @param n
 The number of columns of the matrices B and C.
 
 @param alpha
 Scalar multiplier of A.
 
 @param A
 The sparse matrix.
 
 @param B
 Pointer to the dense matrix B. The number of rows must be equal to the number
 of columns of A and the number of columns is n.  Behavior undefined if this 
 is not met. The argument ldb describes how many elements to move between one
 row (row major) or column (column major).
 
 @param ldb
 Increment in elements between rows (row major) or columns (column major) of B. 
 Must be greater than or equal to n when row major, or number of columns of 
 A when column major.
 
 @param C
 Pointer to the dense matrix C. The number of rows must be equal to the number
 of rows of A and the number of columns is n.  Behavior undefined if this
 is not met. The argument ldc describes how many elements to move between one
 row (row major) or column (column major).  C is updated with the result of the
 operation.
 
 @param ldc
 Increment in elements between rows (row major) or columns (column major) of C.
 Must be greater than or equal to n when row major, or number of rows of
 A when column major.
 
 @result
 On success, SPARSE_SUCCESS is returned and C has been updated with result of the 
 operation.  Will return SPARSE_ILLEGAL_PARAMETER if order or transa is not valid 
 or the leading dimension parameters do not meet their dimension requirements.  
 On error, C is unchanged.
 
 @discussion
 Multiplies the dense matrix B by the sparse matrix A and adds the result to
 the dense matrix C (C = alpha * op(A) * B + C, where op(A) is either A
 or the transpose of A). If A is of size M x N, then B is of size N x n and C is 
 of size M x n.
 
 If the desired operation is C = A * B, then an efficient option is to create
 the C buffer of zeros as C = calloc(sizeof(..)*rows*cols) and then perform
 the operation with the zero filled C.
 */
func sparse_matrix_product_dense_float(order: CBLAS_ORDER, _ transa: CBLAS_TRANSPOSE, _ n: sparse_dimension, _ alpha: Float, _ A: sparse_matrix_float, _ B: UnsafePointer<Float>, _ ldb: sparse_dimension, _ C: UnsafeMutablePointer<Float>, _ ldc: sparse_dimension) -> sparse_status
func sparse_matrix_product_dense_double(order: CBLAS_ORDER, _ transa: CBLAS_TRANSPOSE, _ n: sparse_dimension, _ alpha: Double, _ A: sparse_matrix_double, _ B: UnsafePointer<Double>, _ ldb: sparse_dimension, _ C: UnsafeMutablePointer<Double>, _ ldc: sparse_dimension) -> sparse_status

/*!
 @abstract
 Solve the system of equations B = alpha * T^{-1} * B for B where B is a dense
 matrix and T is a triangular sparse matrix.
 
 @param order
 Specified the storage order for the dense matrix B. Must be one of
 CblasRowMajor or CblasColMajor.
 
 @param transt
 Specifies whether to perform the operation with T or the transpose of T.
 Must be one of CblasNoTrans or CblasTrans.
 
 @param nrhs
 The number of columns of the matrix B.
 
 @param alpha
 Scalar multiplier of T.
 
 @param T
 The sparse triangular matrix.  Must be upper or lower triangular matrix.
 Will return SPARSE_ILLEGAL_PARAMETER if not a triangular matrix.
 
 @param B
 Pointer to the dense matrix B. The number of rows must be equal to the number
 of columns of T and the number of columns is nrhs.  Behavior undefined if this
 is not met. The argument ldb describes how many elements to move between one
 row (row major) or column (column major). On exit holds the solution to the
 system of equations.
 
 @param ldb
 Increment in elements between rows (row major) or columns (column major) of B.
 Must be greater than or equal to nrhs when row major, or number of columns of
 A when column major.
 
 @result
 On success, SPARSE_SUCCESS is returned and B has been updated with result of the
 operation.  Will return SPARSE_ILLEGAL_PARAMETER if either of order or trant are
 invalid or the ldb does not meet its dimension requirements.  On error
 B is unchanged.
 
 @discussion
 Solve the system of equations B = alpha * T^{-1} * B for B where B is a dense
 vector and T is a triangular sparse matrix.  If T is of size N x N, then B must
 be of size N x nrhs.  The matrix T must be an upper or lower triangular matrix.
 
 */
func sparse_matrix_triangular_solve_dense_float(order: CBLAS_ORDER, _ transt: CBLAS_TRANSPOSE, _ nrhs: sparse_dimension, _ alpha: Float, _ T: sparse_matrix_float, _ B: UnsafeMutablePointer<Float>, _ ldb: sparse_dimension) -> sparse_status
func sparse_matrix_triangular_solve_dense_double(order: CBLAS_ORDER, _ transt: CBLAS_TRANSPOSE, _ nrhs: sparse_dimension, _ alpha: Double, _ T: sparse_matrix_double, _ B: UnsafeMutablePointer<Double>, _ ldb: sparse_dimension) -> sparse_status

/*!
 @abstract
 Create a sparse matrix object that is stored in point wise format and is ready
 to receive values from the various insert routines.
 
 @param M
 The number of rows of the matrix.  Must be greater than 0.
 
 @param N
 The number of columns of the matrix.  Must be greater than 0.
 
 @result
 On success, returns a matrix object that is ready for receiving entries.  If an
 error occurs, NULL is returned.
 
 @discussion
 Create a sparse matrix object that is stored in point wise format and is ready
 to receive values from the various insert routines.  Point wise format means
 individual values are stored for a given i,j location as opposed to blocks of
 values.  For block support use the block_create routines.  See the various
 insert routines for details on inserting entries into this matrix object.
 
 The dimensions M and N must be greater than 0.  On success a valid matrix
 object is returned, otherwise NULL is returned.
 
 */
func sparse_matrix_create_float(M: sparse_dimension, _ N: sparse_dimension) -> sparse_matrix_float
func sparse_matrix_create_double(M: sparse_dimension, _ N: sparse_dimension) -> sparse_matrix_double

/*!
 @abstract
 Use to build a sparse matrix by inserting one scalar entry at a time.  Update
 A[i,j] = val.  A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.

 @param A
 The sparse matrix.  A must have been created with one of sparse_matrix_create_float
 or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
 
 @param val
 The scalar value to insert into the sparse matrix.
 
 @param i
 The row location to insert the value.  Indices are 0 based (first element of 
 pointer is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param j
 The column location to insert the value.  Indices are 0 based (first element of
 pointer is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @result
 On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by inserting one scalar entry at a time.  Update
 A[i,j] = val.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
func sparse_insert_entry_float(A: sparse_matrix_float, _ val: Float, _ i: sparse_index, _ j: sparse_index) -> sparse_status
func sparse_insert_entry_double(A: sparse_matrix_double, _ val: Double, _ i: sparse_index, _ j: sparse_index) -> sparse_status

/*!
 @abstract
 Use to build a sparse matrix by providing a list of point entries.  For each
 entry provided, update A[indx[i],jndx[i]] = val[i].  A must have been created
 with one of sparse_matrix_create_float or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of sparse_matrix_create_float
 or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
 
 @param N
 The number of values to insert into A.  Each of indx, jndx and val are of size
 N.
 
 @param val
 Pointer to list of scalar values to insert into the sparse matrix.  The value
 is inserted into the location specified by the corresponding indices in indx
 and jndx.  Must hold N values.
 
 @param indx
 An array of row indices that correspond to the values in val. Must hold N
 values.
 
 Indices are assumed to be unique.  Additionally, indices are assumed to be in the
 bounds of the matrix.  Undefined behavior if any of these assumptions are not 
 met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param jndx
 An array of column indices that correspond to the values in val. Must hold N
 values.
 
 Indices are assumed to be unique.  Additionally, indices are assumed to be in the
 bounds of the matrix.  Undefined behavior if any of these assumptions are not
 met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @result
 On successful insertion, A has been updated with the values and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by providing a list of point entries.  For each
 entry provided, update A[indx[i],jndx[i]] = val[i].
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
func sparse_insert_entries_float(A: sparse_matrix_float, _ N: sparse_dimension, _ val: UnsafePointer<Float>, _ indx: UnsafePointer<sparse_index>, _ jndx: UnsafePointer<sparse_index>) -> sparse_status
func sparse_insert_entries_double(A: sparse_matrix_double, _ N: sparse_dimension, _ val: UnsafePointer<Double>, _ indx: UnsafePointer<sparse_index>, _ jndx: UnsafePointer<sparse_index>) -> sparse_status

/*!
 @abstract
 Use to build a sparse matrix by providing a list of point entries for a single
 column.  For each entry provided, update A[indx[i],j] = val[i].  A must have
 been created with one of sparse_matrix_create_float or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of sparse_matrix_create_float
 or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
 
 @param j
 The column for value insertion.  Indices are 0 based (first element of pointer
 is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param nz
 The number of values to insert into A.  Each of indx and val are of size
 nz.
 
 @param val
 Pointer to list of scalar values to insert into the sparse matrix.  The value
 is inserted into the location specified by the corresponding indices of indx
 and j.  Must hold nz values.
 
 @param indx
 An array of column indices that correspond to the values in val. Must hold nz
 values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Finally, indices are assumed to be in the
 bounds of the matrix.  Undefined behavior if any of these assumptions are not
 met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @result
 On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by providing a list of point entries for a single
 column.  For each entry provided, update A[indx[i],j] = val[i].  This will not
 replace the existing contents of the column, it appends new values and
 overwrites overlapping values.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
func sparse_insert_col_float(A: sparse_matrix_float, _ j: sparse_index, _ nz: sparse_dimension, _ val: UnsafePointer<Float>, _ indx: UnsafePointer<sparse_index>) -> sparse_status
func sparse_insert_col_double(A: sparse_matrix_double, _ j: sparse_index, _ nz: sparse_dimension, _ val: UnsafePointer<Double>, _ indx: UnsafePointer<sparse_index>) -> sparse_status

/*!
 @abstract
 Use to build a sparse matrix by providing a list of point entries for a single
 row.  For each entry provided, update A[i,jndx[i]] = val[i].  A must have been
 created with one of sparse_matrix_create_float or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of sparse_matrix_create_float
 or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
 
 @param i
 The row for value insertion.  Indices are 0 based (first element of pointer is
 ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param nz
 The number of values to insert into A.  Each of jndx and val are of size
 nz.
 
 @param val
 Pointer to list of scalar values to insert into the sparse matrix.  The value
 is inserted into the location specified by the corresponding indices of i and
 jndx.  Must hold nz values.
 
 @param jndx
 An array of column indices that correspond to the values in val. Must hold nz
 values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Finally, indices are assumed to be in the
 bounds of the matrix.  Undefined behavior if any of these assumptions are not
 met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @result
 On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by providing a list of point entries for a single
 row.  For each entry provided, update A[i,jndx[i]] = val[i].  This will not
 replace the existing contents of the row, it appends new values and
 overwrites overlapping values.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
func sparse_insert_row_float(A: sparse_matrix_float, _ i: sparse_index, _ nz: sparse_dimension, _ val: UnsafePointer<Float>, _ jndx: UnsafePointer<sparse_index>) -> sparse_status
func sparse_insert_row_double(A: sparse_matrix_double, _ i: sparse_index, _ nz: sparse_dimension, _ val: UnsafePointer<Double>, _ jndx: UnsafePointer<sparse_index>) -> sparse_status

/*!
 @abstract
 Extract the first nz values of the row begining at A[row,column_start] for the
 sparse matrix A.  A must have been created with one of sparse_matrix_create_float 
 or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of 
 sparse_matrix_create_float or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is 
 returned if not met.
 
 @param row
 The row for value extraction.  Indices are 0 based (first element of pointer is
 ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param column_start
 The index of the column to start extraction.  Indices are 0 based (first 
 element of pointer is ptr[0]).  Indices expected to be in the bounds of matrix 
 dimensions, undefined behavior if not met.
 
 @param column_end
 On return, holds the column index of the next nonzero value.If there is no
 next nonzero value (because all of them have been copied into the sparse
 vector), it holds the number of columns in the matrix.
 Indices are 0 based (first element of pointer is ptr[0]).
 Indices expected to be in the bounds of matrix dimensions, undefined behavior 
 if not met.
 
 @param nz
 The number of values to extract from A.  Each of jndx and val are of size
 nz.
 
 @param val
 Pointer to array to hold the values extracted from the sparse matrix.  The
 value is extracted from the location specified by the corresponding indices of 
 row and jndx.  Must be of size nz elements.  If less than nz nonzero values are
 found, then the last nz - actual_nonzero_count elements of val are untouched.
 
 @param jndx
 An array to hold the extracted column indices that correspond to the values in 
 val. Note that these indices are relative to the matrix row and not the
 starting column index specified by column_start.  Returned indices are 0 based 
 (first element of pointer is ptr[0]).  Must be of size nz elements.
 
 @result
 On success val and jndx have been updated with the nonzero values of the row'th
 row, column_end holds the column index of the next nonzero value, and
 the number of nonzero values written are returned.  If A creation requirements 
 are not met, SPARSE_ILLEGAL_PARAMETER is returned and val and jndx are unchanged.
 
 @discussion
 Extract the first nz values of the row begining at A[row,column_start] for the
 sparse matrix A.  The number of nonzero values extracted is limited by nz, and
 the number of nonzero's written to jndx and val are returned.  Additionally, 
 the column index of the next nonzero value is returned in column_end.
 For example if nz is returned, not all nonzero values have been extracted,
 and a second extract can start from column_end.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 */
func sparse_extract_sparse_row_float(A: sparse_matrix_float, _ row: sparse_index, _ column_start: sparse_index, _ column_end: UnsafeMutablePointer<sparse_index>, _ nz: sparse_dimension, _ val: UnsafeMutablePointer<Float>, _ jndx: UnsafeMutablePointer<sparse_index>) -> sparse_status
func sparse_extract_sparse_row_double(A: sparse_matrix_double, _ row: sparse_index, _ column_start: sparse_index, _ column_end: UnsafeMutablePointer<sparse_index>, _ nz: sparse_dimension, _ val: UnsafeMutablePointer<Double>, _ jndx: UnsafeMutablePointer<sparse_index>) -> sparse_status

/*!
 @abstract
 Extract the first nz values of the column begining at A[row_start,column] for 
 the sparse matrix A.  A must have been created with one of 
 sparse_matrix_create_float or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of 
 sparse_matrix_create_float or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is 
 returned if not met.
 
 @param column
 The column for value extraction.  Indices are 0 based (first element of pointer 
 is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param row_start
 The index of the row to start extraction.  Indices are 0 based (first
 element of pointer is ptr[0]).  Indices expected to be in the bounds of matrix 
 dimensions, undefined behavior if not met.
 
 @param row_end
 On return, holds the row index of the next nonzero value.If there is no
 next nonzero value (because all of them have been copied into the sparse
 vector), it holds the number of rows in the matrix.
 Indices are 0 based (first element of pointer is ptr[0]).
 Indices expected to be in the bounds of matrix dimensions, undefined behavior 
 if not met.
 
 @param nz
 The number of values to extract from A.  Each of indx and val are of size
 nz.
 
 @param val
 Pointer to array to hold the values extracted from the sparse matrix.  The
 value is extracted from the location specified by the corresponding indices of 
 column and indx.  Must be of size nz elements.  If less than nz nonzero values 
 are found, then the last nz - actual_nonzero_count elements of val are 
 untouched.
 
 @param indx
 An array to hold the extracted row indices that correspond to the values in
 val. Note that these indices are relative to the matrix column and not the
 starting row index specified by row_start.  Returned indices are 0 based
 (first element of pointer is ptr[0]).  Must be of size nz elements.
 
 @result
 On success val and indx have been updated with the nonzero values of the 
 column'th column, row_end holds the row index of the next nonzero value,
 and the number of nonzero values written are returned.  If A creation
 requirements are not met, SPARSE_ILLEGAL_PARAMETER is returned and val and indx 
 are unchanged.
 
 @discussion
 Extract the first nz values of the column begining at A[column,row_start] for 
 the sparse matrix A.  The number of nonzero values extracted is limited by nz, 
 and the number of nonzero's written to indx and val are returned.  
 Additionally, the row index of the next nonzero value is returned in
 row_end.  For example if nz is returned, not all nonzero values have been
 extracted, and a second extract can start from row_end.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 */
func sparse_extract_sparse_column_float(A: sparse_matrix_float, _ column: sparse_index, _ row_start: sparse_index, _ row_end: UnsafeMutablePointer<sparse_index>, _ nz: sparse_dimension, _ val: UnsafeMutablePointer<Float>, _ indx: UnsafeMutablePointer<sparse_index>) -> sparse_status
func sparse_extract_sparse_column_double(A: sparse_matrix_double, _ column: sparse_index, _ row_start: sparse_index, _ row_end: UnsafeMutablePointer<sparse_index>, _ nz: sparse_dimension, _ val: UnsafeMutablePointer<Double>, _ indx: UnsafeMutablePointer<sparse_index>) -> sparse_status

/*!
@abstract
Create a sparse matrix object that is stored in block-entry format and is ready
to receive values from the various block insert routines.  Blocks are of fixed
dimension k x l.

@param Mb
The number of rows in terms of blocks of the matrix.  There are a total of
Mb * k rows in the matrix.  Must be greater than 0.

@param Nb
The number of columns in terms of blocks of the matrix.  There are a total of
Nb * l columns in the matrix.  Must be greater than 0.

@param k
The row dimension of a block in the sparse matrix.  Must be greater than 0.

@param l
The column dimension of a block in the sparse matrix.  Must be greater than 0.

@result
On success, returns a matrix object that is ready for receiving entries.  If an
error occurs, NULL is returned.

@discussion
Create a sparse matrix object that is stored in block-entry format and is ready
to receive values from the various block insert routines.  Blocks are are of
fixed dimensions k x l.  Block-entry format means blocks of dense regions will 
be stored at block indices i,j.  For point wise format use non block version of
create. See the various insert routines for details on inserting values into
this matrix object.

The dimensions Mb, Nb, k, and l must be greater than 0.  On success a valid 
matrix object is returned, otherwise NULL is returned.
 
*/
func sparse_matrix_block_create_float(Mb: sparse_dimension, _ Nb: sparse_dimension, _ k: sparse_dimension, _ l: sparse_dimension) -> sparse_matrix_float
func sparse_matrix_block_create_double(Mb: sparse_dimension, _ Nb: sparse_dimension, _ k: sparse_dimension, _ l: sparse_dimension) -> sparse_matrix_double

/*!
 @abstract
 Create a sparse matrix object that is stored in block-entry format and is ready
 to receive values from the various block insert routines.  Blocks are of 
 variable dimensions where the i,j'th block has dimensions K[i] x L[j].
 
 @param Mb
 The number of rows in terms of blocks of the matrix.  Must be greater than 0.
 
 @param Nb
 The number of columns in terms of blocks of the matrix.  Must be greater 
 than 0.
 
 @param K
 Array containing row dimensions of the blocks.  The i'th row in terms of blocks
 will have a dimension K[i].  K is expected to hold Mb elements.  All values of
 K are expected to be greater than 0.
 
 @param L
 Array containing column dimensions of the blocks.  The j'th column in terms of 
 blocks will have a dimension L[j].  L is expected to hold Nb elements.  All 
 values of L are expected to be greater than 0.
 
 @result
 On success, returns a matrix object that is ready for receiving entries.  If an
 error occurs, NULL is returned.
 
 @discussion
 Create a sparse matrix object that is stored in block-entry format and is ready
 to receive values from the various block insert routines.  Blocks are are of
 variable dimension where the i,j'th block index has a dimension K[i] x L[j].  
 Block-entry format means blocks of dense regions will be stored at block 
 indices i,j.  For point wise format use non block version of create. See the 
 various insert routines for details on inserting values into this matrix
 object.
 
 The dimensions Mb, Nb and all values in K and L must be greater than 0.  On 
 success a valid matrix object is returned, otherwise NULL is returned.
 
 */
func sparse_matrix_variable_block_create_float(Mb: sparse_dimension, _ Nb: sparse_dimension, _ K: UnsafePointer<sparse_dimension>, _ L: UnsafePointer<sparse_dimension>) -> sparse_matrix_float
func sparse_matrix_variable_block_create_double(Mb: sparse_dimension, _ Nb: sparse_dimension, _ K: UnsafePointer<sparse_dimension>, _ L: UnsafePointer<sparse_dimension>) -> sparse_matrix_double

/*!
 @abstract
 Use to build a sparse matrix by providing a dense block for entry at block
 location A[bi,bj].  Block size is determined at object creation time.  A must
 have been created with one of sparse_matrix_block_create_float,
 sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
 sparse_matrix_variable_block_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of 
 sparse_matrix_block_create_float, sparse_matrix_block_create_double, 
 sparse_matrix_variable_block_create_float, or 
 sparse_matrix_variable_block_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if 
 not met.  A holds block dimensions (fixed or variable) set with matrix object 
 creation routine.
 
 @param val
 Pointer to block to be inserted at block index location A[bi,bj].  The block is
 of dimension k x l where k and l are set for bi,bj at object creation time.  
 The strides between elements for rows and columns are provided in row_stride 
 and col_stride.
 
 @param row_stride
 The row stride in number of elements to move from one row to the next for the
 block val.
 
 @param col_stride
 The column stride in number of elements to move from one column to the next for
 the block val.
 
 @param bi
 The block row index where val is to be inserted.  Indexing is zero based, the
 first block is located at 0,0.  Index is assumed to be within the bounds of the
 matrix object, undefined behavior if not met.
 
 @param bj
 The block column index where val is to be inserted.  Indexing is zero based, the
 first block is located at 0,0.  Index is assumed to be within the bounds of the
 matrix object, undefined behavior if not met.
 
 @result
 On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by providing a dense block for entry at block
 location A[bi,bj].  Block size is determined at object creation time.  Given a
 block dimension of k x l and for location bi,bj, update as:
 A[bi,bj][i,j] = val[i*row_stride + j*col_stride] for each i in k and each j in
 l.  
 
 A must have been created with one of sparse_matrix_block_create_float,
 sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
 sparse_matrix_variable_block_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
func sparse_insert_block_float(A: sparse_matrix_float, _ val: UnsafePointer<Float>, _ row_stride: sparse_dimension, _ col_stride: sparse_dimension, _ bi: sparse_index, _ bj: sparse_index) -> sparse_status
func sparse_insert_block_double(A: sparse_matrix_double, _ val: UnsafePointer<Double>, _ row_stride: sparse_dimension, _ col_stride: sparse_dimension, _ bi: sparse_index, _ bj: sparse_index) -> sparse_status

/*!
 @abstract
 Extract the bi,bj'th block from the sparse matrix A.  A must have been created
 with one of sparse_matrix_block_create_float, sparse_matrix_block_create_double, 
 sparse_matrix_variable_block_create_float, or 
 sparse_matrix_variable_block_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of
 sparse_matrix_block_create_float, sparse_matrix_block_create_double,
 sparse_matrix_variable_block_create_float, or
 sparse_matrix_variable_block_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if
 not met.  A holds block dimensions (fixed or variable) set with matrix object
 creation routine.
 
 @param bi
 The block row index for value extraction.  Indices are 0 based (first block of 
 matrix is A[0,0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param bj
 The block column index for value extraction.  Indices are 0 based (first block 
 of matrix is A[0,0]).  Indices expected to be in the bounds of matrix 
 dimensions, undefined behavior if not met.
 
 @param row_stride
 The row stride in number of elements to move from one row to the next for the
 block val.
 
 @param col_stride
 The column stride in number of elements to move from one column to the next for
 the block val.
 
 @param val
 Pointer to dense block to place the extracted values.  Expected to be of size
 K x L where K x L is the block size for the matrix object at block index bi,bj.
 This dimensions is set at matrix object creation time.
 
 @result
 On success SPARSE_SUCCESS is return and val has been updated with the block from
 block index bi,bj. If A creation requirements are not met, 
 SPARSE_ILLEGAL_PARAMETER is returned and val is unchanged.
 
 @discussion
 Extract the bi,bj'th block from the sparse matrix A.  
 
 A must have been created with one of sparse_matrix_block_create_float, 
 sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
 sparse_matrix_variable_block_create_double.
 
 */
func sparse_extract_block_float(A: sparse_matrix_float, _ bi: sparse_index, _ bj: sparse_index, _ row_stride: sparse_dimension, _ col_stride: sparse_dimension, _ val: UnsafeMutablePointer<Float>) -> sparse_status
func sparse_extract_block_double(A: sparse_matrix_double, _ bi: sparse_index, _ bj: sparse_index, _ row_stride: sparse_dimension, _ col_stride: sparse_dimension, _ val: UnsafeMutablePointer<Double>) -> sparse_status

/*!
 @abstract
 Return the dimension of the block for the i'th row of a sparse block matrix. 
 Returns 0 if the matrix was not created with a block create routine.
 */
func sparse_get_block_dimension_for_row(A: UnsafeMutablePointer<Void>, _ i: sparse_index) -> Int

/*!
 @abstract
 Return the dimension of the block for the j'th column of a sparse block matrix.
 Returns 0 if the matrix was not created with a block create routine.
 */
func sparse_get_block_dimension_for_col(A: UnsafeMutablePointer<Void>, _ j: sparse_index) -> Int

/*!
 @abstract
 Force any recently added values to the matrix to be put into the internal
 sparse storage format.
 
 @param A
 The sparse matrix, which has had values recently inserted into the object.
 
 @result
 On success, A has all values inserted into the internal sparse representation.
 
 @discussion
 Force any recently added values to the matrix to be put into the internal
 sparse storage format.  Values inserted into a matrix object will may not go 
 directly into the sparse representation until needed, for example when a 
 computation occurs.  In some cases is may be beneficial to the caller to know 
 when the cost of the update will occur.  This routine allows the caller to 
 trigger adding values to the internal sparse format.
 
 Adding values to the sparse format can be costly, and batch updates to the 
 matrices are recommended.  Similarly, use of this routine may be expensive, so
 it is best to insert all values of a batch and call this routine once.
 
 */
func sparse_commit(A: UnsafeMutablePointer<Void>) -> sparse_status

/*!
 @abstract
 Returns the value of the given property name.
 
 @param A
 The sparse matrix object.
 
 @param pname
 The property name to get the value of.  See matrix properties enumeration for
 options.
 
 @result
 Returns the value of the property for a valid object and property, or 0 
 otherwise.
 
 @discussion
 Returns the value of the given property name. See matrix properties enumeration
 for further property details.

 */
func sparse_get_matrix_property(A: UnsafeMutablePointer<Void>, _ pname: sparse_matrix_property) -> Int

/*!
 @abstract
 Set the given property for a matrix object that has not had any values 
 inserted.
 
 @param A
 The sparse matrix object.  Note that after elements have been inserted
 properties cannot be changed.
 
 @param pname
 The property name to set true.  See matrix properties enumeration for options.
 
 @result
 Returns SPARSE_SUCCESS when property is successfully set, otherwise return
 SPARSE_CANNOT_SET_PROPERTY.
 
 @discussion
 Set the given property for the matrix object.  The matrix object must not have
 had values inserted, else SPARSE_CANNOT_SET_PROPERTY is returned and the 
 property is not set.
 
 Certain groups of properties are mutually exclusive and setting multiple values
 within a group is undefined.
 
 */
func sparse_set_matrix_property(A: UnsafeMutablePointer<Void>, _ pname: sparse_matrix_property) -> sparse_status

/*!
 @abstract
 Return the number of rows of the matrix.
 */
func sparse_get_matrix_number_of_rows(A: UnsafeMutablePointer<Void>) -> sparse_dimension

/*!
 @abstract
 Return the number of columns of the matrix.
 */
func sparse_get_matrix_number_of_columns(A: UnsafeMutablePointer<Void>) -> sparse_dimension

/*!
 @abstract
 Return the number of nonzero values in the matrix.
 */
func sparse_get_matrix_nonzero_count(A: UnsafeMutablePointer<Void>) -> Int

/*!
 @abstract
 Return the number of nonzero values for the i'th row.  If index is out of
 bounds of the matrix, 0 is returned.
 */
func sparse_get_matrix_nonzero_count_for_row(A: UnsafeMutablePointer<Void>, _ i: sparse_index) -> Int

/*!
 @abstract
 Return the number of nonzero values for the j'th column.  If index is out of
 bounds of the matrix, 0 is returned.
 */
func sparse_get_matrix_nonzero_count_for_column(A: UnsafeMutablePointer<Void>, _ j: sparse_index) -> Int

/*!
 @abstract
 Release any memory associated with the matrix object.
 
 @param A
 The sparse matrix object.
 
 @result
 All memory associated with the matrix object is released and returns 
 SPARSE_SUCCESS.
 
 @discussion
 Release any memory associated with the matrix object.  Upon return the object 
 is no longer valid and any use of the object is undefined.
 
 */
func sparse_matrix_destroy(A: UnsafeMutablePointer<Void>) -> sparse_status

/*!
 @abstract
 Return the number of nonzero values in the dense vector x.
 
 @param N
 The number of elements in the dense vector x.
 
 @param x
 Pointer to the vector x.
 
 @param incx
 Increment between valid values in the dense vector x.  Negative strides are
 supported.
 
 @result
 Return the count of the nonzero values in the vector x.
 
 */
func sparse_get_vector_nonzero_count_float(N: sparse_dimension, _ x: UnsafePointer<Float>, _ incx: sparse_stride) -> Int
func sparse_get_vector_nonzero_count_double(N: sparse_dimension, _ x: UnsafePointer<Double>, _ incx: sparse_stride) -> Int

/*!
 @abstract
 Pack the first nz nonzero values and indices from the dense vector x and
 place them in y and indy.
 
 @param N
 The number of elements in the dense vector x.
 
 @param nz
 The number of nonzero values to collect.  If less than nz nonzero elements are
 found in the N elements of x, then the last nz - actual_nonzero_count of y and
 indy are unused.
 
 @param x
 Pointer to the dense vector x.
 
 @param incx
 Increment between valid values in the dense vector x.  Negative strides are
 supported.
 
 @param y
 The destination dense storage of nonzero values of y.  Expected to be of size
 nz elements.  On return, any nonzero values are placed in this array, if the 
 actual number of nonzero values is less than nz, then the last 
 nz - actual_nonzero_count elements are unused.
 
 @param indy
 The destination dense storage of nonzero indices of y.  Expected to be of size 
 nz elements.  On return, any nonzero indices are placed in this array, if the 
 actual number of nonzero values is less than nz, then the last 
 nz - actual_nonzero_count elements are unused.  Returned indices are 0 based 
 (the first element of a pointer is ptr[0]).
 
 @result
 On success, y and indy are updated with up to the first nz nonzero indices.  
 The number of nonzero values written is returned.
 
 @discussion
 Pack the first nz nonzero values and indices from the dense vector x and
 place them in y and indy.  If less than nz nonzero elements are found in the N 
 elements of x, then the last nz - actual_nonzero_count elements of y and indy 
 are unused.  The number of indices written can range from 0 to nz values and 
 the number written is returned.
 
 */
func sparse_pack_vector_float(N: sparse_dimension, _ nz: sparse_dimension, _ x: UnsafePointer<Float>, _ incx: sparse_stride, _ y: UnsafeMutablePointer<Float>, _ indy: UnsafeMutablePointer<sparse_index>) -> Int
func sparse_pack_vector_double(N: sparse_dimension, _ nz: sparse_dimension, _ x: UnsafePointer<Double>, _ incx: sparse_stride, _ y: UnsafeMutablePointer<Double>, _ indy: UnsafeMutablePointer<sparse_index>) -> Int

/*!
 @abstract
 Extract elements from the sparse vector x into the corresponding location in
 the dense vector y.  Optionally zero the unused values of y.
 
 @param N
 The number of elements in the dense vector y.
 
 @param nz
 The number of nonzero entries in the sparse vector x.
 
 @param zero
 When true, zero the elements of y which do not have nonzero values written to
 them.  When false ignore the elements of y which do not have nonzero values
 written to them.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nz values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param y
 Pointer to the dense vector y.  Expected to be of size N*abs(incy) elements.  
 Negative strides are supported.  Note, unlike dense BLAS routines, the pointer 
 points to the last element when stride is negative. On exit, the entries 
 described by the indices in indx will be filled with the corresponding values 
 in x and all other values will be unchanged if parameter zero is false, or set 
 to zero if parameter zero is true.
 
 @param incy
 Increment between valid values in the dense vector y.  Negative strides are
 supported.
 
 @result
 On exit y has been updated with the nonzero values. If nz is less than or
 equal to zero y is unchanged.
 
 @discussion
 Extract elements from the sparse vector x into the corresponding location in
 the dense vector y.  Optionally zero the unused values of y.
 
 if (zero) for (i in 0 .. N-1) y[i*incy] = 0;
 
 for (i in 0 .. nz-1) if (indx[i] < N) y[indx[i]*incy] = x[i];
 */
func sparse_unpack_vector_float(N: sparse_dimension, _ nz: sparse_dimension, _ zero: Bool, _ x: UnsafePointer<Float>, _ indx: UnsafePointer<sparse_index>, _ y: UnsafeMutablePointer<Float>, _ incy: sparse_stride)
func sparse_unpack_vector_double(N: sparse_dimension, _ nz: sparse_dimension, _ zero: Bool, _ x: UnsafePointer<Double>, _ indx: UnsafePointer<sparse_index>, _ y: UnsafeMutablePointer<Double>, _ incy: sparse_stride)

/*!
 @abstract Sparse matrix type for float.  Opaque structure
 */
typealias sparse_matrix_float = COpaquePointer

/*!
 @abstract Sparse matrix type for double.  Opaque structure
 */
typealias sparse_matrix_double = COpaquePointer

/*!
 @abstract The dimension type. All dimensions are positive values.
 */
typealias sparse_dimension = UInt64

/*!
 @abstract The stride type.  Supports negative strides for the dense vectors.
 */
typealias sparse_stride = Int64

/*!
 @abstract The index type.  All indices including those in a sparse vectors 
 index array are positive values.
 */
typealias sparse_index = Int64

/*!
 @abstract The type reflecting the status of an operations.
 
 @constant SPARSE_SUCCESS
 Operation was a success
 
 @constant SPARSE_ILLEGAL_PARAMETER
 Operation was not completed because one or more of the arguments had an illegal
 value.
 
 @constant SPARSE_CANNOT_SET_PROPERTY
 Matrix properties can only be set before any values are inserted into the
 matrix.  This error occurs if that order is not repsected.
 
 @constant SPARSE_SYSTEM_ERROR
 An internal error has occured, such as non enough memory.
 */
struct sparse_status : RawRepresentable, Equatable {
  init(_ rawValue: Int32)
  init(rawValue: Int32)
  var rawValue: Int32
}
var SPARSE_SUCCESS: sparse_status { get }
var SPARSE_ILLEGAL_PARAMETER: sparse_status { get }
var SPARSE_CANNOT_SET_PROPERTY: sparse_status { get }
var SPARSE_SYSTEM_ERROR: sparse_status { get }

/*!
 @abstract The matrix property type
 */
struct sparse_matrix_property : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var SPARSE_UPPER_TRIANGULAR: sparse_matrix_property { get }
var SPARSE_LOWER_TRIANGULAR: sparse_matrix_property { get }
var SPARSE_UPPER_SYMMETRIC: sparse_matrix_property { get }
var SPARSE_LOWER_SYMMETRIC: sparse_matrix_property { get }

/*!
 @abstract The norm specifier
 @constant SPARSE_NORM_ONE
 Matrix element wise: sum over i,j ( | A[i,j] | )
 
 Matrix operator    : max over j ( sum over i ( | A[i,j] | )
 
 Vector element wise: sum over i ( | x[i] | )
 
 @constant SPARSE_NORM_TWO
 Matrix element wise: sqrt( sum over i,j (A[i,j])^2 )
 
 Matrix operator    : Largest singular value of matrix, note that the operator
 SPARSE_NORM_TWO is significantly more expensive than other norm operations.
 
 Vector element wise: sqrt( sum over i (x[i])^2 )
 
 @constant SPARSE_NORM_INF
 Matrix element wise: max over i,j ( | A[i,j] | )
 
 Matrix operator    : max over i ( sum over j ( | A[i,j] | )
 
 Vector element wise: max over i ( | x[i] | )
 
 @constant SPARSE_NORM_R1
 Matrix element wise: sum over j ( sqrt ( sum over i ( A[i,j]^2 ) ) )
 
 Matrix operator    : Not supported. Undefined
 
 Vector element wise: Not supported. Undefined
 */
struct sparse_norm : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var SPARSE_NORM_ONE: sparse_norm { get }
var SPARSE_NORM_TWO: sparse_norm { get }
var SPARSE_NORM_INF: sparse_norm { get }
var SPARSE_NORM_R1: sparse_norm { get }
struct CBLAS_ORDER : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var CblasRowMajor: CBLAS_ORDER { get }
var CblasColMajor: CBLAS_ORDER { get }
struct CBLAS_TRANSPOSE : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var CblasNoTrans: CBLAS_TRANSPOSE { get }
var CblasTrans: CBLAS_TRANSPOSE { get }
var CblasConjTrans: CBLAS_TRANSPOSE { get }
var AtlasConj: CBLAS_TRANSPOSE { get }
struct CBLAS_UPLO : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var CblasUpper: CBLAS_UPLO { get }
var CblasLower: CBLAS_UPLO { get }
struct CBLAS_DIAG : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var CblasNonUnit: CBLAS_DIAG { get }
var CblasUnit: CBLAS_DIAG { get }
struct CBLAS_SIDE : RawRepresentable, Equatable {
  init(_ rawValue: UInt32)
  init(rawValue: UInt32)
  var rawValue: UInt32
}
var CblasLeft: CBLAS_SIDE { get }
var CblasRight: CBLAS_SIDE { get }
@available(OSX 10.2, *)
func cblas_sdsdot(__N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Y: UnsafePointer<Float>, _ __incY: Int32) -> Float
@available(OSX 10.2, *)
func cblas_dsdot(__N: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Y: UnsafePointer<Float>, _ __incY: Int32) -> Double
@available(OSX 10.2, *)
func cblas_sdot(__N: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Y: UnsafePointer<Float>, _ __incY: Int32) -> Float
@available(OSX 10.2, *)
func cblas_ddot(__N: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __Y: UnsafePointer<Double>, _ __incY: Int32) -> Double
@available(OSX 10.2, *)
func cblas_cdotu_sub(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __dotu: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_cdotc_sub(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __dotc: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_zdotu_sub(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __dotu: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_zdotc_sub(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __dotc: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_snrm2(__N: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32) -> Float
@available(OSX 10.2, *)
func cblas_sasum(__N: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32) -> Float
@available(OSX 10.2, *)
func cblas_dnrm2(__N: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32) -> Double
@available(OSX 10.2, *)
func cblas_dasum(__N: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32) -> Double
@available(OSX 10.2, *)
func cblas_scnrm2(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32) -> Float
@available(OSX 10.2, *)
func cblas_scasum(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32) -> Float
@available(OSX 10.2, *)
func cblas_dznrm2(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32) -> Double
@available(OSX 10.2, *)
func cblas_dzasum(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32) -> Double
@available(OSX 10.2, *)
func cblas_isamax(__N: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32) -> Int32
@available(OSX 10.2, *)
func cblas_idamax(__N: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32) -> Int32
@available(OSX 10.2, *)
func cblas_icamax(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32) -> Int32
@available(OSX 10.2, *)
func cblas_izamax(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32) -> Int32
@available(OSX 10.2, *)
func cblas_sswap(__N: Int32, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_scopy(__N: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_saxpy(__N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func catlas_saxpby(__N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __beta: Float, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func catlas_sset(__N: Int32, _ __alpha: Float, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_dswap(__N: Int32, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_dcopy(__N: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_daxpy(__N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func catlas_daxpby(__N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __beta: Double, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func catlas_dset(__N: Int32, _ __alpha: Double, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_cswap(__N: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_ccopy(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_caxpy(__N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func catlas_caxpby(__N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func catlas_cset(__N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_zswap(__N: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_zcopy(__N: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_zaxpy(__N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func catlas_zaxpby(__N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func catlas_zset(__N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_srotg(__a: UnsafeMutablePointer<Float>, _ __b: UnsafeMutablePointer<Float>, _ __c: UnsafeMutablePointer<Float>, _ __s: UnsafeMutablePointer<Float>)
@available(OSX 10.2, *)
func cblas_srotmg(__d1: UnsafeMutablePointer<Float>, _ __d2: UnsafeMutablePointer<Float>, _ __b1: UnsafeMutablePointer<Float>, _ __b2: Float, _ __P: UnsafeMutablePointer<Float>)
@available(OSX 10.2, *)
func cblas_srot(__N: Int32, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32, _ __c: Float, _ __s: Float)
@available(OSX 10.2, *)
func cblas_srotm(__N: Int32, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32, _ __P: UnsafePointer<Float>)
@available(OSX 10.2, *)
func cblas_drotg(__a: UnsafeMutablePointer<Double>, _ __b: UnsafeMutablePointer<Double>, _ __c: UnsafeMutablePointer<Double>, _ __s: UnsafeMutablePointer<Double>)
@available(OSX 10.2, *)
func cblas_drotmg(__d1: UnsafeMutablePointer<Double>, _ __d2: UnsafeMutablePointer<Double>, _ __b1: UnsafeMutablePointer<Double>, _ __b2: Double, _ __P: UnsafeMutablePointer<Double>)
@available(OSX 10.2, *)
func cblas_drot(__N: Int32, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32, _ __c: Double, _ __s: Double)
@available(OSX 10.2, *)
func cblas_drotm(__N: Int32, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32, _ __P: UnsafePointer<Double>)
@available(OSX 10.2, *)
func cblas_sscal(__N: Int32, _ __alpha: Float, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_dscal(__N: Int32, _ __alpha: Double, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_cscal(__N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_zscal(__N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_csscal(__N: Int32, _ __alpha: Float, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_zdscal(__N: Int32, _ __alpha: Double, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_crotg(__a: UnsafeMutablePointer<Void>, _ __b: UnsafeMutablePointer<Void>, _ __c: UnsafeMutablePointer<Void>, _ __s: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_zrotg(__a: UnsafeMutablePointer<Void>, _ __b: UnsafeMutablePointer<Void>, _ __c: UnsafeMutablePointer<Void>, _ __s: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_csrot(__N: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32, _ __c: Float, _ __s: Float)
@available(OSX 10.2, *)
func cblas_zdrot(__N: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32, _ __c: Double, _ __s: Double)
@available(OSX 10.2, *)
func cblas_sgemv(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __beta: Float, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_sgbmv(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __KL: Int32, _ __KU: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __beta: Float, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_strmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_stbmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __K: Int32, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_stpmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __Ap: UnsafePointer<Float>, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_strsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_stbsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __K: Int32, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_stpsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __Ap: UnsafePointer<Float>, _ __X: UnsafeMutablePointer<Float>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_dgemv(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __beta: Double, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_dgbmv(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __KL: Int32, _ __KU: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __beta: Double, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_dtrmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_dtbmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __K: Int32, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_dtpmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __Ap: UnsafePointer<Double>, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_dtrsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_dtbsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __K: Int32, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_dtpsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __Ap: UnsafePointer<Double>, _ __X: UnsafeMutablePointer<Double>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_cgemv(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_cgbmv(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __KL: Int32, _ __KU: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_ctrmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ctbmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __K: Int32, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ctpmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __Ap: UnsafePointer<Void>, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ctrsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ctbsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __K: Int32, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ctpsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __Ap: UnsafePointer<Void>, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_zgemv(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_zgbmv(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __KL: Int32, _ __KU: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_ztrmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ztbmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __K: Int32, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ztpmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __Ap: UnsafePointer<Void>, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ztrsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ztbsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __K: Int32, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ztpsv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __N: Int32, _ __Ap: UnsafePointer<Void>, _ __X: UnsafeMutablePointer<Void>, _ __incX: Int32)
@available(OSX 10.2, *)
func cblas_ssymv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __beta: Float, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_ssbmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __K: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __beta: Float, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_sspmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Float, _ __Ap: UnsafePointer<Float>, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __beta: Float, _ __Y: UnsafeMutablePointer<Float>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_sger(__Order: CBLAS_ORDER, _ __M: Int32, _ __N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Y: UnsafePointer<Float>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Float>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_ssyr(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __A: UnsafeMutablePointer<Float>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_sspr(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Ap: UnsafeMutablePointer<Float>)
@available(OSX 10.2, *)
func cblas_ssyr2(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Y: UnsafePointer<Float>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Float>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_sspr2(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Float>, _ __incX: Int32, _ __Y: UnsafePointer<Float>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Float>)
@available(OSX 10.2, *)
func cblas_dsymv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __beta: Double, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_dsbmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __K: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __beta: Double, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_dspmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Double, _ __Ap: UnsafePointer<Double>, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __beta: Double, _ __Y: UnsafeMutablePointer<Double>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_dger(__Order: CBLAS_ORDER, _ __M: Int32, _ __N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __Y: UnsafePointer<Double>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Double>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_dsyr(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __A: UnsafeMutablePointer<Double>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_dspr(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __Ap: UnsafeMutablePointer<Double>)
@available(OSX 10.2, *)
func cblas_dsyr2(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __Y: UnsafePointer<Double>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Double>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_dspr2(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Double>, _ __incX: Int32, _ __Y: UnsafePointer<Double>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Double>)
@available(OSX 10.2, *)
func cblas_chemv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_chbmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_chpmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __Ap: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_cgeru(__Order: CBLAS_ORDER, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Void>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_cgerc(__Order: CBLAS_ORDER, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Void>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_cher(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __A: UnsafeMutablePointer<Void>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_chpr(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Float, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __A: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_cher2(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Void>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_chpr2(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __Ap: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_zhemv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_zhbmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_zhpmv(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __Ap: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __beta: UnsafePointer<Void>, _ __Y: UnsafeMutablePointer<Void>, _ __incY: Int32)
@available(OSX 10.2, *)
func cblas_zgeru(__Order: CBLAS_ORDER, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Void>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_zgerc(__Order: CBLAS_ORDER, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Void>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_zher(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __A: UnsafeMutablePointer<Void>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_zhpr(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: Double, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __A: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_zher2(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __A: UnsafeMutablePointer<Void>, _ __lda: Int32)
@available(OSX 10.2, *)
func cblas_zhpr2(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __X: UnsafePointer<Void>, _ __incX: Int32, _ __Y: UnsafePointer<Void>, _ __incY: Int32, _ __Ap: UnsafeMutablePointer<Void>)
@available(OSX 10.2, *)
func cblas_sgemm(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __TransB: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __K: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __B: UnsafePointer<Float>, _ __ldb: Int32, _ __beta: Float, _ __C: UnsafeMutablePointer<Float>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_ssymm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __M: Int32, _ __N: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __B: UnsafePointer<Float>, _ __ldb: Int32, _ __beta: Float, _ __C: UnsafeMutablePointer<Float>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_ssyrk(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __beta: Float, _ __C: UnsafeMutablePointer<Float>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_ssyr2k(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __B: UnsafePointer<Float>, _ __ldb: Int32, _ __beta: Float, _ __C: UnsafeMutablePointer<Float>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_strmm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __M: Int32, _ __N: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __B: UnsafeMutablePointer<Float>, _ __ldb: Int32)
@available(OSX 10.2, *)
func cblas_strsm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __M: Int32, _ __N: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __B: UnsafeMutablePointer<Float>, _ __ldb: Int32)
@available(OSX 10.2, *)
func cblas_dgemm(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __TransB: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __K: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __B: UnsafePointer<Double>, _ __ldb: Int32, _ __beta: Double, _ __C: UnsafeMutablePointer<Double>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_dsymm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __M: Int32, _ __N: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __B: UnsafePointer<Double>, _ __ldb: Int32, _ __beta: Double, _ __C: UnsafeMutablePointer<Double>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_dsyrk(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __beta: Double, _ __C: UnsafeMutablePointer<Double>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_dsyr2k(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __B: UnsafePointer<Double>, _ __ldb: Int32, _ __beta: Double, _ __C: UnsafeMutablePointer<Double>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_dtrmm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __M: Int32, _ __N: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __B: UnsafeMutablePointer<Double>, _ __ldb: Int32)
@available(OSX 10.2, *)
func cblas_dtrsm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __M: Int32, _ __N: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __B: UnsafeMutablePointer<Double>, _ __ldb: Int32)
@available(OSX 10.2, *)
func cblas_cgemm(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __TransB: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_csymm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_csyrk(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_csyr2k(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_ctrmm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafeMutablePointer<Void>, _ __ldb: Int32)
@available(OSX 10.2, *)
func cblas_ctrsm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafeMutablePointer<Void>, _ __ldb: Int32)
@available(OSX 10.2, *)
func cblas_zgemm(__Order: CBLAS_ORDER, _ __TransA: CBLAS_TRANSPOSE, _ __TransB: CBLAS_TRANSPOSE, _ __M: Int32, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_zsymm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_zsyrk(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_zsyr2k(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_ztrmm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafeMutablePointer<Void>, _ __ldb: Int32)
@available(OSX 10.2, *)
func cblas_ztrsm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __TransA: CBLAS_TRANSPOSE, _ __Diag: CBLAS_DIAG, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafeMutablePointer<Void>, _ __ldb: Int32)
@available(OSX 10.2, *)
func cblas_chemm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_cherk(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: Float, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __beta: Float, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_cher2k(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: Float, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_zhemm(__Order: CBLAS_ORDER, _ __Side: CBLAS_SIDE, _ __Uplo: CBLAS_UPLO, _ __M: Int32, _ __N: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: UnsafePointer<Void>, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_zherk(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: Double, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __beta: Double, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.2, *)
func cblas_zher2k(__Order: CBLAS_ORDER, _ __Uplo: CBLAS_UPLO, _ __Trans: CBLAS_TRANSPOSE, _ __N: Int32, _ __K: Int32, _ __alpha: UnsafePointer<Void>, _ __A: UnsafePointer<Void>, _ __lda: Int32, _ __B: UnsafePointer<Void>, _ __ldb: Int32, _ __beta: Double, _ __C: UnsafeMutablePointer<Void>, _ __ldc: Int32)
@available(OSX 10.10, *)
func appleblas_sgeadd(__order: CBLAS_ORDER, _ __transA: CBLAS_TRANSPOSE, _ __transB: CBLAS_TRANSPOSE, _ __m: Int32, _ __n: Int32, _ __alpha: Float, _ __A: UnsafePointer<Float>, _ __lda: Int32, _ __beta: Float, _ __B: UnsafePointer<Float>, _ __ldb: Int32, _ __C: UnsafeMutablePointer<Float>, _ __ldc: Int32)
@available(OSX 10.10, *)
func appleblas_dgeadd(__order: CBLAS_ORDER, _ __transA: CBLAS_TRANSPOSE, _ __transB: CBLAS_TRANSPOSE, _ __m: Int32, _ __n: Int32, _ __alpha: Double, _ __A: UnsafePointer<Double>, _ __lda: Int32, _ __beta: Double, _ __B: UnsafePointer<Double>, _ __ldb: Int32, _ __C: UnsafeMutablePointer<Double>, _ __ldc: Int32)
typealias BLASParamErrorProc = @convention(c) (UnsafePointer<Int8>, UnsafePointer<Int8>, UnsafePointer<Int32>, UnsafePointer<Int32>) -> Void
@available(OSX 10.2, *)
func SetBLASParamErrorProc(__ErrorProc: BLASParamErrorProc!)
typealias __CLPK_integer = Int32
typealias __CLPK_logical = Int32
typealias __CLPK_real = Float
typealias __CLPK_doublereal = Double
typealias __CLPK_L_fp = @convention(c) () -> __CLPK_logical
typealias __CLPK_ftnlen = Int32
struct __CLPK_complex {
  var r: __CLPK_real
  var i: __CLPK_real
  init()
  init(r: __CLPK_real, i: __CLPK_real)
}
struct __CLPK_doublecomplex {
  var r: __CLPK_doublereal
  var i: __CLPK_doublereal
  init()
  init(r: __CLPK_doublereal, i: __CLPK_doublereal)
}
@available(OSX 10.2, *)
func cbdsqr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncvt: UnsafeMutablePointer<__CLPK_integer>, _ __nru: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vt: UnsafeMutablePointer<__CLPK_complex>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_complex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbbrd_(__vect: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __pt: UnsafeMutablePointer<__CLPK_complex>, _ __ldpt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbcon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbequ_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbequb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbrfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_complex>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbsvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_complex>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbtf2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbtrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgbtrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgebak_(__job: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgebal_(__job: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgebd2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tauq: UnsafeMutablePointer<__CLPK_complex>, _ __taup: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgebrd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tauq: UnsafeMutablePointer<__CLPK_complex>, _ __taup: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgecon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeequ_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeequb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgees_(__jobvs: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __select: __CLPK_L_fp!, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __vs: UnsafeMutablePointer<__CLPK_complex>, _ __ldvs: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeesx_(__jobvs: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __select: __CLPK_L_fp!, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __vs: UnsafeMutablePointer<__CLPK_complex>, _ __ldvs: UnsafeMutablePointer<__CLPK_integer>, _ __rconde: UnsafeMutablePointer<__CLPK_real>, _ __rcondv: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeev_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeevx_(__balanc: UnsafeMutablePointer<Int8>, _ __jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __abnrm: UnsafeMutablePointer<__CLPK_real>, _ __rconde: UnsafeMutablePointer<__CLPK_real>, _ __rcondv: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgegs_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __vsl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgegv_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgehd2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgehrd_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgelq2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgelqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgels_(__trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgelsd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgelss_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgelsx_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgelsy_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeql2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeqlf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeqp3_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeqpf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeqr2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgeqrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgerfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_complex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgerq2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgerqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgesc2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __rhs: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func cgesdd_(__jobz: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_complex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_complex>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgesv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgesvd_(__jobu: UnsafeMutablePointer<Int8>, _ __jobvt: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_complex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_complex>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgesvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_complex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgetc2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgetf2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgetrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgetri_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgetrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggbak_(__job: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_real>, _ __rscale: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggbal_(__job: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_real>, _ __rscale: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgges_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __selctg: __CLPK_L_fp!, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __vsl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggesx_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __selctg: __CLPK_L_fp!, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __vsl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __rconde: UnsafeMutablePointer<__CLPK_real>, _ __rcondv: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggev_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggevx_(__balanc: UnsafeMutablePointer<Int8>, _ __jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_real>, _ __rscale: UnsafeMutablePointer<__CLPK_real>, _ __abnrm: UnsafeMutablePointer<__CLPK_real>, _ __bbnrm: UnsafeMutablePointer<__CLPK_real>, _ __rconde: UnsafeMutablePointer<__CLPK_real>, _ __rcondv: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggglm_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgghrd_(__compq: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgglse_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggqrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __taua: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __taub: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggrqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __taua: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __taub: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggsvd_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_complex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cggsvp_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __tola: UnsafeMutablePointer<__CLPK_real>, _ __tolb: UnsafeMutablePointer<__CLPK_real>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_complex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgtcon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>, _ __du2: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgtrfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>, _ __dlf: UnsafeMutablePointer<__CLPK_complex>, _ __df: UnsafeMutablePointer<__CLPK_complex>, _ __duf: UnsafeMutablePointer<__CLPK_complex>, _ __du2: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgtsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgtsvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>, _ __dlf: UnsafeMutablePointer<__CLPK_complex>, _ __df: UnsafeMutablePointer<__CLPK_complex>, _ __duf: UnsafeMutablePointer<__CLPK_complex>, _ __du2: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgttrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>, _ __du2: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgttrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>, _ __du2: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cgtts2_(__itrans: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>, _ __du2: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chbev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chbevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chbevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chbgst_(__vect: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_complex>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chbgv_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_complex>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chbgvd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_complex>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chbgvx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_complex>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chbtrd_(__vect: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func checon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cheequb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cheev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cheevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cheevr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cheevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chegs2_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chegst_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chegv_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chegvd_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chegvx_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cherfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_complex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chesv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chesvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_complex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chetd2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chetf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chetrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chetrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chetri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chetrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chfrk_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func chgeqz_(__job: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chla_transtype__(__ret_val: UnsafeMutablePointer<Int8>, _ __ret_val_len: __CLPK_ftnlen, _ __trans: UnsafeMutablePointer<__CLPK_integer>)
@available(OSX 10.2, *)
func chpcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpgst_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __bp: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpgv_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __bp: UnsafeMutablePointer<__CLPK_complex>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpgvd_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __bp: UnsafeMutablePointer<__CLPK_complex>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpgvx_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __bp: UnsafeMutablePointer<__CLPK_complex>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __afp: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chpsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __afp: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chptrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chsein_(__side: UnsafeMutablePointer<Int8>, _ __eigsrc: UnsafeMutablePointer<Int8>, _ __initv: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __ifaill: UnsafeMutablePointer<__CLPK_integer>, _ __ifailr: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func chseqr_(__job: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clabrd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tauq: UnsafeMutablePointer<__CLPK_complex>, _ __taup: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clacgv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clacn2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __est: UnsafeMutablePointer<__CLPK_real>, _ __kase: UnsafeMutablePointer<__CLPK_integer>, _ __isave: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clacon_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __est: UnsafeMutablePointer<__CLPK_real>, _ __kase: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clacp2_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clacpy_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clacrm_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func clacrt_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cx: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __cy: UnsafeMutablePointer<__CLPK_complex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __s: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func cladiv_(__ret_val: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __y: UnsafeMutablePointer<__CLPK_complex>)
@available(OSX 10.2, *)
func claed0_(__qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __qstore: UnsafeMutablePointer<__CLPK_complex>, _ __ldqs: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claed7_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __tlvls: UnsafeMutablePointer<__CLPK_integer>, _ __curlvl: UnsafeMutablePointer<__CLPK_integer>, _ __curpbm: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __qstore: UnsafeMutablePointer<__CLPK_real>, _ __qptr: UnsafeMutablePointer<__CLPK_integer>, _ __prmptr: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claed8_(__k: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __dlamda: UnsafeMutablePointer<__CLPK_real>, _ __q2: UnsafeMutablePointer<__CLPK_complex>, _ __ldq2: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __indxp: UnsafeMutablePointer<__CLPK_integer>, _ __indx: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claein_(__rightv: UnsafeMutablePointer<__CLPK_logical>, _ __noinit: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __eps3: UnsafeMutablePointer<__CLPK_real>, _ __smlnum: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claesy_(__a: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __rt1: UnsafeMutablePointer<__CLPK_complex>, _ __rt2: UnsafeMutablePointer<__CLPK_complex>, _ __evscal: UnsafeMutablePointer<__CLPK_complex>, _ __cs1: UnsafeMutablePointer<__CLPK_complex>, _ __sn1: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func claev2_(__a: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __rt1: UnsafeMutablePointer<__CLPK_real>, _ __rt2: UnsafeMutablePointer<__CLPK_real>, _ __cs1: UnsafeMutablePointer<__CLPK_real>, _ __sn1: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clag2z_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_complex>, _ __ldsa: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clags2_(__upper: UnsafeMutablePointer<__CLPK_logical>, _ __a1: UnsafeMutablePointer<__CLPK_real>, _ __a2: UnsafeMutablePointer<__CLPK_complex>, _ __a3: UnsafeMutablePointer<__CLPK_real>, _ __b1: UnsafeMutablePointer<__CLPK_real>, _ __b2: UnsafeMutablePointer<__CLPK_complex>, _ __b3: UnsafeMutablePointer<__CLPK_real>, _ __csu: UnsafeMutablePointer<__CLPK_real>, _ __snu: UnsafeMutablePointer<__CLPK_complex>, _ __csv: UnsafeMutablePointer<__CLPK_real>, _ __snv: UnsafeMutablePointer<__CLPK_complex>, _ __csq: UnsafeMutablePointer<__CLPK_real>, _ __snq: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clagtm_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clahef_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clahqr_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clahr2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clahrd_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claic1_(__job: UnsafeMutablePointer<__CLPK_integer>, _ __j: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __sest: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __gamma: UnsafeMutablePointer<__CLPK_complex>, _ __sestpr: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clals0_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __bx: UnsafeMutablePointer<__CLPK_complex>, _ __ldbx: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __ldgnum: UnsafeMutablePointer<__CLPK_integer>, _ __poles: UnsafeMutablePointer<__CLPK_real>, _ __difl: UnsafeMutablePointer<__CLPK_real>, _ __difr: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clalsa_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __bx: UnsafeMutablePointer<__CLPK_complex>, _ __ldbx: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __difl: UnsafeMutablePointer<__CLPK_real>, _ __difr: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __poles: UnsafeMutablePointer<__CLPK_real>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clalsd_(__uplo: UnsafeMutablePointer<Int8>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clangb_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clange_(__norm: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clangt_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_complex>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __du: UnsafeMutablePointer<__CLPK_complex>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clanhb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clanhe_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clanhf_(__norm: UnsafeMutablePointer<Int8>, _ __transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clanhp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clanhs_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clanht_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_complex>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clansb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clansp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clansy_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clantb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clantp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clantr_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func clapll_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __ssmin: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func clapmt_(__forwrd: UnsafeMutablePointer<__CLPK_logical>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claqgb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func claqge_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func claqhb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func claqhe_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func claqhp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func claqp2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __vn1: UnsafeMutablePointer<__CLPK_real>, _ __vn2: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func claqps_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __vn1: UnsafeMutablePointer<__CLPK_real>, _ __vn2: UnsafeMutablePointer<__CLPK_real>, _ __auxv: UnsafeMutablePointer<__CLPK_complex>, _ __f: UnsafeMutablePointer<__CLPK_complex>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claqr0_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claqr1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __s1: UnsafeMutablePointer<__CLPK_complex>, _ __s2: UnsafeMutablePointer<__CLPK_complex>, _ __v: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func claqr2_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ns: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __sh: UnsafeMutablePointer<__CLPK_complex>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_complex>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claqr3_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ns: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __sh: UnsafeMutablePointer<__CLPK_complex>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_complex>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claqr4_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claqr5_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __kacc22: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nshfts: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_complex>, _ __h__: UnsafeMutablePointer<__CLPK_complex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_complex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_complex>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __wh: UnsafeMutablePointer<__CLPK_complex>, _ __ldwh: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claqsb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func claqsp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func claqsy_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func clar1v_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __b1: UnsafeMutablePointer<__CLPK_integer>, _ __bn: UnsafeMutablePointer<__CLPK_integer>, _ __lambda: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __l: UnsafeMutablePointer<__CLPK_real>, _ __ld: UnsafeMutablePointer<__CLPK_real>, _ __lld: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __gaptol: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __wantnc: UnsafeMutablePointer<__CLPK_logical>, _ __negcnt: UnsafeMutablePointer<__CLPK_integer>, _ __ztz: UnsafeMutablePointer<__CLPK_real>, _ __mingma: UnsafeMutablePointer<__CLPK_real>, _ __r__: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __nrminv: UnsafeMutablePointer<__CLPK_real>, _ __resid: UnsafeMutablePointer<__CLPK_real>, _ __rqcorr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func clar2v_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_complex>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clarcm_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func clarf_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clarfb_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clarfg_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clarfp_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clarft_(__direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clarfx_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clargv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clarnv_(__idist: UnsafeMutablePointer<__CLPK_integer>, _ __iseed: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clarrv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __l: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __dol: UnsafeMutablePointer<__CLPK_integer>, _ __dou: UnsafeMutablePointer<__CLPK_integer>, _ __minrgp: UnsafeMutablePointer<__CLPK_real>, _ __rtol1: UnsafeMutablePointer<__CLPK_real>, _ __rtol2: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __werr: UnsafeMutablePointer<__CLPK_real>, _ __wgap: UnsafeMutablePointer<__CLPK_real>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __indexw: UnsafeMutablePointer<__CLPK_integer>, _ __gers: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clarscl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clartg_(__f: UnsafeMutablePointer<__CLPK_complex>, _ __g: UnsafeMutablePointer<__CLPK_complex>, _ __cs: UnsafeMutablePointer<__CLPK_real>, _ __sn: UnsafeMutablePointer<__CLPK_complex>, _ __r__: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clartv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_complex>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clarz_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clarzb_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clarzt_(__direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clascl_(__type__: UnsafeMutablePointer<Int8>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __cfrom: UnsafeMutablePointer<__CLPK_real>, _ __cto: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clascl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func claset_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clasr_(__side: UnsafeMutablePointer<Int8>, _ __pivot: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func classq_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __sumsq: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func claswp_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __k1: UnsafeMutablePointer<__CLPK_integer>, _ __k2: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clasyf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clatbs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __cnorm: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clatdf_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __rhs: UnsafeMutablePointer<__CLPK_complex>, _ __rdsum: UnsafeMutablePointer<__CLPK_real>, _ __rdscal: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clatps_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __cnorm: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clatrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clatrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __cnorm: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clatrz_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clatzm_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c1: UnsafeMutablePointer<__CLPK_complex>, _ __c2: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func clauu2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func clauum_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbequ_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_complex>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbstf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_complex>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbtf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbtrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpbtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpftrf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpftri_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpftrs_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpocon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpoequ_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpoequb_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cporfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_complex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cposv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cposvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_complex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpotf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpotrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpotri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpotrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cppcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cppequ_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __afp: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cppsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cppsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __afp: UnsafeMutablePointer<__CLPK_complex>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpstf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __piv: UnsafeMutablePointer<__CLPK_integer>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __tol: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpstrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __piv: UnsafeMutablePointer<__CLPK_integer>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __tol: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cptcon_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpteqr_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cptrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __df: UnsafeMutablePointer<__CLPK_real>, _ __ef: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cptsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cptsvx_(__fact: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __df: UnsafeMutablePointer<__CLPK_real>, _ __ef: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpttrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cpttrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cptts2_(__iuplo: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func crot_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cx: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __cy: UnsafeMutablePointer<__CLPK_complex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func cspcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cspmv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cspr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>) -> Int32
@available(OSX 10.2, *)
func csprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __afp: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cspsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cspsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __afp: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csrscl_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_real>, _ __sx: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cstedc_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cstegr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cstein_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cstemr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __nzc: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __tryrac: UnsafeMutablePointer<__CLPK_logical>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csteqr_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csycon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csyequb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csymv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __y: UnsafeMutablePointer<__CLPK_complex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csyr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csyrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_complex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csysv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csysvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_complex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csytf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csytrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csytri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func csytrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctbcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctbrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctbtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_complex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctfsm_(__transr: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctftri_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctfttp_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_complex>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctfttr_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_complex>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctgevc_(__side: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_complex>, _ __lds: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_complex>, _ __ldp: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctgex2_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __j1: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctgexc_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ifst: UnsafeMutablePointer<__CLPK_integer>, _ __ilst: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctgsen_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_complex>, _ __beta: UnsafeMutablePointer<__CLPK_complex>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_complex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __pl: UnsafeMutablePointer<__CLPK_real>, _ __pr: UnsafeMutablePointer<__CLPK_real>, _ __dif: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctgsja_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __tola: UnsafeMutablePointer<__CLPK_real>, _ __tolb: UnsafeMutablePointer<__CLPK_real>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_complex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_complex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __ncycle: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctgsna_(__job: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __dif: UnsafeMutablePointer<__CLPK_real>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctgsy2_(__trans: UnsafeMutablePointer<Int8>, _ __ijob: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __ldd: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __lde: UnsafeMutablePointer<__CLPK_integer>, _ __f: UnsafeMutablePointer<__CLPK_complex>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __rdsum: UnsafeMutablePointer<__CLPK_real>, _ __rdscal: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctgsyl_(__trans: UnsafeMutablePointer<Int8>, _ __ijob: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_complex>, _ __ldd: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_complex>, _ __lde: UnsafeMutablePointer<__CLPK_integer>, _ __f: UnsafeMutablePointer<__CLPK_complex>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __dif: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctpcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctptri_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctpttf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __arf: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctpttr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrevc_(__side: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrexc_(__compq: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __ifst: UnsafeMutablePointer<__CLPK_integer>, _ __ilst: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_complex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrsen_(__job: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_complex>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __sep: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrsna_(__job: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_complex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_complex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_complex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __sep: UnsafeMutablePointer<__CLPK_real>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrsyl_(__trana: UnsafeMutablePointer<Int8>, _ __tranb: UnsafeMutablePointer<Int8>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrti2_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrtri_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_complex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrttf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctrttp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctzrqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ctzrzf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cung2l_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cung2r_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cungbr_(__vect: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunghr_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cungl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunglq_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cungql_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cungqr_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cungr2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cungrq_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cungtr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunm2l_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunm2r_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmbr_(__vect: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmhr_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunml2_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmlq_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmql_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmqr_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmr2_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmr3_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmrq_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmrz_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cunmtr_(__side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cupgtr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __q: UnsafeMutablePointer<__CLPK_complex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func cupmtr_(__side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_complex>, _ __tau: UnsafeMutablePointer<__CLPK_complex>, _ __c__: UnsafeMutablePointer<__CLPK_complex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_complex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dbdsdc_(__uplo: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __iq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dbdsqr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncvt: UnsafeMutablePointer<__CLPK_integer>, _ __nru: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ddisna_(__job: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __sep: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbbrd_(__vect: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __pt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldpt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbcon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbequ_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbequb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbrfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbsvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbtf2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbtrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgbtrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgebak_(__job: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgebal_(__job: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgebd2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tauq: UnsafeMutablePointer<__CLPK_doublereal>, _ __taup: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgebrd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tauq: UnsafeMutablePointer<__CLPK_doublereal>, _ __taup: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgecon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeequ_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeequb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgees_(__jobvs: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __select: __CLPK_L_fp!, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __vs: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvs: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeesx_(__jobvs: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __select: __CLPK_L_fp!, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __vs: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvs: UnsafeMutablePointer<__CLPK_integer>, _ __rconde: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcondv: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeev_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeevx_(__balanc: UnsafeMutablePointer<Int8>, _ __jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __abnrm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rconde: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcondv: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgegs_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __vsl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgegv_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgehd2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgehrd_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgejsv_(__joba: UnsafeMutablePointer<Int8>, _ __jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobr: UnsafeMutablePointer<Int8>, _ __jobt: UnsafeMutablePointer<Int8>, _ __jobp: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sva: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgelq2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgelqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgels_(__trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgelsd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgelss_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgelsx_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgelsy_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeql2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeqlf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeqp3_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeqpf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeqr2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgeqrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgerfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgerq2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgerqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgesc2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __rhs: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dgesdd_(__jobz: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgesv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgesvd_(__jobu: UnsafeMutablePointer<Int8>, _ __jobvt: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgesvj_(__joba: UnsafeMutablePointer<Int8>, _ __jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sva: UnsafeMutablePointer<__CLPK_doublereal>, _ __mv: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgesvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgetc2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgetf2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgetrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgetri_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgetrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggbak_(__job: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __rscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggbal_(__job: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __rscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgges_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __selctg: __CLPK_L_fp!, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __vsl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggesx_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __selctg: __CLPK_L_fp!, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __vsl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __rconde: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcondv: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggev_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggevx_(__balanc: UnsafeMutablePointer<Int8>, _ __jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __rscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __abnrm: UnsafeMutablePointer<__CLPK_doublereal>, _ __bbnrm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rconde: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcondv: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggglm_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgghrd_(__compq: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgglse_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggqrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __taua: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __taub: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggrqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __taua: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __taub: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggsvd_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dggsvp_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __tola: UnsafeMutablePointer<__CLPK_doublereal>, _ __tolb: UnsafeMutablePointer<__CLPK_doublereal>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgsvj0_(__jobv: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __sva: UnsafeMutablePointer<__CLPK_doublereal>, _ __mv: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __eps: UnsafeMutablePointer<__CLPK_doublereal>, _ __sfmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __tol: UnsafeMutablePointer<__CLPK_doublereal>, _ __nsweep: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgsvj1_(__jobv: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __sva: UnsafeMutablePointer<__CLPK_doublereal>, _ __mv: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __eps: UnsafeMutablePointer<__CLPK_doublereal>, _ __sfmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __tol: UnsafeMutablePointer<__CLPK_doublereal>, _ __nsweep: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgtcon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>, _ __du2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgtrfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlf: UnsafeMutablePointer<__CLPK_doublereal>, _ __df: UnsafeMutablePointer<__CLPK_doublereal>, _ __duf: UnsafeMutablePointer<__CLPK_doublereal>, _ __du2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgtsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgtsvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlf: UnsafeMutablePointer<__CLPK_doublereal>, _ __df: UnsafeMutablePointer<__CLPK_doublereal>, _ __duf: UnsafeMutablePointer<__CLPK_doublereal>, _ __du2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgttrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>, _ __du2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgttrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>, _ __du2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dgtts2_(__itrans: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>, _ __du2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dhgeqz_(__job: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dhsein_(__side: UnsafeMutablePointer<Int8>, _ __eigsrc: UnsafeMutablePointer<Int8>, _ __initv: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __ifaill: UnsafeMutablePointer<__CLPK_integer>, _ __ifailr: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dhseqr_(__job: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func disnan_(__din: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_logical
@available(OSX 10.2, *)
func dlabad_(__small: UnsafeMutablePointer<__CLPK_doublereal>, _ __large: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlabrd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tauq: UnsafeMutablePointer<__CLPK_doublereal>, _ __taup: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlacn2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __est: UnsafeMutablePointer<__CLPK_doublereal>, _ __kase: UnsafeMutablePointer<__CLPK_integer>, _ __isave: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlacon_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __est: UnsafeMutablePointer<__CLPK_doublereal>, _ __kase: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlacpy_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dladiv_(__a: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __p: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlae2_(__a: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt1: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt2: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlaebz_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __nitmax: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __mmax: UnsafeMutablePointer<__CLPK_integer>, _ __minp: UnsafeMutablePointer<__CLPK_integer>, _ __nbmin: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __reltol: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __e2: UnsafeMutablePointer<__CLPK_doublereal>, _ __nval: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __mout: UnsafeMutablePointer<__CLPK_integer>, _ __nab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed0_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __qstore: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldqs: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed2_(__k: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlamda: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __q2: UnsafeMutablePointer<__CLPK_doublereal>, _ __indx: UnsafeMutablePointer<__CLPK_integer>, _ __indxc: UnsafeMutablePointer<__CLPK_integer>, _ __indxp: UnsafeMutablePointer<__CLPK_integer>, _ __coltyp: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed3_(__k: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlamda: UnsafeMutablePointer<__CLPK_doublereal>, _ __q2: UnsafeMutablePointer<__CLPK_doublereal>, _ __indx: UnsafeMutablePointer<__CLPK_integer>, _ __ctot: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed4_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __i__: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __delta: UnsafeMutablePointer<__CLPK_doublereal>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlam: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed5_(__i__: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __delta: UnsafeMutablePointer<__CLPK_doublereal>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlam: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlaed6_(__kniter: UnsafeMutablePointer<__CLPK_integer>, _ __orgati: UnsafeMutablePointer<__CLPK_logical>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __finit: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed7_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __tlvls: UnsafeMutablePointer<__CLPK_integer>, _ __curlvl: UnsafeMutablePointer<__CLPK_integer>, _ __curpbm: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __qstore: UnsafeMutablePointer<__CLPK_doublereal>, _ __qptr: UnsafeMutablePointer<__CLPK_integer>, _ __prmptr: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed8_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlamda: UnsafeMutablePointer<__CLPK_doublereal>, _ __q2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq2: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __indxp: UnsafeMutablePointer<__CLPK_integer>, _ __indx: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaed9_(__k: UnsafeMutablePointer<__CLPK_integer>, _ __kstart: UnsafeMutablePointer<__CLPK_integer>, _ __kstop: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlamda: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __lds: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaeda_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __tlvls: UnsafeMutablePointer<__CLPK_integer>, _ __curlvl: UnsafeMutablePointer<__CLPK_integer>, _ __curpbm: UnsafeMutablePointer<__CLPK_integer>, _ __prmptr: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __qptr: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ztemp: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaein_(__rightv: UnsafeMutablePointer<__CLPK_logical>, _ __noinit: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __vi: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __eps3: UnsafeMutablePointer<__CLPK_doublereal>, _ __smlnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __bignum: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaev2_(__a: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt1: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt2: UnsafeMutablePointer<__CLPK_doublereal>, _ __cs1: UnsafeMutablePointer<__CLPK_doublereal>, _ __sn1: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlaexc_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __j1: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlag2_(__a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __safmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __scale1: UnsafeMutablePointer<__CLPK_doublereal>, _ __scale2: UnsafeMutablePointer<__CLPK_doublereal>, _ __wr1: UnsafeMutablePointer<__CLPK_doublereal>, _ __wr2: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlag2s_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_real>, _ __ldsa: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlags2_(__upper: UnsafeMutablePointer<__CLPK_logical>, _ __a1: UnsafeMutablePointer<__CLPK_doublereal>, _ __a2: UnsafeMutablePointer<__CLPK_doublereal>, _ __a3: UnsafeMutablePointer<__CLPK_doublereal>, _ __b1: UnsafeMutablePointer<__CLPK_doublereal>, _ __b2: UnsafeMutablePointer<__CLPK_doublereal>, _ __b3: UnsafeMutablePointer<__CLPK_doublereal>, _ __csu: UnsafeMutablePointer<__CLPK_doublereal>, _ __snu: UnsafeMutablePointer<__CLPK_doublereal>, _ __csv: UnsafeMutablePointer<__CLPK_doublereal>, _ __snv: UnsafeMutablePointer<__CLPK_doublereal>, _ __csq: UnsafeMutablePointer<__CLPK_doublereal>, _ __snq: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlagtf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lambda: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __tol: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __in: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlagtm_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlagts_(__job: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __in: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __tol: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlagv2_(__a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __csl: UnsafeMutablePointer<__CLPK_doublereal>, _ __snl: UnsafeMutablePointer<__CLPK_doublereal>, _ __csr: UnsafeMutablePointer<__CLPK_doublereal>, _ __snr: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlahqr_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlahr2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlahrd_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaic1_(__job: UnsafeMutablePointer<__CLPK_integer>, _ __j: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __sest: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __gamma: UnsafeMutablePointer<__CLPK_doublereal>, _ __sestpr: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlaisnan_(__din1: UnsafeMutablePointer<__CLPK_doublereal>, _ __din2: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_logical
@available(OSX 10.2, *)
func dlaln2_(__ltrans: UnsafeMutablePointer<__CLPK_logical>, _ __na: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __smin: UnsafeMutablePointer<__CLPK_doublereal>, _ __ca: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d1: UnsafeMutablePointer<__CLPK_doublereal>, _ __d2: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __xnorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlals0_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __bx: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldbx: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldgnum: UnsafeMutablePointer<__CLPK_integer>, _ __poles: UnsafeMutablePointer<__CLPK_doublereal>, _ __difl: UnsafeMutablePointer<__CLPK_doublereal>, _ __difr: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlalsa_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __bx: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldbx: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __difl: UnsafeMutablePointer<__CLPK_doublereal>, _ __difr: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __poles: UnsafeMutablePointer<__CLPK_doublereal>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlalsd_(__uplo: UnsafeMutablePointer<Int8>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlamrg_(__n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __dtrd1: UnsafeMutablePointer<__CLPK_integer>, _ __dtrd2: UnsafeMutablePointer<__CLPK_integer>, _ __index: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaneg_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __lld: UnsafeMutablePointer<__CLPK_doublereal>, _ __sigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __r__: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func dlangb_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlange_(__norm: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlangt_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __du: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlanhs_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlansb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlansf_(__norm: UnsafeMutablePointer<Int8>, _ __transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlansp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlanst_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlansy_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlantb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlantp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlantr_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlanv2_(__a: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt1r: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt1i: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt2r: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt2i: UnsafeMutablePointer<__CLPK_doublereal>, _ __cs: UnsafeMutablePointer<__CLPK_doublereal>, _ __sn: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlapll_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __ssmin: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlapmt_(__forwrd: UnsafeMutablePointer<__CLPK_logical>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlapy2_(__x: UnsafeMutablePointer<__CLPK_doublereal>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlapy3_(__x: UnsafeMutablePointer<__CLPK_doublereal>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlaqgb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func dlaqge_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func dlaqp2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __vn1: UnsafeMutablePointer<__CLPK_doublereal>, _ __vn2: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlaqps_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __vn1: UnsafeMutablePointer<__CLPK_doublereal>, _ __vn2: UnsafeMutablePointer<__CLPK_doublereal>, _ __auxv: UnsafeMutablePointer<__CLPK_doublereal>, _ __f: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaqr0_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaqr1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __sr1: UnsafeMutablePointer<__CLPK_doublereal>, _ __si1: UnsafeMutablePointer<__CLPK_doublereal>, _ __sr2: UnsafeMutablePointer<__CLPK_doublereal>, _ __si2: UnsafeMutablePointer<__CLPK_doublereal>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlaqr2_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ns: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __sr: UnsafeMutablePointer<__CLPK_doublereal>, _ __si: UnsafeMutablePointer<__CLPK_doublereal>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaqr3_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ns: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __sr: UnsafeMutablePointer<__CLPK_doublereal>, _ __si: UnsafeMutablePointer<__CLPK_doublereal>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaqr4_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaqr5_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __kacc22: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nshfts: UnsafeMutablePointer<__CLPK_integer>, _ __sr: UnsafeMutablePointer<__CLPK_doublereal>, _ __si: UnsafeMutablePointer<__CLPK_doublereal>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __wh: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldwh: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaqsb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func dlaqsp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func dlaqsy_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func dlaqtr_(__ltran: UnsafeMutablePointer<__CLPK_logical>, _ __l__CLPK_real: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlar1v_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __b1: UnsafeMutablePointer<__CLPK_integer>, _ __bn: UnsafeMutablePointer<__CLPK_integer>, _ __lambda: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __l: UnsafeMutablePointer<__CLPK_doublereal>, _ __ld: UnsafeMutablePointer<__CLPK_doublereal>, _ __lld: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __gaptol: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __wantnc: UnsafeMutablePointer<__CLPK_logical>, _ __negcnt: UnsafeMutablePointer<__CLPK_integer>, _ __ztz: UnsafeMutablePointer<__CLPK_doublereal>, _ __mingma: UnsafeMutablePointer<__CLPK_doublereal>, _ __r__: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __nrminv: UnsafeMutablePointer<__CLPK_doublereal>, _ __resid: UnsafeMutablePointer<__CLPK_doublereal>, _ __rqcorr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlar2v_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarf_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlarfb_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarfg_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlarfp_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlarft_(__direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarfx_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlargv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarnv_(__idist: UnsafeMutablePointer<__CLPK_integer>, _ __iseed: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlarra_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __e2: UnsafeMutablePointer<__CLPK_doublereal>, _ __spltol: UnsafeMutablePointer<__CLPK_doublereal>, _ __tnrm: UnsafeMutablePointer<__CLPK_doublereal>, _ __nsplit: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarrb_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __lld: UnsafeMutablePointer<__CLPK_doublereal>, _ __ifirst: UnsafeMutablePointer<__CLPK_integer>, _ __ilast: UnsafeMutablePointer<__CLPK_integer>, _ __rtol1: UnsafeMutablePointer<__CLPK_doublereal>, _ __rtol2: UnsafeMutablePointer<__CLPK_doublereal>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __wgap: UnsafeMutablePointer<__CLPK_doublereal>, _ __werr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __spdiam: UnsafeMutablePointer<__CLPK_doublereal>, _ __twist: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarrc_(__jobt: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __eigcnt: UnsafeMutablePointer<__CLPK_integer>, _ __lcnt: UnsafeMutablePointer<__CLPK_integer>, _ __rcnt: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarrd_(__range: UnsafeMutablePointer<Int8>, _ __order: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __gers: UnsafeMutablePointer<__CLPK_doublereal>, _ __reltol: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __e2: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __nsplit: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __werr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wl: UnsafeMutablePointer<__CLPK_doublereal>, _ __wu: UnsafeMutablePointer<__CLPK_doublereal>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __indexw: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarre_(__range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __e2: UnsafeMutablePointer<__CLPK_doublereal>, _ __rtol1: UnsafeMutablePointer<__CLPK_doublereal>, _ __rtol2: UnsafeMutablePointer<__CLPK_doublereal>, _ __spltol: UnsafeMutablePointer<__CLPK_doublereal>, _ __nsplit: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __werr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wgap: UnsafeMutablePointer<__CLPK_doublereal>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __indexw: UnsafeMutablePointer<__CLPK_integer>, _ __gers: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __l: UnsafeMutablePointer<__CLPK_doublereal>, _ __ld: UnsafeMutablePointer<__CLPK_doublereal>, _ __clstrt: UnsafeMutablePointer<__CLPK_integer>, _ __clend: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __wgap: UnsafeMutablePointer<__CLPK_doublereal>, _ __werr: UnsafeMutablePointer<__CLPK_doublereal>, _ __spdiam: UnsafeMutablePointer<__CLPK_doublereal>, _ __clgapl: UnsafeMutablePointer<__CLPK_doublereal>, _ __clgapr: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __sigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __dplus: UnsafeMutablePointer<__CLPK_doublereal>, _ __lplus: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarrj_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ifirst: UnsafeMutablePointer<__CLPK_integer>, _ __ilast: UnsafeMutablePointer<__CLPK_integer>, _ __rtol: UnsafeMutablePointer<__CLPK_doublereal>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __werr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __spdiam: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarrk_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __iw: UnsafeMutablePointer<__CLPK_integer>, _ __gl: UnsafeMutablePointer<__CLPK_doublereal>, _ __gu: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e2: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __reltol: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __werr: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarrr_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarrv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __l: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __dol: UnsafeMutablePointer<__CLPK_integer>, _ __dou: UnsafeMutablePointer<__CLPK_integer>, _ __minrgp: UnsafeMutablePointer<__CLPK_doublereal>, _ __rtol1: UnsafeMutablePointer<__CLPK_doublereal>, _ __rtol2: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __werr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wgap: UnsafeMutablePointer<__CLPK_doublereal>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __indexw: UnsafeMutablePointer<__CLPK_integer>, _ __gers: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarscl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlartg_(__f: UnsafeMutablePointer<__CLPK_doublereal>, _ __g: UnsafeMutablePointer<__CLPK_doublereal>, _ __cs: UnsafeMutablePointer<__CLPK_doublereal>, _ __sn: UnsafeMutablePointer<__CLPK_doublereal>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlartv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublereal>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaruv_(__iseed: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlarz_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlarzb_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlarzt_(__direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlas2_(__f: UnsafeMutablePointer<__CLPK_doublereal>, _ __g: UnsafeMutablePointer<__CLPK_doublereal>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ssmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __ssmax: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlascl_(__type__: UnsafeMutablePointer<Int8>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __cfrom: UnsafeMutablePointer<__CLPK_doublereal>, _ __cto: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlascl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasd0_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasd1_(__nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __idxq: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasd2_(__nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __dsigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __u2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu2: UnsafeMutablePointer<__CLPK_integer>, _ __vt2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt2: UnsafeMutablePointer<__CLPK_integer>, _ __idxp: UnsafeMutablePointer<__CLPK_integer>, _ __idx: UnsafeMutablePointer<__CLPK_integer>, _ __idxc: UnsafeMutablePointer<__CLPK_integer>, _ __idxq: UnsafeMutablePointer<__CLPK_integer>, _ __coltyp: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasd3_(__nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __dsigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __u2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu2: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __vt2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt2: UnsafeMutablePointer<__CLPK_integer>, _ __idxc: UnsafeMutablePointer<__CLPK_integer>, _ __ctot: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasd4_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __i__: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __delta: UnsafeMutablePointer<__CLPK_doublereal>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __sigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasd5_(__i__: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __delta: UnsafeMutablePointer<__CLPK_doublereal>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __dsigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlasd6_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __vf: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __idxq: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldgnum: UnsafeMutablePointer<__CLPK_integer>, _ __poles: UnsafeMutablePointer<__CLPK_doublereal>, _ __difl: UnsafeMutablePointer<__CLPK_doublereal>, _ __difr: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasd7_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __zw: UnsafeMutablePointer<__CLPK_doublereal>, _ __vf: UnsafeMutablePointer<__CLPK_doublereal>, _ __vfw: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vlw: UnsafeMutablePointer<__CLPK_doublereal>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __dsigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __idx: UnsafeMutablePointer<__CLPK_integer>, _ __idxp: UnsafeMutablePointer<__CLPK_integer>, _ __idxq: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldgnum: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasd8_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __vf: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __difl: UnsafeMutablePointer<__CLPK_doublereal>, _ __difr: UnsafeMutablePointer<__CLPK_doublereal>, _ __lddifr: UnsafeMutablePointer<__CLPK_integer>, _ __dsigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasda_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __difl: UnsafeMutablePointer<__CLPK_doublereal>, _ __difr: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __poles: UnsafeMutablePointer<__CLPK_doublereal>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasdq_(__uplo: UnsafeMutablePointer<Int8>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncvt: UnsafeMutablePointer<__CLPK_integer>, _ __nru: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasdt_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __lvl: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __inode: UnsafeMutablePointer<__CLPK_integer>, _ __ndiml: UnsafeMutablePointer<__CLPK_integer>, _ __ndimr: UnsafeMutablePointer<__CLPK_integer>, _ __msub: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlaset_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasq1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasq2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasq3_(__i0: UnsafeMutablePointer<__CLPK_integer>, _ __n0: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __pp: UnsafeMutablePointer<__CLPK_integer>, _ __dmin__: UnsafeMutablePointer<__CLPK_doublereal>, _ __sigma: UnsafeMutablePointer<__CLPK_doublereal>, _ __desig: UnsafeMutablePointer<__CLPK_doublereal>, _ __qmax: UnsafeMutablePointer<__CLPK_doublereal>, _ __nfail: UnsafeMutablePointer<__CLPK_integer>, _ __iter: UnsafeMutablePointer<__CLPK_integer>, _ __ndiv: UnsafeMutablePointer<__CLPK_integer>, _ __ieee: UnsafeMutablePointer<__CLPK_logical>, _ __ttype: UnsafeMutablePointer<__CLPK_integer>, _ __dmin1: UnsafeMutablePointer<__CLPK_doublereal>, _ __dmin2: UnsafeMutablePointer<__CLPK_doublereal>, _ __dn: UnsafeMutablePointer<__CLPK_doublereal>, _ __dn1: UnsafeMutablePointer<__CLPK_doublereal>, _ __dn2: UnsafeMutablePointer<__CLPK_doublereal>, _ __g: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlasq4_(__i0: UnsafeMutablePointer<__CLPK_integer>, _ __n0: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __pp: UnsafeMutablePointer<__CLPK_integer>, _ __n0in: UnsafeMutablePointer<__CLPK_integer>, _ __dmin__: UnsafeMutablePointer<__CLPK_doublereal>, _ __dmin1: UnsafeMutablePointer<__CLPK_doublereal>, _ __dmin2: UnsafeMutablePointer<__CLPK_doublereal>, _ __dn: UnsafeMutablePointer<__CLPK_doublereal>, _ __dn1: UnsafeMutablePointer<__CLPK_doublereal>, _ __dn2: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __ttype: UnsafeMutablePointer<__CLPK_integer>, _ __g: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlasq5_(__i0: UnsafeMutablePointer<__CLPK_integer>, _ __n0: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __pp: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __dmin__: UnsafeMutablePointer<__CLPK_doublereal>, _ __dmin1: UnsafeMutablePointer<__CLPK_doublereal>, _ __dmin2: UnsafeMutablePointer<__CLPK_doublereal>, _ __dn: UnsafeMutablePointer<__CLPK_doublereal>, _ __dnm1: UnsafeMutablePointer<__CLPK_doublereal>, _ __dnm2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ieee: UnsafeMutablePointer<__CLPK_logical>) -> Int32
@available(OSX 10.2, *)
func dlasq6_(__i0: UnsafeMutablePointer<__CLPK_integer>, _ __n0: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __pp: UnsafeMutablePointer<__CLPK_integer>, _ __dmin__: UnsafeMutablePointer<__CLPK_doublereal>, _ __dmin1: UnsafeMutablePointer<__CLPK_doublereal>, _ __dmin2: UnsafeMutablePointer<__CLPK_doublereal>, _ __dn: UnsafeMutablePointer<__CLPK_doublereal>, _ __dnm1: UnsafeMutablePointer<__CLPK_doublereal>, _ __dnm2: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlasr_(__side: UnsafeMutablePointer<Int8>, _ __pivot: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasrt_(__id: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlassq_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __sumsq: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlasv2_(__f: UnsafeMutablePointer<__CLPK_doublereal>, _ __g: UnsafeMutablePointer<__CLPK_doublereal>, _ __h__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ssmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __ssmax: UnsafeMutablePointer<__CLPK_doublereal>, _ __snr: UnsafeMutablePointer<__CLPK_doublereal>, _ __csr: UnsafeMutablePointer<__CLPK_doublereal>, _ __snl: UnsafeMutablePointer<__CLPK_doublereal>, _ __csl: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlaswp_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __k1: UnsafeMutablePointer<__CLPK_integer>, _ __k2: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasy2_(__ltranl: UnsafeMutablePointer<__CLPK_logical>, _ __ltranr: UnsafeMutablePointer<__CLPK_logical>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __tl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldtl: UnsafeMutablePointer<__CLPK_integer>, _ __tr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldtr: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __xnorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlasyf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlat2s_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_real>, _ __ldsa: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlatbs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __cnorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlatdf_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __rhs: UnsafeMutablePointer<__CLPK_doublereal>, _ __rdsum: UnsafeMutablePointer<__CLPK_doublereal>, _ __rdscal: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlatps_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __cnorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlatrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlatrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __cnorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlatrz_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlatzm_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c1: UnsafeMutablePointer<__CLPK_doublereal>, _ __c2: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlauu2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlauum_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dopgtr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dopmtr_(__side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorg2l_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorg2r_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorgbr_(__vect: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorghr_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorgl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorglq_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorgql_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorgqr_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorgr2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorgrq_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorgtr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorm2l_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorm2r_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormbr_(__vect: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormhr_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dorml2_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormlq_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormql_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormqr_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormr2_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormr3_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormrq_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormrz_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dormtr_(__side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbequ_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbstf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbtf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbtrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpbtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpftrf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpftri_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpftrs_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpocon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpoequ_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpoequb_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dporfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dposv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dposvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpotf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpotrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpotri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpotrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dppcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dppequ_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __afp: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dppsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dppsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __afp: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpstf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __piv: UnsafeMutablePointer<__CLPK_integer>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __tol: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpstrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __piv: UnsafeMutablePointer<__CLPK_integer>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __tol: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dptcon_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpteqr_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dptrfs_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __df: UnsafeMutablePointer<__CLPK_doublereal>, _ __ef: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dptsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dptsvx_(__fact: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __df: UnsafeMutablePointer<__CLPK_doublereal>, _ __ef: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpttrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dpttrs_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dptts2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func drscl_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_doublereal>, _ __sx: UnsafeMutablePointer<__CLPK_doublereal>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsbev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsbevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsbevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsbgst_(__vect: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsbgv_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsbgvd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsbgvx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsbtrd_(__vect: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsfrk_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dsgesv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __swork: UnsafeMutablePointer<__CLPK_real>, _ __iter: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspgst_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __bp: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspgv_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __bp: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspgvd_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __bp: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspgvx_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __bp: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsposv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __swork: UnsafeMutablePointer<__CLPK_real>, _ __iter: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __afp: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dspsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __afp: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsptrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstebz_(__range: UnsafeMutablePointer<Int8>, _ __order: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __nsplit: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstedc_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstegr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstein_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstemr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __nzc: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __tryrac: UnsafeMutablePointer<__CLPK_logical>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsteqr_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsterf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstev_(__jobz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstevd_(__jobz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstevr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dstevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsycon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsyequb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsyev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsyevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsyevr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsyevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsygs2_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsygst_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsygv_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsygvd_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsygvx_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsyrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsysv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsysvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsytd2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsytf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsytrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsytrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsytri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dsytrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtbcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtbrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtbtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtfsm_(__transr: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtftri_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtfttp_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_doublereal>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtfttr_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtgevc_(__side: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __lds: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldp: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtgex2_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __j1: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtgexc_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ifst: UnsafeMutablePointer<__CLPK_integer>, _ __ilst: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtgsen_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_doublereal>, _ __alphai: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __pl: UnsafeMutablePointer<__CLPK_doublereal>, _ __pr: UnsafeMutablePointer<__CLPK_doublereal>, _ __dif: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtgsja_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __tola: UnsafeMutablePointer<__CLPK_doublereal>, _ __tolb: UnsafeMutablePointer<__CLPK_doublereal>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __ncycle: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtgsna_(__job: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __dif: UnsafeMutablePointer<__CLPK_doublereal>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtgsy2_(__trans: UnsafeMutablePointer<Int8>, _ __ijob: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldd: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __lde: UnsafeMutablePointer<__CLPK_integer>, _ __f: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __rdsum: UnsafeMutablePointer<__CLPK_doublereal>, _ __rdscal: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __pq: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtgsyl_(__trans: UnsafeMutablePointer<Int8>, _ __ijob: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldd: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __lde: UnsafeMutablePointer<__CLPK_integer>, _ __f: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __dif: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtpcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtptri_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtpttf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __arf: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtpttr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrevc_(__side: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrexc_(__compq: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __ifst: UnsafeMutablePointer<__CLPK_integer>, _ __ilst: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrsen_(__job: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wi: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __sep: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrsna_(__job: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __sep: UnsafeMutablePointer<__CLPK_doublereal>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrsyl_(__trana: UnsafeMutablePointer<Int8>, _ __tranb: UnsafeMutablePointer<Int8>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrti2_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrtri_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrttf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtrttp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtzrqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dtzrzf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dzsum1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cx: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func icmax1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cx: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func ieeeck_(__ispec: UnsafeMutablePointer<__CLPK_integer>, _ __zero: UnsafeMutablePointer<__CLPK_real>, _ __one: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilaclc_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilaclr_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_complex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func iladiag_(__diag: UnsafeMutablePointer<Int8>) -> __CLPK_integer
@available(OSX 10.2, *)
func iladlc_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func iladlr_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilaprec_(__prec: UnsafeMutablePointer<Int8>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilaslc_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilaslr_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilatrans_(__trans: UnsafeMutablePointer<Int8>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilauplo_(__uplo: UnsafeMutablePointer<Int8>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilazlc_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func ilazlr_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func iparmq_(__ispec: UnsafeMutablePointer<__CLPK_integer>, _ __name__: UnsafeMutablePointer<Int8>, _ __opts: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func izmax1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cx: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func lsamen_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ca: UnsafeMutablePointer<Int8>, _ __cb: UnsafeMutablePointer<Int8>) -> __CLPK_logical
@available(OSX 10.2, *)
func smaxloc_(__a: UnsafeMutablePointer<__CLPK_real>, _ __dimm: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func sbdsdc_(__uplo: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __iq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sbdsqr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncvt: UnsafeMutablePointer<__CLPK_integer>, _ __nru: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func scsum1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cx: UnsafeMutablePointer<__CLPK_complex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func sdisna_(__job: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __sep: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbbrd_(__vect: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __pt: UnsafeMutablePointer<__CLPK_real>, _ __ldpt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbcon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbequ_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbequb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbrfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_real>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbsvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_real>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbtf2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbtrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgbtrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgebak_(__job: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgebal_(__job: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgebd2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tauq: UnsafeMutablePointer<__CLPK_real>, _ __taup: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgebrd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tauq: UnsafeMutablePointer<__CLPK_real>, _ __taup: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgecon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeequ_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeequb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgees_(__jobvs: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __select: __CLPK_L_fp!, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __vs: UnsafeMutablePointer<__CLPK_real>, _ __ldvs: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeesx_(__jobvs: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __select: __CLPK_L_fp!, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __vs: UnsafeMutablePointer<__CLPK_real>, _ __ldvs: UnsafeMutablePointer<__CLPK_integer>, _ __rconde: UnsafeMutablePointer<__CLPK_real>, _ __rcondv: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeev_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeevx_(__balanc: UnsafeMutablePointer<Int8>, _ __jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __abnrm: UnsafeMutablePointer<__CLPK_real>, _ __rconde: UnsafeMutablePointer<__CLPK_real>, _ __rcondv: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgegs_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __vsl: UnsafeMutablePointer<__CLPK_real>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_real>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgegv_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgehd2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgehrd_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgejsv_(__joba: UnsafeMutablePointer<Int8>, _ __jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobr: UnsafeMutablePointer<Int8>, _ __jobt: UnsafeMutablePointer<Int8>, _ __jobp: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sva: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgelq2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgelqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgels_(__trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgelsd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgelss_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgelsx_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgelsy_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeql2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeqlf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeqp3_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeqpf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeqr2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgeqrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgerfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_real>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgerq2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgerqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgesc2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __rhs: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func sgesdd_(__jobz: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgesv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgesvd_(__jobu: UnsafeMutablePointer<Int8>, _ __jobvt: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgesvj_(__joba: UnsafeMutablePointer<Int8>, _ __jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sva: UnsafeMutablePointer<__CLPK_real>, _ __mv: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgesvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_real>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgetc2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgetf2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgetrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgetri_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgetrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggbak_(__job: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_real>, _ __rscale: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggbal_(__job: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_real>, _ __rscale: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgges_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __selctg: __CLPK_L_fp!, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __vsl: UnsafeMutablePointer<__CLPK_real>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_real>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggesx_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __selctg: __CLPK_L_fp!, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __vsl: UnsafeMutablePointer<__CLPK_real>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_real>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __rconde: UnsafeMutablePointer<__CLPK_real>, _ __rcondv: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggev_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggevx_(__balanc: UnsafeMutablePointer<Int8>, _ __jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_real>, _ __rscale: UnsafeMutablePointer<__CLPK_real>, _ __abnrm: UnsafeMutablePointer<__CLPK_real>, _ __bbnrm: UnsafeMutablePointer<__CLPK_real>, _ __rconde: UnsafeMutablePointer<__CLPK_real>, _ __rcondv: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggglm_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgghrd_(__compq: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgglse_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggqrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __taua: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __taub: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggrqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __taua: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __taub: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggsvd_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sggsvp_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __tola: UnsafeMutablePointer<__CLPK_real>, _ __tolb: UnsafeMutablePointer<__CLPK_real>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgsvj0_(__jobv: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __sva: UnsafeMutablePointer<__CLPK_real>, _ __mv: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __eps: UnsafeMutablePointer<__CLPK_real>, _ __sfmin: UnsafeMutablePointer<__CLPK_real>, _ __tol: UnsafeMutablePointer<__CLPK_real>, _ __nsweep: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgsvj1_(__jobv: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __sva: UnsafeMutablePointer<__CLPK_real>, _ __mv: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __eps: UnsafeMutablePointer<__CLPK_real>, _ __sfmin: UnsafeMutablePointer<__CLPK_real>, _ __tol: UnsafeMutablePointer<__CLPK_real>, _ __nsweep: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgtcon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>, _ __du2: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgtrfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>, _ __dlf: UnsafeMutablePointer<__CLPK_real>, _ __df: UnsafeMutablePointer<__CLPK_real>, _ __duf: UnsafeMutablePointer<__CLPK_real>, _ __du2: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgtsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgtsvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>, _ __dlf: UnsafeMutablePointer<__CLPK_real>, _ __df: UnsafeMutablePointer<__CLPK_real>, _ __duf: UnsafeMutablePointer<__CLPK_real>, _ __du2: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgttrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>, _ __du2: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgttrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>, _ __du2: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sgtts2_(__itrans: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>, _ __du2: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func shgeqz_(__job: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func shsein_(__side: UnsafeMutablePointer<Int8>, _ __eigsrc: UnsafeMutablePointer<Int8>, _ __initv: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __ifaill: UnsafeMutablePointer<__CLPK_integer>, _ __ifailr: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func shseqr_(__job: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sisnan_(__sin__: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_logical
@available(OSX 10.2, *)
func slabad_(__small: UnsafeMutablePointer<__CLPK_real>, _ __large: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slabrd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tauq: UnsafeMutablePointer<__CLPK_real>, _ __taup: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slacn2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __est: UnsafeMutablePointer<__CLPK_real>, _ __kase: UnsafeMutablePointer<__CLPK_integer>, _ __isave: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slacon_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __est: UnsafeMutablePointer<__CLPK_real>, _ __kase: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slacpy_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sladiv_(__a: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __p: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slae2_(__a: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rt1: UnsafeMutablePointer<__CLPK_real>, _ __rt2: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slaebz_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __nitmax: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __mmax: UnsafeMutablePointer<__CLPK_integer>, _ __minp: UnsafeMutablePointer<__CLPK_integer>, _ __nbmin: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __reltol: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __e2: UnsafeMutablePointer<__CLPK_real>, _ __nval: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __mout: UnsafeMutablePointer<__CLPK_integer>, _ __nab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed0_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __qstore: UnsafeMutablePointer<__CLPK_real>, _ __ldqs: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed2_(__k: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __dlamda: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __q2: UnsafeMutablePointer<__CLPK_real>, _ __indx: UnsafeMutablePointer<__CLPK_integer>, _ __indxc: UnsafeMutablePointer<__CLPK_integer>, _ __indxp: UnsafeMutablePointer<__CLPK_integer>, _ __coltyp: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed3_(__k: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __dlamda: UnsafeMutablePointer<__CLPK_real>, _ __q2: UnsafeMutablePointer<__CLPK_real>, _ __indx: UnsafeMutablePointer<__CLPK_integer>, _ __ctot: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed4_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __i__: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __delta: UnsafeMutablePointer<__CLPK_real>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __dlam: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed5_(__i__: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __delta: UnsafeMutablePointer<__CLPK_real>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __dlam: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slaed6_(__kniter: UnsafeMutablePointer<__CLPK_integer>, _ __orgati: UnsafeMutablePointer<__CLPK_logical>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __finit: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed7_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __tlvls: UnsafeMutablePointer<__CLPK_integer>, _ __curlvl: UnsafeMutablePointer<__CLPK_integer>, _ __curpbm: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __qstore: UnsafeMutablePointer<__CLPK_real>, _ __qptr: UnsafeMutablePointer<__CLPK_integer>, _ __prmptr: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed8_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __dlamda: UnsafeMutablePointer<__CLPK_real>, _ __q2: UnsafeMutablePointer<__CLPK_real>, _ __ldq2: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __indxp: UnsafeMutablePointer<__CLPK_integer>, _ __indx: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaed9_(__k: UnsafeMutablePointer<__CLPK_integer>, _ __kstart: UnsafeMutablePointer<__CLPK_integer>, _ __kstop: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __dlamda: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __lds: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaeda_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __tlvls: UnsafeMutablePointer<__CLPK_integer>, _ __curlvl: UnsafeMutablePointer<__CLPK_integer>, _ __curpbm: UnsafeMutablePointer<__CLPK_integer>, _ __prmptr: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __qptr: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ztemp: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaein_(__rightv: UnsafeMutablePointer<__CLPK_logical>, _ __noinit: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __vi: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __eps3: UnsafeMutablePointer<__CLPK_real>, _ __smlnum: UnsafeMutablePointer<__CLPK_real>, _ __bignum: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaev2_(__a: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rt1: UnsafeMutablePointer<__CLPK_real>, _ __rt2: UnsafeMutablePointer<__CLPK_real>, _ __cs1: UnsafeMutablePointer<__CLPK_real>, _ __sn1: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slaexc_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __j1: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slag2_(__a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __safmin: UnsafeMutablePointer<__CLPK_real>, _ __scale1: UnsafeMutablePointer<__CLPK_real>, _ __scale2: UnsafeMutablePointer<__CLPK_real>, _ __wr1: UnsafeMutablePointer<__CLPK_real>, _ __wr2: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slag2d_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_real>, _ __ldsa: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slags2_(__upper: UnsafeMutablePointer<__CLPK_logical>, _ __a1: UnsafeMutablePointer<__CLPK_real>, _ __a2: UnsafeMutablePointer<__CLPK_real>, _ __a3: UnsafeMutablePointer<__CLPK_real>, _ __b1: UnsafeMutablePointer<__CLPK_real>, _ __b2: UnsafeMutablePointer<__CLPK_real>, _ __b3: UnsafeMutablePointer<__CLPK_real>, _ __csu: UnsafeMutablePointer<__CLPK_real>, _ __snu: UnsafeMutablePointer<__CLPK_real>, _ __csv: UnsafeMutablePointer<__CLPK_real>, _ __snv: UnsafeMutablePointer<__CLPK_real>, _ __csq: UnsafeMutablePointer<__CLPK_real>, _ __snq: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slagtf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lambda: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __tol: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __in: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slagtm_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slagts_(__job: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __in: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __tol: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slagv2_(__a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __csl: UnsafeMutablePointer<__CLPK_real>, _ __snl: UnsafeMutablePointer<__CLPK_real>, _ __csr: UnsafeMutablePointer<__CLPK_real>, _ __snr: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slahqr_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slahr2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slahrd_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaic1_(__job: UnsafeMutablePointer<__CLPK_integer>, _ __j: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __sest: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __gamma: UnsafeMutablePointer<__CLPK_real>, _ __sestpr: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slaisnan_(__sin1: UnsafeMutablePointer<__CLPK_real>, _ __sin2: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_logical
@available(OSX 10.2, *)
func slaln2_(__ltrans: UnsafeMutablePointer<__CLPK_logical>, _ __na: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __smin: UnsafeMutablePointer<__CLPK_real>, _ __ca: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d1: UnsafeMutablePointer<__CLPK_real>, _ __d2: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __xnorm: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slals0_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __bx: UnsafeMutablePointer<__CLPK_real>, _ __ldbx: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __ldgnum: UnsafeMutablePointer<__CLPK_integer>, _ __poles: UnsafeMutablePointer<__CLPK_real>, _ __difl: UnsafeMutablePointer<__CLPK_real>, _ __difr: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slalsa_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __bx: UnsafeMutablePointer<__CLPK_real>, _ __ldbx: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __difl: UnsafeMutablePointer<__CLPK_real>, _ __difr: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __poles: UnsafeMutablePointer<__CLPK_real>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slalsd_(__uplo: UnsafeMutablePointer<Int8>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slamrg_(__n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __strd1: UnsafeMutablePointer<__CLPK_integer>, _ __strd2: UnsafeMutablePointer<__CLPK_integer>, _ __index: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaneg_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __lld: UnsafeMutablePointer<__CLPK_real>, _ __sigma: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __r__: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.2, *)
func slangb_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slange_(__norm: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slangt_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __du: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slanhs_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slansb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slansf_(__norm: UnsafeMutablePointer<Int8>, _ __transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slansp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slanst_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slansy_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slantb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slantp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slantr_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slanv2_(__a: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __rt1r: UnsafeMutablePointer<__CLPK_real>, _ __rt1i: UnsafeMutablePointer<__CLPK_real>, _ __rt2r: UnsafeMutablePointer<__CLPK_real>, _ __rt2i: UnsafeMutablePointer<__CLPK_real>, _ __cs: UnsafeMutablePointer<__CLPK_real>, _ __sn: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slapll_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __ssmin: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slapmt_(__forwrd: UnsafeMutablePointer<__CLPK_logical>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slapy2_(__x: UnsafeMutablePointer<__CLPK_real>, _ __y: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slapy3_(__x: UnsafeMutablePointer<__CLPK_real>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slaqgb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func slaqge_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __rowcnd: UnsafeMutablePointer<__CLPK_real>, _ __colcnd: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func slaqp2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __vn1: UnsafeMutablePointer<__CLPK_real>, _ __vn2: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slaqps_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __vn1: UnsafeMutablePointer<__CLPK_real>, _ __vn2: UnsafeMutablePointer<__CLPK_real>, _ __auxv: UnsafeMutablePointer<__CLPK_real>, _ __f: UnsafeMutablePointer<__CLPK_real>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaqr0_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaqr1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __sr1: UnsafeMutablePointer<__CLPK_real>, _ __si1: UnsafeMutablePointer<__CLPK_real>, _ __sr2: UnsafeMutablePointer<__CLPK_real>, _ __si2: UnsafeMutablePointer<__CLPK_real>, _ __v: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slaqr2_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ns: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __sr: UnsafeMutablePointer<__CLPK_real>, _ __si: UnsafeMutablePointer<__CLPK_real>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_real>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaqr3_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ns: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __sr: UnsafeMutablePointer<__CLPK_real>, _ __si: UnsafeMutablePointer<__CLPK_real>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_real>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaqr4_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaqr5_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __kacc22: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nshfts: UnsafeMutablePointer<__CLPK_integer>, _ __sr: UnsafeMutablePointer<__CLPK_real>, _ __si: UnsafeMutablePointer<__CLPK_real>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_real>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __wh: UnsafeMutablePointer<__CLPK_real>, _ __ldwh: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaqsb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func slaqsp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func slaqsy_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func slaqtr_(__ltran: UnsafeMutablePointer<__CLPK_logical>, _ __l__CLPK_real: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slar1v_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __b1: UnsafeMutablePointer<__CLPK_integer>, _ __bn: UnsafeMutablePointer<__CLPK_integer>, _ __lambda: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __l: UnsafeMutablePointer<__CLPK_real>, _ __ld: UnsafeMutablePointer<__CLPK_real>, _ __lld: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __gaptol: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __wantnc: UnsafeMutablePointer<__CLPK_logical>, _ __negcnt: UnsafeMutablePointer<__CLPK_integer>, _ __ztz: UnsafeMutablePointer<__CLPK_real>, _ __mingma: UnsafeMutablePointer<__CLPK_real>, _ __r__: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __nrminv: UnsafeMutablePointer<__CLPK_real>, _ __resid: UnsafeMutablePointer<__CLPK_real>, _ __rqcorr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slar2v_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarf_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slarfb_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarfg_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slarfp_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slarft_(__direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarfx_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slargv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarnv_(__idist: UnsafeMutablePointer<__CLPK_integer>, _ __iseed: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slarra_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __e2: UnsafeMutablePointer<__CLPK_real>, _ __spltol: UnsafeMutablePointer<__CLPK_real>, _ __tnrm: UnsafeMutablePointer<__CLPK_real>, _ __nsplit: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarrb_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __lld: UnsafeMutablePointer<__CLPK_real>, _ __ifirst: UnsafeMutablePointer<__CLPK_integer>, _ __ilast: UnsafeMutablePointer<__CLPK_integer>, _ __rtol1: UnsafeMutablePointer<__CLPK_real>, _ __rtol2: UnsafeMutablePointer<__CLPK_real>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __wgap: UnsafeMutablePointer<__CLPK_real>, _ __werr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __spdiam: UnsafeMutablePointer<__CLPK_real>, _ __twist: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarrc_(__jobt: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __eigcnt: UnsafeMutablePointer<__CLPK_integer>, _ __lcnt: UnsafeMutablePointer<__CLPK_integer>, _ __rcnt: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarrd_(__range: UnsafeMutablePointer<Int8>, _ __order: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __gers: UnsafeMutablePointer<__CLPK_real>, _ __reltol: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __e2: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __nsplit: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __werr: UnsafeMutablePointer<__CLPK_real>, _ __wl: UnsafeMutablePointer<__CLPK_real>, _ __wu: UnsafeMutablePointer<__CLPK_real>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __indexw: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarre_(__range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __e2: UnsafeMutablePointer<__CLPK_real>, _ __rtol1: UnsafeMutablePointer<__CLPK_real>, _ __rtol2: UnsafeMutablePointer<__CLPK_real>, _ __spltol: UnsafeMutablePointer<__CLPK_real>, _ __nsplit: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __werr: UnsafeMutablePointer<__CLPK_real>, _ __wgap: UnsafeMutablePointer<__CLPK_real>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __indexw: UnsafeMutablePointer<__CLPK_integer>, _ __gers: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __l: UnsafeMutablePointer<__CLPK_real>, _ __ld: UnsafeMutablePointer<__CLPK_real>, _ __clstrt: UnsafeMutablePointer<__CLPK_integer>, _ __clend: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __wgap: UnsafeMutablePointer<__CLPK_real>, _ __werr: UnsafeMutablePointer<__CLPK_real>, _ __spdiam: UnsafeMutablePointer<__CLPK_real>, _ __clgapl: UnsafeMutablePointer<__CLPK_real>, _ __clgapr: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __sigma: UnsafeMutablePointer<__CLPK_real>, _ __dplus: UnsafeMutablePointer<__CLPK_real>, _ __lplus: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarrj_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e2: UnsafeMutablePointer<__CLPK_real>, _ __ifirst: UnsafeMutablePointer<__CLPK_integer>, _ __ilast: UnsafeMutablePointer<__CLPK_integer>, _ __rtol: UnsafeMutablePointer<__CLPK_real>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __werr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __spdiam: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarrk_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __iw: UnsafeMutablePointer<__CLPK_integer>, _ __gl: UnsafeMutablePointer<__CLPK_real>, _ __gu: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e2: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __reltol: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __werr: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarrr_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarrv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __l: UnsafeMutablePointer<__CLPK_real>, _ __pivmin: UnsafeMutablePointer<__CLPK_real>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __dol: UnsafeMutablePointer<__CLPK_integer>, _ __dou: UnsafeMutablePointer<__CLPK_integer>, _ __minrgp: UnsafeMutablePointer<__CLPK_real>, _ __rtol1: UnsafeMutablePointer<__CLPK_real>, _ __rtol2: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __werr: UnsafeMutablePointer<__CLPK_real>, _ __wgap: UnsafeMutablePointer<__CLPK_real>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __indexw: UnsafeMutablePointer<__CLPK_integer>, _ __gers: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarscl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slartg_(__f: UnsafeMutablePointer<__CLPK_real>, _ __g: UnsafeMutablePointer<__CLPK_real>, _ __cs: UnsafeMutablePointer<__CLPK_real>, _ __sn: UnsafeMutablePointer<__CLPK_real>, _ __r__: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slartv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_real>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaruv_(__iseed: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slarz_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slarzb_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slarzt_(__direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slas2_(__f: UnsafeMutablePointer<__CLPK_real>, _ __g: UnsafeMutablePointer<__CLPK_real>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ssmin: UnsafeMutablePointer<__CLPK_real>, _ __ssmax: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slascl_(__type__: UnsafeMutablePointer<Int8>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __cfrom: UnsafeMutablePointer<__CLPK_real>, _ __cto: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slascl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasd0_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasd1_(__nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __idxq: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasd2_(__nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __dsigma: UnsafeMutablePointer<__CLPK_real>, _ __u2: UnsafeMutablePointer<__CLPK_real>, _ __ldu2: UnsafeMutablePointer<__CLPK_integer>, _ __vt2: UnsafeMutablePointer<__CLPK_real>, _ __ldvt2: UnsafeMutablePointer<__CLPK_integer>, _ __idxp: UnsafeMutablePointer<__CLPK_integer>, _ __idx: UnsafeMutablePointer<__CLPK_integer>, _ __idxc: UnsafeMutablePointer<__CLPK_integer>, _ __idxq: UnsafeMutablePointer<__CLPK_integer>, _ __coltyp: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasd3_(__nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __dsigma: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __u2: UnsafeMutablePointer<__CLPK_real>, _ __ldu2: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __vt2: UnsafeMutablePointer<__CLPK_real>, _ __ldvt2: UnsafeMutablePointer<__CLPK_integer>, _ __idxc: UnsafeMutablePointer<__CLPK_integer>, _ __ctot: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasd4_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __i__: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __delta: UnsafeMutablePointer<__CLPK_real>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __sigma: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasd5_(__i__: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __delta: UnsafeMutablePointer<__CLPK_real>, _ __rho: UnsafeMutablePointer<__CLPK_real>, _ __dsigma: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slasd6_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __vf: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __idxq: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __ldgnum: UnsafeMutablePointer<__CLPK_integer>, _ __poles: UnsafeMutablePointer<__CLPK_real>, _ __difl: UnsafeMutablePointer<__CLPK_real>, _ __difr: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasd7_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __zw: UnsafeMutablePointer<__CLPK_real>, _ __vf: UnsafeMutablePointer<__CLPK_real>, _ __vfw: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vlw: UnsafeMutablePointer<__CLPK_real>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __dsigma: UnsafeMutablePointer<__CLPK_real>, _ __idx: UnsafeMutablePointer<__CLPK_integer>, _ __idxp: UnsafeMutablePointer<__CLPK_integer>, _ __idxq: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __ldgnum: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasd8_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __vf: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __difl: UnsafeMutablePointer<__CLPK_real>, _ __difr: UnsafeMutablePointer<__CLPK_real>, _ __lddifr: UnsafeMutablePointer<__CLPK_integer>, _ __dsigma: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasda_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __difl: UnsafeMutablePointer<__CLPK_real>, _ __difr: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __poles: UnsafeMutablePointer<__CLPK_real>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasdq_(__uplo: UnsafeMutablePointer<Int8>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncvt: UnsafeMutablePointer<__CLPK_integer>, _ __nru: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vt: UnsafeMutablePointer<__CLPK_real>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasdt_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __lvl: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __inode: UnsafeMutablePointer<__CLPK_integer>, _ __ndiml: UnsafeMutablePointer<__CLPK_integer>, _ __ndimr: UnsafeMutablePointer<__CLPK_integer>, _ __msub: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slaset_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasq1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasq2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasq3_(__i0: UnsafeMutablePointer<__CLPK_integer>, _ __n0: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __pp: UnsafeMutablePointer<__CLPK_integer>, _ __dmin__: UnsafeMutablePointer<__CLPK_real>, _ __sigma: UnsafeMutablePointer<__CLPK_real>, _ __desig: UnsafeMutablePointer<__CLPK_real>, _ __qmax: UnsafeMutablePointer<__CLPK_real>, _ __nfail: UnsafeMutablePointer<__CLPK_integer>, _ __iter: UnsafeMutablePointer<__CLPK_integer>, _ __ndiv: UnsafeMutablePointer<__CLPK_integer>, _ __ieee: UnsafeMutablePointer<__CLPK_logical>, _ __ttype: UnsafeMutablePointer<__CLPK_integer>, _ __dmin1: UnsafeMutablePointer<__CLPK_real>, _ __dmin2: UnsafeMutablePointer<__CLPK_real>, _ __dn: UnsafeMutablePointer<__CLPK_real>, _ __dn1: UnsafeMutablePointer<__CLPK_real>, _ __dn2: UnsafeMutablePointer<__CLPK_real>, _ __g: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slasq4_(__i0: UnsafeMutablePointer<__CLPK_integer>, _ __n0: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __pp: UnsafeMutablePointer<__CLPK_integer>, _ __n0in: UnsafeMutablePointer<__CLPK_integer>, _ __dmin__: UnsafeMutablePointer<__CLPK_real>, _ __dmin1: UnsafeMutablePointer<__CLPK_real>, _ __dmin2: UnsafeMutablePointer<__CLPK_real>, _ __dn: UnsafeMutablePointer<__CLPK_real>, _ __dn1: UnsafeMutablePointer<__CLPK_real>, _ __dn2: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __ttype: UnsafeMutablePointer<__CLPK_integer>, _ __g: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slasq5_(__i0: UnsafeMutablePointer<__CLPK_integer>, _ __n0: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __pp: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __dmin__: UnsafeMutablePointer<__CLPK_real>, _ __dmin1: UnsafeMutablePointer<__CLPK_real>, _ __dmin2: UnsafeMutablePointer<__CLPK_real>, _ __dn: UnsafeMutablePointer<__CLPK_real>, _ __dnm1: UnsafeMutablePointer<__CLPK_real>, _ __dnm2: UnsafeMutablePointer<__CLPK_real>, _ __ieee: UnsafeMutablePointer<__CLPK_logical>) -> Int32
@available(OSX 10.2, *)
func slasq6_(__i0: UnsafeMutablePointer<__CLPK_integer>, _ __n0: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __pp: UnsafeMutablePointer<__CLPK_integer>, _ __dmin__: UnsafeMutablePointer<__CLPK_real>, _ __dmin1: UnsafeMutablePointer<__CLPK_real>, _ __dmin2: UnsafeMutablePointer<__CLPK_real>, _ __dn: UnsafeMutablePointer<__CLPK_real>, _ __dnm1: UnsafeMutablePointer<__CLPK_real>, _ __dnm2: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slasr_(__side: UnsafeMutablePointer<Int8>, _ __pivot: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasrt_(__id: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slassq_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __sumsq: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slasv2_(__f: UnsafeMutablePointer<__CLPK_real>, _ __g: UnsafeMutablePointer<__CLPK_real>, _ __h__: UnsafeMutablePointer<__CLPK_real>, _ __ssmin: UnsafeMutablePointer<__CLPK_real>, _ __ssmax: UnsafeMutablePointer<__CLPK_real>, _ __snr: UnsafeMutablePointer<__CLPK_real>, _ __csr: UnsafeMutablePointer<__CLPK_real>, _ __snl: UnsafeMutablePointer<__CLPK_real>, _ __csl: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slaswp_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __k1: UnsafeMutablePointer<__CLPK_integer>, _ __k2: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasy2_(__ltranl: UnsafeMutablePointer<__CLPK_logical>, _ __ltranr: UnsafeMutablePointer<__CLPK_logical>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __tl: UnsafeMutablePointer<__CLPK_real>, _ __ldtl: UnsafeMutablePointer<__CLPK_integer>, _ __tr: UnsafeMutablePointer<__CLPK_real>, _ __ldtr: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __xnorm: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slasyf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slatbs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __cnorm: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slatdf_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __rhs: UnsafeMutablePointer<__CLPK_real>, _ __rdsum: UnsafeMutablePointer<__CLPK_real>, _ __rdscal: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slatps_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __cnorm: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slatrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slatrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __cnorm: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slatrz_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slatzm_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c1: UnsafeMutablePointer<__CLPK_real>, _ __c2: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slauu2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slauum_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sopgtr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sopmtr_(__side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorg2l_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorg2r_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorgbr_(__vect: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorghr_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorgl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorglq_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorgql_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorgqr_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorgr2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorgrq_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorgtr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorm2l_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorm2r_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormbr_(__vect: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormhr_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sorml2_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormlq_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormql_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormqr_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormr2_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormr3_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormrq_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormrz_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sormtr_(__side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbequ_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_real>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbstf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_real>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbtf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbtrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spbtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spftrf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spftri_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spftrs_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spocon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spoequ_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spoequb_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sporfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_real>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sposv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sposvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_real>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spotf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spotrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spotri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spotrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sppcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sppequ_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __afp: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sppsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sppsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __afp: UnsafeMutablePointer<__CLPK_real>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spstf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __piv: UnsafeMutablePointer<__CLPK_integer>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __tol: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spstrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __piv: UnsafeMutablePointer<__CLPK_integer>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __tol: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sptcon_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spteqr_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sptrfs_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __df: UnsafeMutablePointer<__CLPK_real>, _ __ef: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sptsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sptsvx_(__fact: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __df: UnsafeMutablePointer<__CLPK_real>, _ __ef: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spttrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func spttrs_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sptts2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func srscl_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_real>, _ __sx: UnsafeMutablePointer<__CLPK_real>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssbev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssbevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssbevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssbgst_(__vect: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_real>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssbgv_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_real>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssbgvd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_real>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssbgvx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_real>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssbtrd_(__vect: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssfrk_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __c__: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func sspcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspgst_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __bp: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspgv_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __bp: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspgvd_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __bp: UnsafeMutablePointer<__CLPK_real>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspgvx_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __bp: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __afp: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sspsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __afp: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssptrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstebz_(__range: UnsafeMutablePointer<Int8>, _ __order: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __nsplit: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstedc_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstegr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstein_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstemr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __nzc: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __tryrac: UnsafeMutablePointer<__CLPK_logical>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssteqr_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssterf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstev_(__jobz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstevd_(__jobz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstevr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func sstevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssycon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssyequb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __scond: UnsafeMutablePointer<__CLPK_real>, _ __amax: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssyev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssyevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssyevr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssyevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssygs2_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssygst_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssygv_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssygvd_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssygvx_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __vu: UnsafeMutablePointer<__CLPK_real>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_real>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssyrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_real>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssysv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssysvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_real>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssytd2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssytf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssytrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssytrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssytri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ssytrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stbcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stbrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stbtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_real>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stfsm_(__transr: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stftri_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stfttp_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_real>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stfttr_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stgevc_(__side: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __lds: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_real>, _ __ldp: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stgex2_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __j1: UnsafeMutablePointer<__CLPK_integer>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stgexc_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ifst: UnsafeMutablePointer<__CLPK_integer>, _ __ilst: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stgsen_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alphar: UnsafeMutablePointer<__CLPK_real>, _ __alphai: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_real>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __pl: UnsafeMutablePointer<__CLPK_real>, _ __pr: UnsafeMutablePointer<__CLPK_real>, _ __dif: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stgsja_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __tola: UnsafeMutablePointer<__CLPK_real>, _ __tolb: UnsafeMutablePointer<__CLPK_real>, _ __alpha: UnsafeMutablePointer<__CLPK_real>, _ __beta: UnsafeMutablePointer<__CLPK_real>, _ __u: UnsafeMutablePointer<__CLPK_real>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_real>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __ncycle: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stgsna_(__job: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __dif: UnsafeMutablePointer<__CLPK_real>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stgsy2_(__trans: UnsafeMutablePointer<Int8>, _ __ijob: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __ldd: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __lde: UnsafeMutablePointer<__CLPK_integer>, _ __f: UnsafeMutablePointer<__CLPK_real>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __rdsum: UnsafeMutablePointer<__CLPK_real>, _ __rdscal: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __pq: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stgsyl_(__trans: UnsafeMutablePointer<Int8>, _ __ijob: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_real>, _ __ldd: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_real>, _ __lde: UnsafeMutablePointer<__CLPK_integer>, _ __f: UnsafeMutablePointer<__CLPK_real>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __dif: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stpcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stptri_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stpttf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __arf: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stpttr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strevc_(__side: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strexc_(__compq: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __ifst: UnsafeMutablePointer<__CLPK_integer>, _ __ilst: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_real>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_real>, _ __berr: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strsen_(__job: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_real>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __wr: UnsafeMutablePointer<__CLPK_real>, _ __wi: UnsafeMutablePointer<__CLPK_real>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __sep: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strsna_(__job: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_real>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_real>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_real>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_real>, _ __sep: UnsafeMutablePointer<__CLPK_real>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strsyl_(__trana: UnsafeMutablePointer<Int8>, _ __tranb: UnsafeMutablePointer<Int8>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_real>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strti2_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strtri_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_real>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strttf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func strttp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stzrqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func stzrzf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_real>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_real>, _ __work: UnsafeMutablePointer<__CLPK_real>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zbdsqr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncvt: UnsafeMutablePointer<__CLPK_integer>, _ __nru: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vt: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zcgesv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __swork: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iter: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zcposv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __swork: UnsafeMutablePointer<__CLPK_complex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iter: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zdrscl_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_doublereal>, _ __sx: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbbrd_(__vect: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ncc: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __pt: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldpt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbcon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbequ_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbequb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbrfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbsvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbtf2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbtrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgbtrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgebak_(__job: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgebal_(__job: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgebd2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tauq: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __taup: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgebrd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tauq: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __taup: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgecon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeequ_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeequb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgees_(__jobvs: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __select: __CLPK_L_fp!, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vs: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvs: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeesx_(__jobvs: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __select: __CLPK_L_fp!, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vs: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvs: UnsafeMutablePointer<__CLPK_integer>, _ __rconde: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcondv: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeev_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeevx_(__balanc: UnsafeMutablePointer<Int8>, _ __jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __abnrm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rconde: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcondv: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgegs_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vsl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgegv_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgehd2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgehrd_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgelq2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgelqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgels_(__trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgelsd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgelss_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgelsx_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgelsy_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeql2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeqlf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeqp3_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeqpf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeqr2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgeqrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgerfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgerq2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgerqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgesc2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __rhs: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func zgesdd_(__jobz: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgesv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgesvd_(__jobu: UnsafeMutablePointer<Int8>, _ __jobvt: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvt: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgesvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgetc2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgetf2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgetrf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgetri_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgetrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggbak_(__job: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __rscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggbal_(__job: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __rscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgges_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __selctg: __CLPK_L_fp!, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vsl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggesx_(__jobvsl: UnsafeMutablePointer<Int8>, _ __jobvsr: UnsafeMutablePointer<Int8>, _ __sort: UnsafeMutablePointer<Int8>, _ __selctg: __CLPK_L_fp!, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __sdim: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vsl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvsl: UnsafeMutablePointer<__CLPK_integer>, _ __vsr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvsr: UnsafeMutablePointer<__CLPK_integer>, _ __rconde: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcondv: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggev_(__jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggevx_(__balanc: UnsafeMutablePointer<Int8>, _ __jobvl: UnsafeMutablePointer<Int8>, _ __jobvr: UnsafeMutablePointer<Int8>, _ __sense: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __lscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __rscale: UnsafeMutablePointer<__CLPK_doublereal>, _ __abnrm: UnsafeMutablePointer<__CLPK_doublereal>, _ __bbnrm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rconde: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcondv: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __bwork: UnsafeMutablePointer<__CLPK_logical>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggglm_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgghrd_(__compq: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgglse_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggqrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __taua: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __taub: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggrqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __taua: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __taub: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggsvd_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zggsvp_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __tola: UnsafeMutablePointer<__CLPK_doublereal>, _ __tolb: UnsafeMutablePointer<__CLPK_doublereal>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgtcon_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgtrfs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __dlf: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __df: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __duf: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgtsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgtsvx_(__fact: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __dlf: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __df: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __duf: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgttrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgttrs_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zgtts2_(__itrans: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhbev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhbevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhbevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhbgst_(__vect: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhbgv_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhbgvd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhbgvx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ka: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __bb: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldbb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhbtrd_(__vect: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhecon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zheequb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zheev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zheevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zheevr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zheevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhegs2_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhegst_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhegv_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhegvd_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhegvx_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zherfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhesv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhesvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhetd2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhetf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhetrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhetrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhetri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhetrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhfrk_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zhgeqz_(__job: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpev_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpevd_(__jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpevx_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpgst_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __bp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpgv_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __bp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpgvd_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __bp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpgvx_(__itype: UnsafeMutablePointer<__CLPK_integer>, _ __jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __bp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __afp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhpsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __afp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhptrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhsein_(__side: UnsafeMutablePointer<Int8>, _ __eigsrc: UnsafeMutablePointer<Int8>, _ __initv: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __ifaill: UnsafeMutablePointer<__CLPK_integer>, _ __ifailr: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zhseqr_(__job: UnsafeMutablePointer<Int8>, _ __compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlabrd_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tauq: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __taup: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlacgv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlacn2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __est: UnsafeMutablePointer<__CLPK_doublereal>, _ __kase: UnsafeMutablePointer<__CLPK_integer>, _ __isave: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlacon_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __est: UnsafeMutablePointer<__CLPK_doublereal>, _ __kase: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlacp2_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlacpy_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlacrm_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func zlacrt_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cx: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __cy: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __s: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zladiv_(__ret_val: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>)
@available(OSX 10.2, *)
func zlaed0_(__qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __qstore: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldqs: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaed7_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __tlvls: UnsafeMutablePointer<__CLPK_integer>, _ __curlvl: UnsafeMutablePointer<__CLPK_integer>, _ __curpbm: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __qstore: UnsafeMutablePointer<__CLPK_doublereal>, _ __qptr: UnsafeMutablePointer<__CLPK_integer>, _ __prmptr: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaed8_(__k: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __qsiz: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rho: UnsafeMutablePointer<__CLPK_doublereal>, _ __cutpnt: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __dlamda: UnsafeMutablePointer<__CLPK_doublereal>, _ __q2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq2: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __indxp: UnsafeMutablePointer<__CLPK_integer>, _ __indx: UnsafeMutablePointer<__CLPK_integer>, _ __indxq: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaein_(__rightv: UnsafeMutablePointer<__CLPK_logical>, _ __noinit: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __eps3: UnsafeMutablePointer<__CLPK_doublereal>, _ __smlnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaesy_(__a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rt1: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rt2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __evscal: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __cs1: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __sn1: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlaev2_(__a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rt1: UnsafeMutablePointer<__CLPK_doublereal>, _ __rt2: UnsafeMutablePointer<__CLPK_doublereal>, _ __cs1: UnsafeMutablePointer<__CLPK_doublereal>, _ __sn1: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlag2c_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_complex>, _ __ldsa: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlags2_(__upper: UnsafeMutablePointer<__CLPK_logical>, _ __a1: UnsafeMutablePointer<__CLPK_doublereal>, _ __a2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __a3: UnsafeMutablePointer<__CLPK_doublereal>, _ __b1: UnsafeMutablePointer<__CLPK_doublereal>, _ __b2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b3: UnsafeMutablePointer<__CLPK_doublereal>, _ __csu: UnsafeMutablePointer<__CLPK_doublereal>, _ __snu: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __csv: UnsafeMutablePointer<__CLPK_doublereal>, _ __snv: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __csq: UnsafeMutablePointer<__CLPK_doublereal>, _ __snq: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlagtm_(__trans: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlahef_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlahqr_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlahr2_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlahrd_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaic1_(__job: UnsafeMutablePointer<__CLPK_integer>, _ __j: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __sest: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __gamma: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __sestpr: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlals0_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __nl: UnsafeMutablePointer<__CLPK_integer>, _ __nr: UnsafeMutablePointer<__CLPK_integer>, _ __sqre: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __bx: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldbx: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldgnum: UnsafeMutablePointer<__CLPK_integer>, _ __poles: UnsafeMutablePointer<__CLPK_doublereal>, _ __difl: UnsafeMutablePointer<__CLPK_doublereal>, _ __difr: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlalsa_(__icompq: UnsafeMutablePointer<__CLPK_integer>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __bx: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldbx: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublereal>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __vt: UnsafeMutablePointer<__CLPK_doublereal>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __difl: UnsafeMutablePointer<__CLPK_doublereal>, _ __difr: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublereal>, _ __poles: UnsafeMutablePointer<__CLPK_doublereal>, _ __givptr: UnsafeMutablePointer<__CLPK_integer>, _ __givcol: UnsafeMutablePointer<__CLPK_integer>, _ __ldgcol: UnsafeMutablePointer<__CLPK_integer>, _ __perm: UnsafeMutablePointer<__CLPK_integer>, _ __givnum: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlalsd_(__uplo: UnsafeMutablePointer<Int8>, _ __smlsiz: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlangb_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlange_(__norm: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlangt_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __dl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __du: UnsafeMutablePointer<__CLPK_doublecomplex>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlanhb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlanhe_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlanhf_(__norm: UnsafeMutablePointer<Int8>, _ __transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlanhp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlanhs_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlanht_(__norm: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlansb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlansp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlansy_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlantb_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlantp_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlantr_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func zlapll_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __ssmin: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func zlapmt_(__forwrd: UnsafeMutablePointer<__CLPK_logical>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaqgb_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func zlaqge_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __r__: UnsafeMutablePointer<__CLPK_doublereal>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __rowcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __colcnd: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func zlaqhb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func zlaqhe_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func zlaqhp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func zlaqp2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vn1: UnsafeMutablePointer<__CLPK_doublereal>, _ __vn2: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlaqps_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __offset: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __jpvt: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __vn1: UnsafeMutablePointer<__CLPK_doublereal>, _ __vn2: UnsafeMutablePointer<__CLPK_doublereal>, _ __auxv: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __f: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaqr0_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaqr1_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __s1: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __s2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlaqr2_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ns: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __sh: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaqr3_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nw: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ns: UnsafeMutablePointer<__CLPK_integer>, _ __nd: UnsafeMutablePointer<__CLPK_integer>, _ __sh: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaqr4_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaqr5_(__wantt: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __kacc22: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ktop: UnsafeMutablePointer<__CLPK_integer>, _ __kbot: UnsafeMutablePointer<__CLPK_integer>, _ __nshfts: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __h__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldh: UnsafeMutablePointer<__CLPK_integer>, _ __iloz: UnsafeMutablePointer<__CLPK_integer>, _ __ihiz: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __u: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __nv: UnsafeMutablePointer<__CLPK_integer>, _ __wv: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldwv: UnsafeMutablePointer<__CLPK_integer>, _ __nh: UnsafeMutablePointer<__CLPK_integer>, _ __wh: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldwh: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaqsb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func zlaqsp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func zlaqsy_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __equed: UnsafeMutablePointer<Int8>) -> Int32
@available(OSX 10.2, *)
func zlar1v_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __b1: UnsafeMutablePointer<__CLPK_integer>, _ __bn: UnsafeMutablePointer<__CLPK_integer>, _ __lambda: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __l: UnsafeMutablePointer<__CLPK_doublereal>, _ __ld: UnsafeMutablePointer<__CLPK_doublereal>, _ __lld: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __gaptol: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __wantnc: UnsafeMutablePointer<__CLPK_logical>, _ __negcnt: UnsafeMutablePointer<__CLPK_integer>, _ __ztz: UnsafeMutablePointer<__CLPK_doublereal>, _ __mingma: UnsafeMutablePointer<__CLPK_doublereal>, _ __r__: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __nrminv: UnsafeMutablePointer<__CLPK_doublereal>, _ __resid: UnsafeMutablePointer<__CLPK_doublereal>, _ __rqcorr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func zlar2v_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlarcm_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublereal>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func zlarf_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlarfb_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlarfg_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlarfp_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlarft_(__direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlarfx_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlargv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlarnv_(__idist: UnsafeMutablePointer<__CLPK_integer>, _ __iseed: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlarrv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __l: UnsafeMutablePointer<__CLPK_doublereal>, _ __pivmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __dol: UnsafeMutablePointer<__CLPK_integer>, _ __dou: UnsafeMutablePointer<__CLPK_integer>, _ __minrgp: UnsafeMutablePointer<__CLPK_doublereal>, _ __rtol1: UnsafeMutablePointer<__CLPK_doublereal>, _ __rtol2: UnsafeMutablePointer<__CLPK_doublereal>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __werr: UnsafeMutablePointer<__CLPK_doublereal>, _ __wgap: UnsafeMutablePointer<__CLPK_doublereal>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __indexw: UnsafeMutablePointer<__CLPK_integer>, _ __gers: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlarscl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlartg_(__f: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __g: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __cs: UnsafeMutablePointer<__CLPK_doublereal>, _ __sn: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __r__: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlartv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incc: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlarz_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlarzb_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlarzt_(__direct: UnsafeMutablePointer<Int8>, _ __storev: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlascl_(__type__: UnsafeMutablePointer<Int8>, _ __kl: UnsafeMutablePointer<__CLPK_integer>, _ __ku: UnsafeMutablePointer<__CLPK_integer>, _ __cfrom: UnsafeMutablePointer<__CLPK_doublereal>, _ __cto: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlascl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlaset_(__uplo: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlasr_(__side: UnsafeMutablePointer<Int8>, _ __pivot: UnsafeMutablePointer<Int8>, _ __direct: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlassq_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __sumsq: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func zlaswp_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __k1: UnsafeMutablePointer<__CLPK_integer>, _ __k2: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __incx: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlasyf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __kb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlat2c_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __sa: UnsafeMutablePointer<__CLPK_complex>, _ __ldsa: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlatbs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __cnorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlatdf_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __rhs: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rdsum: UnsafeMutablePointer<__CLPK_doublereal>, _ __rdscal: UnsafeMutablePointer<__CLPK_doublereal>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __jpiv: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlatps_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __cnorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlatrd_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nb: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldw: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlatrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __normin: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __cnorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlatrz_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlatzm_(__side: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incv: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c1: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c2: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zlauu2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zlauum_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbequ_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbstf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __afb: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldafb: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbtf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbtrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpbtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpftrf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpftri_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpftrs_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpocon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpoequ_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpoequb_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zporfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zposv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zposvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpotf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpotrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpotri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpotrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zppcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zppequ_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __afp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zppsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zppsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __afp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __equed: UnsafeMutablePointer<Int8>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpstf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __piv: UnsafeMutablePointer<__CLPK_integer>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __tol: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpstrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __piv: UnsafeMutablePointer<__CLPK_integer>, _ __rank: UnsafeMutablePointer<__CLPK_integer>, _ __tol: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zptcon_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpteqr_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zptrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __df: UnsafeMutablePointer<__CLPK_doublereal>, _ __ef: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zptsv_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zptsvx_(__fact: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __df: UnsafeMutablePointer<__CLPK_doublereal>, _ __ef: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpttrf_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zpttrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zptts2_(__iuplo: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zrot_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __cx: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __cy: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublereal>, _ __s: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zspcon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zspmv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zspr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>) -> Int32
@available(OSX 10.2, *)
func zsprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __afp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zspsv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zspsvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __afp: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsptrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsptri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zstedc_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __lrwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zstegr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __abstol: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zstein_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __iblock: UnsafeMutablePointer<__CLPK_integer>, _ __isplit: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __ifail: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zstemr_(__jobz: UnsafeMutablePointer<Int8>, _ __range: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __vl: UnsafeMutablePointer<__CLPK_doublereal>, _ __vu: UnsafeMutablePointer<__CLPK_doublereal>, _ __il: UnsafeMutablePointer<__CLPK_integer>, _ __iu: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __nzc: UnsafeMutablePointer<__CLPK_integer>, _ __isuppz: UnsafeMutablePointer<__CLPK_integer>, _ __tryrac: UnsafeMutablePointer<__CLPK_logical>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsteqr_(__compz: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublereal>, _ __e: UnsafeMutablePointer<__CLPK_doublereal>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsycon_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __anorm: UnsafeMutablePointer<__CLPK_doublereal>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsyequb_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __scond: UnsafeMutablePointer<__CLPK_doublereal>, _ __amax: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsymv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __y: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incy: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsyr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __incx: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsyrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsysv_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsysvx_(__fact: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __af: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldaf: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsytf2_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsytrf_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsytri_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zsytrs_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ipiv: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztbcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztbrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztbtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __kd: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ab: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldab: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztfsm_(__transr: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztftri_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztfttp_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztfttr_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztgevc_(__side: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lds: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldp: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztgex2_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __j1: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztgexc_(__wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __ifst: UnsafeMutablePointer<__CLPK_integer>, _ __ilst: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztgsen_(__ijob: UnsafeMutablePointer<__CLPK_integer>, _ __wantq: UnsafeMutablePointer<__CLPK_logical>, _ __wantz: UnsafeMutablePointer<__CLPK_logical>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __alpha: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __beta: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __z__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldz: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __pl: UnsafeMutablePointer<__CLPK_doublereal>, _ __pr: UnsafeMutablePointer<__CLPK_doublereal>, _ __dif: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __liwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztgsja_(__jobu: UnsafeMutablePointer<Int8>, _ __jobv: UnsafeMutablePointer<Int8>, _ __jobq: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __tola: UnsafeMutablePointer<__CLPK_doublereal>, _ __tolb: UnsafeMutablePointer<__CLPK_doublereal>, _ __alpha: UnsafeMutablePointer<__CLPK_doublereal>, _ __beta: UnsafeMutablePointer<__CLPK_doublereal>, _ __u: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldu: UnsafeMutablePointer<__CLPK_integer>, _ __v: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldv: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ncycle: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztgsna_(__job: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __dif: UnsafeMutablePointer<__CLPK_doublereal>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztgsy2_(__trans: UnsafeMutablePointer<Int8>, _ __ijob: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldd: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lde: UnsafeMutablePointer<__CLPK_integer>, _ __f: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __rdsum: UnsafeMutablePointer<__CLPK_doublereal>, _ __rdscal: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztgsyl_(__trans: UnsafeMutablePointer<Int8>, _ __ijob: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __d__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldd: UnsafeMutablePointer<__CLPK_integer>, _ __e: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lde: UnsafeMutablePointer<__CLPK_integer>, _ __f: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldf: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __dif: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __iwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztpcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztprfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztptri_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztptrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztpttf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __arf: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztpttr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrcon_(__norm: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __rcond: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrevc_(__side: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrexc_(__compq: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __ifst: UnsafeMutablePointer<__CLPK_integer>, _ __ilst: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrrfs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __x: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldx: UnsafeMutablePointer<__CLPK_integer>, _ __ferr: UnsafeMutablePointer<__CLPK_doublereal>, _ __berr: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrsen_(__job: UnsafeMutablePointer<Int8>, _ __compq: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __w: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __sep: UnsafeMutablePointer<__CLPK_doublereal>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrsna_(__job: UnsafeMutablePointer<Int8>, _ __howmny: UnsafeMutablePointer<Int8>, _ __select: UnsafeMutablePointer<__CLPK_logical>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldt: UnsafeMutablePointer<__CLPK_integer>, _ __vl: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvl: UnsafeMutablePointer<__CLPK_integer>, _ __vr: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldvr: UnsafeMutablePointer<__CLPK_integer>, _ __s: UnsafeMutablePointer<__CLPK_doublereal>, _ __sep: UnsafeMutablePointer<__CLPK_doublereal>, _ __mm: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldwork: UnsafeMutablePointer<__CLPK_integer>, _ __rwork: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrsyl_(__trana: UnsafeMutablePointer<Int8>, _ __tranb: UnsafeMutablePointer<Int8>, _ __isgn: UnsafeMutablePointer<__CLPK_integer>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __scale: UnsafeMutablePointer<__CLPK_doublereal>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrti2_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrtri_(__uplo: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrtrs_(__uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __diag: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __nrhs: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __b: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldb: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrttf_(__transr: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __arf: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztrttp_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztzrqf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ztzrzf_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zung2l_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zung2r_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zungbr_(__vect: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunghr_(__n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zungl2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunglq_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zungql_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zungqr_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zungr2_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zungrq_(__m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zungtr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunm2l_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunm2r_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmbr_(__vect: UnsafeMutablePointer<Int8>, _ __side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmhr_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ilo: UnsafeMutablePointer<__CLPK_integer>, _ __ihi: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunml2_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmlq_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmql_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmqr_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmr2_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmr3_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmrq_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmrz_(__side: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __k: UnsafeMutablePointer<__CLPK_integer>, _ __l: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zunmtr_(__side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __a: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lda: UnsafeMutablePointer<__CLPK_integer>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __lwork: UnsafeMutablePointer<__CLPK_integer>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zupgtr_(__uplo: UnsafeMutablePointer<Int8>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __q: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldq: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func zupmtr_(__side: UnsafeMutablePointer<Int8>, _ __uplo: UnsafeMutablePointer<Int8>, _ __trans: UnsafeMutablePointer<Int8>, _ __m: UnsafeMutablePointer<__CLPK_integer>, _ __n: UnsafeMutablePointer<__CLPK_integer>, _ __ap: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __tau: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __c__: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __ldc: UnsafeMutablePointer<__CLPK_integer>, _ __work: UnsafeMutablePointer<__CLPK_doublecomplex>, _ __info: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func ilaver_(__vers_major__: UnsafeMutablePointer<__CLPK_integer>, _ __vers_minor__: UnsafeMutablePointer<__CLPK_integer>, _ __vers_patch__: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slamch_(__cmach: UnsafeMutablePointer<Int8>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slamc1_(__beta: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_integer>, _ __rnd: UnsafeMutablePointer<__CLPK_logical>, _ __ieee1: UnsafeMutablePointer<__CLPK_logical>) -> Int32
@available(OSX 10.2, *)
func slamc2_(__beta: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_integer>, _ __rnd: UnsafeMutablePointer<__CLPK_logical>, _ __eps: UnsafeMutablePointer<__CLPK_real>, _ __emin: UnsafeMutablePointer<__CLPK_integer>, _ __rmin: UnsafeMutablePointer<__CLPK_real>, _ __emax: UnsafeMutablePointer<__CLPK_integer>, _ __rmax: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func slamc3_(__a: UnsafeMutablePointer<__CLPK_real>, _ __b: UnsafeMutablePointer<__CLPK_real>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func slamc4_(__emin: UnsafeMutablePointer<__CLPK_integer>, _ __start: UnsafeMutablePointer<__CLPK_real>, _ __base: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func slamc5_(__beta: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __emin: UnsafeMutablePointer<__CLPK_integer>, _ __ieee: UnsafeMutablePointer<__CLPK_logical>, _ __emax: UnsafeMutablePointer<__CLPK_integer>, _ __rmax: UnsafeMutablePointer<__CLPK_real>) -> Int32
@available(OSX 10.2, *)
func dlamch_(__cmach: UnsafeMutablePointer<Int8>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlamc1_(__beta: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_integer>, _ __rnd: UnsafeMutablePointer<__CLPK_logical>, _ __ieee1: UnsafeMutablePointer<__CLPK_logical>) -> Int32
@available(OSX 10.2, *)
func dlamc2_(__beta: UnsafeMutablePointer<__CLPK_integer>, _ __t: UnsafeMutablePointer<__CLPK_integer>, _ __rnd: UnsafeMutablePointer<__CLPK_logical>, _ __eps: UnsafeMutablePointer<__CLPK_doublereal>, _ __emin: UnsafeMutablePointer<__CLPK_integer>, _ __rmin: UnsafeMutablePointer<__CLPK_doublereal>, _ __emax: UnsafeMutablePointer<__CLPK_integer>, _ __rmax: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func dlamc3_(__a: UnsafeMutablePointer<__CLPK_doublereal>, _ __b: UnsafeMutablePointer<__CLPK_doublereal>) -> __CLPK_doublereal
@available(OSX 10.2, *)
func dlamc4_(__emin: UnsafeMutablePointer<__CLPK_integer>, _ __start: UnsafeMutablePointer<__CLPK_doublereal>, _ __base: UnsafeMutablePointer<__CLPK_integer>) -> Int32
@available(OSX 10.2, *)
func dlamc5_(__beta: UnsafeMutablePointer<__CLPK_integer>, _ __p: UnsafeMutablePointer<__CLPK_integer>, _ __emin: UnsafeMutablePointer<__CLPK_integer>, _ __ieee: UnsafeMutablePointer<__CLPK_logical>, _ __emax: UnsafeMutablePointer<__CLPK_integer>, _ __rmax: UnsafeMutablePointer<__CLPK_doublereal>) -> Int32
@available(OSX 10.2, *)
func ilaenv_(__ispec: UnsafeMutablePointer<__CLPK_integer>, _ __name__: UnsafeMutablePointer<Int8>, _ __opts: UnsafeMutablePointer<Int8>, _ __n1: UnsafeMutablePointer<__CLPK_integer>, _ __n2: UnsafeMutablePointer<__CLPK_integer>, _ __n3: UnsafeMutablePointer<__CLPK_integer>, _ __n4: UnsafeMutablePointer<__CLPK_integer>) -> __CLPK_integer
@available(OSX 10.0, *)
func vS32Divide(vN: vSInt32, _ vD: vSInt32, _ vRemainder: UnsafeMutablePointer<vSInt32>) -> vSInt32
@available(OSX 10.0, *)
func vS64Divide(vN: vSInt32, _ vD: vSInt32, _ vRemainder: UnsafeMutablePointer<vSInt32>) -> vSInt32
@available(OSX 10.0, *)
func vS128Divide(vN: vSInt32, _ vD: vSInt32, _ vRemainder: UnsafeMutablePointer<vSInt32>) -> vSInt32
@available(OSX 10.0, *)
func vS32HalfMultiply(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS32FullMulEven(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS32FullMulOdd(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS64HalfMultiply(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS64FullMulEven(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS64FullMulOdd(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS128HalfMultiply(vA: vSInt32, _ vB: vSInt32) -> vSInt32
func vS64Sub(__vbasicops_vA: vSInt32, _ __vbasicops_vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS128Sub(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS64SubS(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS128SubS(vA: vSInt32, _ vB: vSInt32) -> vSInt32
func vS64Add(__vbasicops_vA: vSInt32, _ __vbasicops_vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS64AddS(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS128Add(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.0, *)
func vS128AddS(vA: vSInt32, _ vB: vSInt32) -> vSInt32
@available(OSX 10.5, *)
func vS64Neg(vA: vSInt32) -> vSInt32
@available(OSX 10.5, *)
func vS128Neg(vA: vSInt32) -> vSInt32
struct vU128 {
  struct __Unnamed_struct_vs {
    init()
  }
  struct __Unnamed_struct_s {
    var LSW: UInt32
    var d3: UInt32
    var d2: UInt32
    var MSW: UInt32
    init()
    init(LSW: UInt32, d3: UInt32, d2: UInt32, MSW: UInt32)
  }
  var vs: vU128.__Unnamed_struct_vs
  var s: vU128.__Unnamed_struct_s
  init(vs: vU128.__Unnamed_struct_vs)
  init(s: vU128.__Unnamed_struct_s)
  init()
}
struct vS128 {
  struct __Unnamed_struct_vs {
    init()
  }
  struct __Unnamed_struct_s {
    var LSW: Int32
    var d3: UInt32
    var d2: UInt32
    var MSW: UInt32
    init()
    init(LSW: Int32, d3: UInt32, d2: UInt32, MSW: UInt32)
  }
  var vs: vS128.__Unnamed_struct_vs
  var s: vS128.__Unnamed_struct_s
  init(vs: vS128.__Unnamed_struct_vs)
  init(s: vS128.__Unnamed_struct_s)
  init()
}
struct vU256 {
  struct __Unnamed_struct_vs {
    init()
  }
  struct __Unnamed_struct_s {
    var LSW: UInt32
    var d7: UInt32
    var d6: UInt32
    var d5: UInt32
    var d4: UInt32
    var d3: UInt32
    var d2: UInt32
    var MSW: UInt32
    init()
    init(LSW: UInt32, d7: UInt32, d6: UInt32, d5: UInt32, d4: UInt32, d3: UInt32, d2: UInt32, MSW: UInt32)
  }
  var vs: vU256.__Unnamed_struct_vs
  var s: vU256.__Unnamed_struct_s
  init(vs: vU256.__Unnamed_struct_vs)
  init(s: vU256.__Unnamed_struct_s)
  init()
}
struct vS256 {
  struct __Unnamed_struct_vs {
    init()
  }
  struct __Unnamed_struct_s {
    var LSW: Int32
    var d7: UInt32
    var d6: UInt32
    var d5: UInt32
    var d4: UInt32
    var d3: UInt32
    var d2: UInt32
    var MSW: UInt32
    init()
    init(LSW: Int32, d7: UInt32, d6: UInt32, d5: UInt32, d4: UInt32, d3: UInt32, d2: UInt32, MSW: UInt32)
  }
  var vs: vS256.__Unnamed_struct_vs
  var s: vS256.__Unnamed_struct_s
  init(vs: vS256.__Unnamed_struct_vs)
  init(s: vS256.__Unnamed_struct_s)
  init()
}
struct vU512 {
  struct __Unnamed_struct_vs {
    init()
  }
  struct __Unnamed_struct_s {
    var LSW: UInt32
    var d15: UInt32
    var d14: UInt32
    var d13: UInt32
    var d12: UInt32
    var d11: UInt32
    var d10: UInt32
    var d9: UInt32
    var d8: UInt32
    var d7: UInt32
    var d6: UInt32
    var d5: UInt32
    var d4: UInt32
    var d3: UInt32
    var d2: UInt32
    var MSW: UInt32
    init()
    init(LSW: UInt32, d15: UInt32, d14: UInt32, d13: UInt32, d12: UInt32, d11: UInt32, d10: UInt32, d9: UInt32, d8: UInt32, d7: UInt32, d6: UInt32, d5: UInt32, d4: UInt32, d3: UInt32, d2: UInt32, MSW: UInt32)
  }
  var vs: vU512.__Unnamed_struct_vs
  var s: vU512.__Unnamed_struct_s
  init(vs: vU512.__Unnamed_struct_vs)
  init(s: vU512.__Unnamed_struct_s)
  init()
}
struct vS512 {
  struct __Unnamed_struct_vs {
    init()
  }
  struct __Unnamed_struct_s {
    var LSW: Int32
    var d15: UInt32
    var d14: UInt32
    var d13: UInt32
    var d12: UInt32
    var d11: UInt32
    var d10: UInt32
    var d9: UInt32
    var d8: UInt32
    var d7: UInt32
    var d6: UInt32
    var d5: UInt32
    var d4: UInt32
    var d3: UInt32
    var d2: UInt32
    var MSW: UInt32
    init()
    init(LSW: Int32, d15: UInt32, d14: UInt32, d13: UInt32, d12: UInt32, d11: UInt32, d10: UInt32, d9: UInt32, d8: UInt32, d7: UInt32, d6: UInt32, d5: UInt32, d4: UInt32, d3: UInt32, d2: UInt32, MSW: UInt32)
  }
  var vs: vS512.__Unnamed_struct_vs
  var s: vS512.__Unnamed_struct_s
  init(vs: vS512.__Unnamed_struct_vs)
  init(s: vS512.__Unnamed_struct_s)
  init()
}
struct vU1024 {
  struct __Unnamed_struct_vs {
    init()
  }
  struct __Unnamed_struct_s {
    var LSW: UInt32
    var d31: UInt32
    var d30: UInt32
    var d29: UInt32
    var d28: UInt32
    var d27: UInt32
    var d26: UInt32
    var d25: UInt32
    var d24: UInt32
    var d23: UInt32
    var d22: UInt32
    var d21: UInt32
    var d20: UInt32
    var d19: UInt32
    var d18: UInt32
    var d17: UInt32
    var d16: UInt32
    var d15: UInt32
    var d14: UInt32
    var d13: UInt32
    var d12: UInt32
    var d11: UInt32
    var d10: UInt32
    var d9: UInt32
    var d8: UInt32
    var d7: UInt32
    var d6: UInt32
    var d5: UInt32
    var d4: UInt32
    var d3: UInt32
    var d2: UInt32
    var MSW: UInt32
    init()
    init(LSW: UInt32, d31: UInt32, d30: UInt32, d29: UInt32, d28: UInt32, d27: UInt32, d26: UInt32, d25: UInt32, d24: UInt32, d23: UInt32, d22: UInt32, d21: UInt32, d20: UInt32, d19: UInt32, d18: UInt32, d17: UInt32, d16: UInt32, d15: UInt32, d14: UInt32, d13: UInt32, d12: UInt32, d11: UInt32, d10: UInt32, d9: UInt32, d8: UInt32, d7: UInt32, d6: UInt32, d5: UInt32, d4: UInt32, d3: UInt32, d2: UInt32, MSW: UInt32)
  }
  var vs: vU1024.__Unnamed_struct_vs
  var s: vU1024.__Unnamed_struct_s
  init(vs: vU1024.__Unnamed_struct_vs)
  init(s: vU1024.__Unnamed_struct_s)
  init()
}
struct vS1024 {
  struct __Unnamed_struct_vs {
    init()
  }
  struct __Unnamed_struct_s {
    var LSW: Int32
    var d31: UInt32
    var d30: UInt32
    var d29: UInt32
    var d28: UInt32
    var d27: UInt32
    var d26: UInt32
    var d25: UInt32
    var d24: UInt32
    var d23: UInt32
    var d22: UInt32
    var d21: UInt32
    var d20: UInt32
    var d19: UInt32
    var d18: UInt32
    var d17: UInt32
    var d16: UInt32
    var d15: UInt32
    var d14: UInt32
    var d13: UInt32
    var d12: UInt32
    var d11: UInt32
    var d10: UInt32
    var d9: UInt32
    var d8: UInt32
    var d7: UInt32
    var d6: UInt32
    var d5: UInt32
    var d4: UInt32
    var d3: UInt32
    var d2: UInt32
    var MSW: UInt32
    init()
    init(LSW: Int32, d31: UInt32, d30: UInt32, d29: UInt32, d28: UInt32, d27: UInt32, d26: UInt32, d25: UInt32, d24: UInt32, d23: UInt32, d22: UInt32, d21: UInt32, d20: UInt32, d19: UInt32, d18: UInt32, d17: UInt32, d16: UInt32, d15: UInt32, d14: UInt32, d13: UInt32, d12: UInt32, d11: UInt32, d10: UInt32, d9: UInt32, d8: UInt32, d7: UInt32, d6: UInt32, d5: UInt32, d4: UInt32, d3: UInt32, d2: UInt32, MSW: UInt32)
  }
  var vs: vS1024.__Unnamed_struct_vs
  var s: vS1024.__Unnamed_struct_s
  init(vs: vS1024.__Unnamed_struct_vs)
  init(s: vS1024.__Unnamed_struct_s)
  init()
}

/************************************************************************************
*                                                                                   *
*                                Division operations                                *
*                                                                                   *
************************************************************************************/
@available(OSX 10.0, *)
func vU256Divide(numerator: UnsafePointer<vU256>, _ divisor: UnsafePointer<vU256>, _ result: UnsafeMutablePointer<vU256>, _ remainder: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS256Divide(numerator: UnsafePointer<vS256>, _ divisor: UnsafePointer<vS256>, _ result: UnsafeMutablePointer<vS256>, _ remainder: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU512Divide(numerator: UnsafePointer<vU512>, _ divisor: UnsafePointer<vU512>, _ result: UnsafeMutablePointer<vU512>, _ remainder: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS512Divide(numerator: UnsafePointer<vS512>, _ divisor: UnsafePointer<vS512>, _ result: UnsafeMutablePointer<vS512>, _ remainder: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU1024Divide(numerator: UnsafePointer<vU1024>, _ divisor: UnsafePointer<vU1024>, _ result: UnsafeMutablePointer<vU1024>, _ remainder: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS1024Divide(numerator: UnsafePointer<vS1024>, _ divisor: UnsafePointer<vS1024>, _ result: UnsafeMutablePointer<vS1024>, _ remainder: UnsafeMutablePointer<vS1024>)

/************************************************************************************
*                                                                                   *
*                              Multiply operations                                  *
*                                                                                   *
************************************************************************************/
@available(OSX 10.0, *)
func vU128FullMultiply(a: UnsafePointer<vU128>, _ b: UnsafePointer<vU128>, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS128FullMultiply(a: UnsafePointer<vS128>, _ b: UnsafePointer<vS128>, _ result: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU256FullMultiply(a: UnsafePointer<vU256>, _ b: UnsafePointer<vU256>, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS256FullMultiply(a: UnsafePointer<vS256>, _ b: UnsafePointer<vS256>, _ result: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU512FullMultiply(a: UnsafePointer<vU512>, _ b: UnsafePointer<vU512>, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS512FullMultiply(a: UnsafePointer<vS512>, _ b: UnsafePointer<vS512>, _ result: UnsafeMutablePointer<vS1024>)
@available(OSX 10.0, *)
func vU256HalfMultiply(a: UnsafePointer<vU256>, _ b: UnsafePointer<vU256>, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS256HalfMultiply(a: UnsafePointer<vS256>, _ b: UnsafePointer<vS256>, _ result: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU512HalfMultiply(a: UnsafePointer<vU512>, _ b: UnsafePointer<vU512>, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS512HalfMultiply(a: UnsafePointer<vS512>, _ b: UnsafePointer<vS512>, _ result: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU1024HalfMultiply(a: UnsafePointer<vU1024>, _ b: UnsafePointer<vU1024>, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS1024HalfMultiply(a: UnsafePointer<vS1024>, _ b: UnsafePointer<vS1024>, _ result: UnsafeMutablePointer<vS1024>)

/************************************************************************************
*                                                                                   *
*                             Subtraction operations                                *
*                                                                                   *
************************************************************************************/
@available(OSX 10.0, *)
func vU256Sub(a: UnsafePointer<vU256>, _ b: UnsafePointer<vU256>, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS256Sub(a: UnsafePointer<vS256>, _ b: UnsafePointer<vS256>, _ result: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU256SubS(a: UnsafePointer<vU256>, _ b: UnsafePointer<vU256>, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS256SubS(a: UnsafePointer<vS256>, _ b: UnsafePointer<vS256>, _ result: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU512Sub(a: UnsafePointer<vU512>, _ b: UnsafePointer<vU512>, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS512Sub(a: UnsafePointer<vS512>, _ b: UnsafePointer<vS512>, _ result: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU512SubS(a: UnsafePointer<vU512>, _ b: UnsafePointer<vU512>, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS512SubS(a: UnsafePointer<vS512>, _ b: UnsafePointer<vS512>, _ result: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU1024Sub(a: UnsafePointer<vU1024>, _ b: UnsafePointer<vU1024>, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS1024Sub(a: UnsafePointer<vS1024>, _ b: UnsafePointer<vS1024>, _ result: UnsafeMutablePointer<vS1024>)
@available(OSX 10.0, *)
func vU1024SubS(a: UnsafePointer<vU1024>, _ b: UnsafePointer<vU1024>, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS1024SubS(a: UnsafePointer<vS1024>, _ b: UnsafePointer<vS1024>, _ result: UnsafeMutablePointer<vS1024>)

/************************************************************************************
*                                                                                   *
*                                Negate operations                                  *
*                                                                                   *
************************************************************************************/
@available(OSX 10.0, *)
func vU256Neg(a: UnsafePointer<vU256>, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS256Neg(a: UnsafePointer<vS256>, _ result: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU512Neg(a: UnsafePointer<vU512>, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS512Neg(a: UnsafePointer<vS512>, _ result: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU1024Neg(a: UnsafePointer<vU1024>, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS1024Neg(a: UnsafePointer<vS1024>, _ result: UnsafeMutablePointer<vS1024>)

/************************************************************************************
*                                                                                   *
*                                Addition operations                                *
*                                                                                   *
************************************************************************************/
@available(OSX 10.0, *)
func vU256Add(a: UnsafePointer<vU256>, _ b: UnsafePointer<vU256>, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS256Add(a: UnsafePointer<vS256>, _ b: UnsafePointer<vS256>, _ result: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU256AddS(a: UnsafePointer<vU256>, _ b: UnsafePointer<vU256>, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS256AddS(a: UnsafePointer<vS256>, _ b: UnsafePointer<vS256>, _ result: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU512Add(a: UnsafePointer<vU512>, _ b: UnsafePointer<vU512>, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS512Add(a: UnsafePointer<vS512>, _ b: UnsafePointer<vS512>, _ result: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU512AddS(a: UnsafePointer<vU512>, _ b: UnsafePointer<vU512>, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS512AddS(a: UnsafePointer<vS512>, _ b: UnsafePointer<vS512>, _ result: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU1024Add(a: UnsafePointer<vU1024>, _ b: UnsafePointer<vU1024>, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS1024Add(a: UnsafePointer<vS1024>, _ b: UnsafePointer<vS1024>, _ result: UnsafeMutablePointer<vS1024>)
@available(OSX 10.0, *)
func vU1024AddS(a: UnsafePointer<vU1024>, _ b: UnsafePointer<vU1024>, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS1024AddS(a: UnsafePointer<vS1024>, _ b: UnsafePointer<vS1024>, _ result: UnsafeMutablePointer<vS1024>)

/************************************************************************************
*                                                                                   *
*                                   Mod operations                                  *
*                                                                                   *
************************************************************************************/
@available(OSX 10.0, *)
func vU256Mod(numerator: UnsafePointer<vU256>, _ divisor: UnsafePointer<vU256>, _ remainder: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vS256Mod(numerator: UnsafePointer<vS256>, _ divisor: UnsafePointer<vS256>, _ remainder: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vU512Mod(numerator: UnsafePointer<vU512>, _ divisor: UnsafePointer<vU512>, _ remainder: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vS512Mod(numerator: UnsafePointer<vS512>, _ divisor: UnsafePointer<vS512>, _ remainder: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vU1024Mod(numerator: UnsafePointer<vU1024>, _ divisor: UnsafePointer<vU1024>, _ remainder: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vS1024Mod(numerator: UnsafePointer<vS1024>, _ divisor: UnsafePointer<vS1024>, _ remainder: UnsafeMutablePointer<vS1024>)

/************************************************************************************
*                                                                                   *
*                                Shift operations                                   *
*                                                                                   *
************************************************************************************/
@available(OSX 10.0, *)
func vLL256Shift(a: UnsafePointer<vU256>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vLL512Shift(a: UnsafePointer<vU512>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vLL1024Shift(a: UnsafePointer<vU1024>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vLR256Shift(a: UnsafePointer<vU256>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vLR512Shift(a: UnsafePointer<vU512>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vLR1024Shift(a: UnsafePointer<vU1024>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vA256Shift(a: UnsafePointer<vS256>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vS256>)
@available(OSX 10.0, *)
func vA512Shift(a: UnsafePointer<vS512>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vS512>)
@available(OSX 10.0, *)
func vA1024Shift(a: UnsafePointer<vS1024>, _ shiftAmount: UInt32, _ result: UnsafeMutablePointer<vS1024>)

/************************************************************************************
*                                                                                   *
*                                  Rotate operations                                *
*                                                                                   *
************************************************************************************/
@available(OSX 10.0, *)
func vL256Rotate(a: UnsafePointer<vU256>, _ rotateAmount: UInt32, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vL512Rotate(a: UnsafePointer<vU512>, _ rotateAmount: UInt32, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vL1024Rotate(a: UnsafePointer<vU1024>, _ rotateAmount: UInt32, _ result: UnsafeMutablePointer<vU1024>)
@available(OSX 10.0, *)
func vR256Rotate(a: UnsafePointer<vU256>, _ rotateAmount: UInt32, _ result: UnsafeMutablePointer<vU256>)
@available(OSX 10.0, *)
func vR512Rotate(a: UnsafePointer<vU512>, _ rotateAmount: UInt32, _ result: UnsafeMutablePointer<vU512>)
@available(OSX 10.0, *)
func vR1024Rotate(a: UnsafePointer<vU1024>, _ rotateAmount: UInt32, _ result: UnsafeMutablePointer<vU1024>)
var vDSP_Version0: Int32 { get }
var vDSP_Version1: Int32 { get }
typealias vDSP_Length = UInt
typealias vDSP_Stride = Int
struct DSPComplex {
  var real: Float
  var imag: Float
  init()
  init(real: Float, imag: Float)
}
struct DSPDoubleComplex {
  var real: Double
  var imag: Double
  init()
  init(real: Double, imag: Double)
}
struct DSPSplitComplex {
  var realp: UnsafeMutablePointer<Float>
  var imagp: UnsafeMutablePointer<Float>
}
struct DSPDoubleSplitComplex {
  var realp: UnsafeMutablePointer<Double>
  var imagp: UnsafeMutablePointer<Double>
}
typealias FFTDirection = Int32
typealias FFTRadix = Int32
var kFFTDirection_Forward: Int { get }
var kFFTDirection_Inverse: Int { get }
var kFFTRadix2: Int { get }
var kFFTRadix3: Int { get }
var kFFTRadix5: Int { get }
var vDSP_HALF_WINDOW: Int { get }
var vDSP_HANN_DENORM: Int { get }
var vDSP_HANN_NORM: Int { get }
struct vDSP_uint24 {
  var bytes: (UInt8, UInt8, UInt8)
  init()
  init(bytes: (UInt8, UInt8, UInt8))
}
struct vDSP_int24 {
  var bytes: (UInt8, UInt8, UInt8)
  init()
  init(bytes: (UInt8, UInt8, UInt8))
}
typealias FFTSetup = COpaquePointer
typealias FFTSetupD = COpaquePointer
typealias vDSP_biquad_Setup = COpaquePointer
typealias vDSP_biquad_SetupD = COpaquePointer
typealias vDSP_biquadm_Setup = COpaquePointer
typealias vDSP_biquadm_SetupD = COpaquePointer
@available(OSX 10.0, *)
func vDSP_create_fftsetup(__Log2n: vDSP_Length, _ __Radix: FFTRadix) -> FFTSetup
@available(OSX 10.0, *)
func vDSP_destroy_fftsetup(__setup: FFTSetup)
@available(OSX 10.2, *)
func vDSP_create_fftsetupD(__Log2n: vDSP_Length, _ __Radix: FFTRadix) -> FFTSetupD
@available(OSX 10.2, *)
func vDSP_destroy_fftsetupD(__setup: FFTSetupD)
@available(OSX 10.9, *)
func vDSP_biquad_CreateSetup(__Coefficients: UnsafePointer<Double>, _ __M: vDSP_Length) -> vDSP_biquad_Setup
@available(OSX 10.9, *)
func vDSP_biquad_CreateSetupD(__Coefficients: UnsafePointer<Double>, _ __M: vDSP_Length) -> vDSP_biquad_SetupD
@available(OSX 10.9, *)
func vDSP_biquad_DestroySetup(__setup: vDSP_biquad_Setup)
@available(OSX 10.9, *)
func vDSP_biquad_DestroySetupD(__setup: vDSP_biquad_SetupD)
@available(OSX 10.9, *)
func vDSP_biquadm_CreateSetup(__coeffs: UnsafePointer<Double>, _ __M: vDSP_Length, _ __N: vDSP_Length) -> vDSP_biquadm_Setup
@available(OSX 10.10, *)
func vDSP_biquadm_CreateSetupD(__coeffs: UnsafePointer<Double>, _ __M: vDSP_Length, _ __N: vDSP_Length) -> vDSP_biquadm_SetupD
@available(OSX 10.9, *)
func vDSP_biquadm_DestroySetup(__setup: vDSP_biquadm_Setup)
@available(OSX 10.10, *)
func vDSP_biquadm_DestroySetupD(__setup: vDSP_biquadm_SetupD)
@available(OSX 10.9, *)
func vDSP_biquadm_CopyState(__dest: vDSP_biquadm_Setup, _ __src: COpaquePointer)
@available(OSX 10.10, *)
func vDSP_biquadm_CopyStateD(__dest: vDSP_biquadm_SetupD, _ __src: COpaquePointer)
@available(OSX 10.9, *)
func vDSP_biquadm_ResetState(__setup: vDSP_biquadm_Setup)
@available(OSX 10.10, *)
func vDSP_biquadm_ResetStateD(__setup: vDSP_biquadm_SetupD)
@available(OSX 10.11, *)
func vDSP_biquadm_SetCoefficientsDouble(__setup: vDSP_biquadm_Setup, _ __coeffs: UnsafePointer<Double>, _ __start_sec: vDSP_Length, _ __start_chn: vDSP_Length, _ __nsec: vDSP_Length, _ __nchn: vDSP_Length)
@available(OSX 10.11, *)
func vDSP_biquadm_SetTargetsDouble(__setup: vDSP_biquadm_Setup, _ __targets: UnsafePointer<Double>, _ __interp_rate: Float, _ __interp_threshold: Float, _ __start_sec: vDSP_Length, _ __start_chn: vDSP_Length, _ __nsec: vDSP_Length, _ __nchn: vDSP_Length)
@available(OSX 10.11, *)
func vDSP_biquadm_SetCoefficientsSingle(__setup: vDSP_biquadm_Setup, _ __coeffs: UnsafePointer<Float>, _ __start_sec: vDSP_Length, _ __start_chn: vDSP_Length, _ __nsec: vDSP_Length, _ __nchn: vDSP_Length)
@available(OSX 10.11, *)
func vDSP_biquadm_SetTargetsSingle(__setup: vDSP_biquadm_Setup, _ __targets: UnsafePointer<Float>, _ __interp_rate: Float, _ __interp_threshold: Float, _ __start_sec: vDSP_Length, _ __start_chn: vDSP_Length, _ __nsec: vDSP_Length, _ __nchn: vDSP_Length)
@available(OSX 10.11, *)
func vDSP_biquadm_SetActiveFilters(__setup: vDSP_biquadm_Setup, _ __filter_states: UnsafePointer<Bool>)
@available(OSX 10.0, *)
func vDSP_ctoz(__C: UnsafePointer<DSPComplex>, _ __IC: vDSP_Stride, _ __Z: UnsafePointer<DSPSplitComplex>, _ __IZ: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_ctozD(__C: UnsafePointer<DSPDoubleComplex>, _ __IC: vDSP_Stride, _ __Z: UnsafePointer<DSPDoubleSplitComplex>, _ __IZ: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_ztoc(__Z: UnsafePointer<DSPSplitComplex>, _ __IZ: vDSP_Stride, _ __C: UnsafeMutablePointer<DSPComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_ztocD(__Z: UnsafePointer<DSPDoubleSplitComplex>, _ __IZ: vDSP_Stride, _ __C: UnsafeMutablePointer<DSPDoubleComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_fft_zip(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft_zipD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft_zipt(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft_ziptD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft_zop(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft_zopt(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft_zopD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft_zoptD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft_zrip(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft_zripD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft_zript(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft_zriptD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft_zrop(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft_zropD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft_zropt(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft_zroptD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft2d_zip(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft2d_zipD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft2d_zipt(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC1: vDSP_Stride, _ __IC0: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft2d_ziptD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft2d_zop(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA0: vDSP_Stride, _ __IA1: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft2d_zopD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA0: vDSP_Stride, _ __IA1: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft2d_zopt(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA0: vDSP_Stride, _ __IA1: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft2d_zoptD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA0: vDSP_Stride, _ __IA1: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft2d_zrip(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft2d_zripD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __flag: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft2d_zript(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft2d_zriptD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __flag: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft2d_zrop(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA0: vDSP_Stride, _ __IA1: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.0, *)
func vDSP_fft2d_zropt(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA0: vDSP_Stride, _ __IA1: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft2d_zropD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA0: vDSP_Stride, _ __IA1: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fft2d_zroptD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA0: vDSP_Stride, _ __IA1: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC0: vDSP_Stride, _ __IC1: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N0: vDSP_Length, _ __Log2N1: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zip(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __IM: vDSP_Stride, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zipD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __IM: vDSP_Stride, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zipt(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __IM: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_ziptD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __IM: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zop(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __IMA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __IMC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zopD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __IMA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __IMC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zopt(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __IMA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __IMC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zoptD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __IMA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __IMC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zrip(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __IM: vDSP_Stride, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zripD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __IM: vDSP_Stride, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zript(__Setup: FFTSetup, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __IM: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zriptD(__Setup: FFTSetupD, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __IM: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zrop(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __IMA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __IMC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zropt(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __IMA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __IMC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPSplitComplex>, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zropD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __IMA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __IMC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.2, *)
func vDSP_fftm_zroptD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __IMA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __IMC: vDSP_Stride, _ __Buffer: UnsafePointer<DSPDoubleSplitComplex>, _ __Log2N: vDSP_Length, _ __M: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX, introduced=10.2, deprecated=10.11)
func vDSP_fft3_zop(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX, introduced=10.2, deprecated=10.11)
func vDSP_fft3_zopD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX, introduced=10.2, deprecated=10.11)
func vDSP_fft5_zop(__Setup: FFTSetup, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX, introduced=10.2, deprecated=10.11)
func vDSP_fft5_zopD(__Setup: FFTSetupD, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __Log2N: vDSP_Length, _ __Direction: FFTDirection)
@available(OSX 10.9, *)
func vDSP_biquad(__Setup: COpaquePointer, _ __Delay: UnsafeMutablePointer<Float>, _ __X: UnsafePointer<Float>, _ __IX: vDSP_Stride, _ __Y: UnsafeMutablePointer<Float>, _ __IY: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_biquadD(__Setup: COpaquePointer, _ __Delay: UnsafeMutablePointer<Double>, _ __X: UnsafePointer<Double>, _ __IX: vDSP_Stride, _ __Y: UnsafeMutablePointer<Double>, _ __IY: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_biquadm(__Setup: vDSP_biquadm_Setup, _ __X: UnsafeMutablePointer<UnsafePointer<Float>>, _ __IX: vDSP_Stride, _ __Y: UnsafeMutablePointer<UnsafeMutablePointer<Float>>, _ __IY: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_biquadmD(__Setup: vDSP_biquadm_SetupD, _ __X: UnsafeMutablePointer<UnsafePointer<Double>>, _ __IX: vDSP_Stride, _ __Y: UnsafeMutablePointer<UnsafeMutablePointer<Double>>, _ __IY: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_conv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __F: UnsafePointer<Float>, _ __IF: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_convD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __F: UnsafePointer<Double>, _ __IF: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zconv(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __F: UnsafePointer<DSPSplitComplex>, _ __IF: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zconvD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __F: UnsafePointer<DSPDoubleSplitComplex>, _ __IF: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_f3x3(__A: UnsafePointer<Float>, _ __NR: vDSP_Length, _ __NC: vDSP_Length, _ __F: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>)
@available(OSX 10.2, *)
func vDSP_f3x3D(__A: UnsafePointer<Double>, _ __NR: vDSP_Length, _ __NC: vDSP_Length, _ __F: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>)
@available(OSX 10.2, *)
func vDSP_f5x5(__A: UnsafePointer<Float>, _ __NR: vDSP_Length, _ __NC: vDSP_Length, _ __F: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>)
@available(OSX 10.2, *)
func vDSP_f5x5D(__A: UnsafePointer<Double>, _ __NR: vDSP_Length, _ __NC: vDSP_Length, _ __F: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>)
@available(OSX 10.2, *)
func vDSP_imgfir(__A: UnsafePointer<Float>, _ __NR: vDSP_Length, _ __NC: vDSP_Length, _ __F: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __P: vDSP_Length, _ __Q: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_imgfirD(__A: UnsafePointer<Double>, _ __NR: vDSP_Length, _ __NC: vDSP_Length, _ __F: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __P: vDSP_Length, _ __Q: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_mtrans(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_mtransD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_mmul(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_mmulD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zmma(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPSplitComplex>, _ __ID: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zmmaD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPDoubleSplitComplex>, _ __ID: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zmms(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPSplitComplex>, _ __ID: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zmmsD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPDoubleSplitComplex>, _ __ID: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_zvmmaa(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPSplitComplex>, _ __ID: vDSP_Stride, _ __E: UnsafePointer<DSPSplitComplex>, _ __IE: vDSP_Stride, _ __F: UnsafePointer<DSPSplitComplex>, _ __IF: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_zvmmaaD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPDoubleSplitComplex>, _ __ID: vDSP_Stride, _ __E: UnsafePointer<DSPDoubleSplitComplex>, _ __IE: vDSP_Stride, _ __F: UnsafePointer<DSPDoubleSplitComplex>, _ __IF: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zmsm(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPSplitComplex>, _ __ID: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zmsmD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPDoubleSplitComplex>, _ __ID: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zmmul(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zmmulD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_vadd(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_vaddD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_vaddi(__A: UnsafePointer<Int32>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Int32>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zvadd(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zvaddD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zrvadd(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zrvaddD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_vsub(__B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_vsubD(__B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zvsub(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zvsubD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_vmul(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_vmulD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zrvmul(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zrvmulD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vdiv(__B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vdivD(__B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vdivi(__B: UnsafePointer<Int32>, _ __IB: vDSP_Stride, _ __A: UnsafePointer<Int32>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvdiv(__B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvdivD(__B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zrvdiv(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zrvdivD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_vsmul(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_vsmulD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_vsq(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_vsqD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_vssq(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_vssqD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.8, *)
func vDSP_distancesq(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_distancesqD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_dotpr(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_dotprD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zdotpr(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zdotprD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zrdotpr(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zrdotprD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_vam(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_vamD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Double>, _ __IDD: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vma(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmaD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_zvma(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPSplitComplex>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_zvmaD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPDoubleSplitComplex>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zvmul(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __Conjugate: Int32)
@available(OSX 10.2, *)
func vDSP_zvmulD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __Conjugate: Int32)
@available(OSX 10.0, *)
func vDSP_zidotpr(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zidotprD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zvcma(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPSplitComplex>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zvcmaD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPDoubleSplitComplex>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.0, *)
func vDSP_zrvsub(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.2, *)
func vDSP_zrvsubD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vdpsp(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vspdp(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vabs(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vabsD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vabsi(__A: UnsafePointer<Int32>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvabs(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvabsD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_veqvi(__A: UnsafePointer<Int32>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Int32>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfill(__A: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IA: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfillD(__A: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfilli(__A: UnsafePointer<Int32>, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvfill(__A: UnsafePointer<DSPSplitComplex>, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvfillD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsadd(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsaddD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsaddi(__A: UnsafePointer<Int32>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Int32>, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsdiv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsdivD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsdivi(__A: UnsafePointer<Int32>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Int32>, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zaspec(__A: UnsafePointer<DSPSplitComplex>, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zaspecD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_blkman_window(__C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length, _ __Flag: Int32)
@available(OSX 10.4, *)
func vDSP_blkman_windowD(__C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length, _ __Flag: Int32)
@available(OSX 10.4, *)
func vDSP_zcoher(__A: UnsafePointer<Float>, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<DSPSplitComplex>, _ __D: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zcoherD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __D: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_desamp(__A: UnsafePointer<Float>, _ __DF: vDSP_Stride, _ __F: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_desampD(__A: UnsafePointer<Double>, _ __DF: vDSP_Stride, _ __F: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zrdesamp(__A: UnsafePointer<DSPSplitComplex>, _ __DF: vDSP_Stride, _ __F: UnsafePointer<Float>, _ __C: UnsafePointer<DSPSplitComplex>, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zrdesampD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __DF: vDSP_Stride, _ __F: UnsafePointer<Double>, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_ztrans(__A: UnsafePointer<Float>, _ __B: UnsafePointer<DSPSplitComplex>, _ __C: UnsafePointer<DSPSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_ztransD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zcspec(__A: UnsafePointer<DSPSplitComplex>, _ __B: UnsafePointer<DSPSplitComplex>, _ __C: UnsafePointer<DSPSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zcspecD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvcmul(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvcmulD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __iC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvconj(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvconjD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvzsml(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvzsmlD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvmags(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvmagsD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvmgsa(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvmgsaD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvmov(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvmovD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvneg(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvnegD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvphas(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvphasD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvsma(__A: UnsafePointer<DSPSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPSplitComplex>, _ __C: UnsafePointer<DSPSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPSplitComplex>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_zvsmaD(__A: UnsafePointer<DSPDoubleSplitComplex>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<DSPDoubleSplitComplex>, _ __C: UnsafePointer<DSPDoubleSplitComplex>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<DSPDoubleSplitComplex>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_deq22(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_deq22D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_hamm_window(__C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length, _ __Flag: Int32)
@available(OSX 10.4, *)
func vDSP_hamm_windowD(__C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length, _ __Flag: Int32)
@available(OSX 10.4, *)
func vDSP_hann_window(__C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length, _ __Flag: Int32)
@available(OSX 10.4, *)
func vDSP_hann_windowD(__C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length, _ __Flag: Int32)
@available(OSX 10.4, *)
func vDSP_maxmgv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_maxmgvD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_maxmgvi(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_maxmgviD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_maxv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_maxvD(__A: UnsafePointer<Double>, _ __I: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_maxvi(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_maxviD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_meamgv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_meamgvD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_meanv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_meanvD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_measqv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_measqvD(__A: UnsafePointer<Double>, _ __I: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_minmgv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_minmgvD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_minmgvi(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_minmgviD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_minv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_minvD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_minvi(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_minviD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_mmov(__A: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __TA: vDSP_Length, _ __TC: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_mmovD(__A: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __M: vDSP_Length, _ __N: vDSP_Length, _ __TA: vDSP_Length, _ __TC: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_mvessq(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_mvessqD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_nzcros(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: vDSP_Length, _ __C: UnsafeMutablePointer<vDSP_Length>, _ __D: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_nzcrosD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: vDSP_Length, _ __C: UnsafeMutablePointer<vDSP_Length>, _ __D: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_polar(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_polarD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_rect(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_rectD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_rmsqv(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_rmsqvD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_svdiv(__A: UnsafePointer<Float>, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_svdivD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_sve(__A: UnsafePointer<Float>, _ __I: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_sveD(__A: UnsafePointer<Double>, _ __I: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_svemg(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_svemgD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_svesq(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_svesqD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.8, *)
func vDSP_sve_svesq(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __Sum: UnsafeMutablePointer<Float>, _ __SumOfSquares: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.8, *)
func vDSP_sve_svesqD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __Sum: UnsafeMutablePointer<Double>, _ __SumOfSquares: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.8, *)
func vDSP_normalize(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __Mean: UnsafeMutablePointer<Float>, _ __StandardDeviation: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.8, *)
func vDSP_normalizeD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __Mean: UnsafeMutablePointer<Double>, _ __StandardDeviation: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_svs(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_svsD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vaam(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Float>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Float>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vaamD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Double>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Double>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vasbm(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Float>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Float>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vasbmD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Double>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Double>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vasm(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vasmD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vavlin(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vavlinD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vclip(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vclipD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vclipc(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length, _ __NLow: UnsafeMutablePointer<vDSP_Length>, _ __NHigh: UnsafeMutablePointer<vDSP_Length>)
@available(OSX 10.4, *)
func vDSP_vclipcD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length, _ __NLow: UnsafeMutablePointer<vDSP_Length>, _ __NHigh: UnsafeMutablePointer<vDSP_Length>)
@available(OSX 10.4, *)
func vDSP_vclr(__C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vclrD(__C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vcmprs(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vcmprsD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vdbcon(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __F: UInt32)
@available(OSX 10.4, *)
func vDSP_vdbconD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __F: UInt32)
@available(OSX 10.4, *)
func vDSP_vdist(__A: UnsafePointer<Float>, _ __I: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __J: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __K: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vdistD(__A: UnsafePointer<Double>, _ __I: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __J: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __K: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_venvlp(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_venvlpD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfix8(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int8>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfix8D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int8>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfix16(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int16>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfix16D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int16>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfix32(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfix32D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixu8(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt8>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixu8D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt8>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixu16(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt16>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixu16D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt16>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixu32(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixu32D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_vsmfixu24(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<vDSP_uint24>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_vsmfix24(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<vDSP_int24>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_vfltu24(__A: UnsafePointer<vDSP_uint24>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_vflt24(__A: UnsafePointer<vDSP_int24>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_vfltsmu24(__A: UnsafePointer<vDSP_uint24>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_vfltsm24(__A: UnsafePointer<vDSP_int24>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixr8(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int8>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixr8D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int8>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixr16(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int16>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixr16D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int16>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixr32(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixr32D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixru8(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt8>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixru8D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt8>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixru16(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt16>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixru16D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt16>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixru32(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfixru32D(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<UInt32>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vflt8(__A: UnsafePointer<Int8>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vflt8D(__A: UnsafePointer<Int8>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vflt16(__A: UnsafePointer<Int16>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vflt16D(__A: UnsafePointer<Int16>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vflt32(__A: UnsafePointer<Int32>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vflt32D(__A: UnsafePointer<Int32>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfltu8(__A: UnsafePointer<UInt8>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfltu8D(__A: UnsafePointer<UInt8>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfltu16(__A: UnsafePointer<UInt16>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfltu16D(__A: UnsafePointer<UInt16>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfltu32(__A: UnsafePointer<UInt32>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfltu32D(__A: UnsafePointer<UInt32>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfrac(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vfracD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vgathr(__A: UnsafePointer<Float>, _ __B: UnsafePointer<vDSP_Length>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vgathrD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<vDSP_Length>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vgathra(__A: UnsafeMutablePointer<UnsafePointer<Float>>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vgathraD(__A: UnsafeMutablePointer<UnsafePointer<Double>>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vgen(__A: UnsafePointer<Float>, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vgenD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vgenp(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __M: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vgenpD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __M: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_viclip(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_viclipD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vindex(__A: UnsafePointer<Float>, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vindexD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vintb(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vintbD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vlim(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vlimD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vlint(__A: UnsafePointer<Float>, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __M: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vlintD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __M: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmax(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmaxD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmaxmg(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmaxmgD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vswmax(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __WindowLength: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vswmaxD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __WindowLength: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmin(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vminD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vminmg(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vminmgD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmma(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Float>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Float>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmmaD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Double>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Double>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmmsb(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Float>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Float>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmmsbD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Double>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Double>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmsa(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmsaD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmsb(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vmsbD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vnabs(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vnabsD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vneg(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vnegD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vpoly(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vpolyD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vpythg(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Float>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Float>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vpythgD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Double>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Double>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vqint(__A: UnsafePointer<Float>, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __M: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vqintD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __M: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vramp(__A: UnsafePointer<Float>, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vrampD(__A: UnsafePointer<Double>, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vrsum(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __S: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vrsumD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __S: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vrvrs(__C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vrvrsD(__C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsbm(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsbmD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsbsbm(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Float>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Float>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsbsbmD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Double>, _ __ID: vDSP_Stride, _ __E: UnsafeMutablePointer<Double>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsbsm(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsbsmD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsimps(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsimpsD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsma(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsmaD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsmsa(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsmsaD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __ID: UnsafeMutablePointer<Double>, _ __L: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsmsb(__A: UnsafePointer<Float>, _ __I: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __K: vDSP_Stride, _ __D: UnsafeMutablePointer<Float>, _ __L: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsmsbD(__A: UnsafePointer<Double>, _ __I: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __K: vDSP_Stride, _ __D: UnsafeMutablePointer<Double>, _ __L: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.9, *)
func vDSP_vsmsma(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Float>, _ __E: UnsafeMutablePointer<Float>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vsmsmaD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __IC: vDSP_Stride, _ __D: UnsafePointer<Double>, _ __E: UnsafeMutablePointer<Double>, _ __IE: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vsort(__C: UnsafeMutablePointer<Float>, _ __N: vDSP_Length, _ __Order: Int32)
@available(OSX 10.4, *)
func vDSP_vsortD(__C: UnsafeMutablePointer<Double>, _ __N: vDSP_Length, _ __Order: Int32)
@available(OSX 10.4, *)
func vDSP_vsorti(__C: UnsafePointer<Float>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __Temporary: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length, _ __Order: Int32)
@available(OSX 10.4, *)
func vDSP_vsortiD(__C: UnsafePointer<Double>, _ __I: UnsafeMutablePointer<vDSP_Length>, _ __Temporary: UnsafeMutablePointer<vDSP_Length>, _ __N: vDSP_Length, _ __Order: Int32)
@available(OSX 10.4, *)
func vDSP_vswap(__A: UnsafeMutablePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafeMutablePointer<Float>, _ __IB: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vswapD(__A: UnsafeMutablePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafeMutablePointer<Double>, _ __IB: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vswsum(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vswsumD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length, _ __P: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vtabi(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __S1: UnsafePointer<Float>, _ __S2: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __M: vDSP_Length, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vtabiD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __S1: UnsafePointer<Double>, _ __S2: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __M: vDSP_Length, _ __ID: UnsafeMutablePointer<Double>, _ __L: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vthr(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vthrD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vthres(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vthresD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vthrsc(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __D: UnsafeMutablePointer<Float>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vthrscD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __D: UnsafeMutablePointer<Double>, _ __ID: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vtmerg(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vtmergD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __IB: vDSP_Stride, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vtrapz(__A: UnsafePointer<Float>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __C: UnsafeMutablePointer<Float>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_vtrapzD(__A: UnsafePointer<Double>, _ __IA: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __C: UnsafeMutablePointer<Double>, _ __IC: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.4, *)
func vDSP_wiener(__L: vDSP_Length, _ __A: UnsafePointer<Float>, _ __C: UnsafePointer<Float>, _ __F: UnsafeMutablePointer<Float>, _ __P: UnsafeMutablePointer<Float>, _ __Flag: Int32, _ __Error: UnsafeMutablePointer<Int32>)
@available(OSX 10.4, *)
func vDSP_wienerD(__L: vDSP_Length, _ __A: UnsafePointer<Double>, _ __C: UnsafePointer<Double>, _ __F: UnsafeMutablePointer<Double>, _ __P: UnsafeMutablePointer<Double>, _ __Flag: Int32, _ __Error: UnsafeMutablePointer<Int32>)
@available(OSX 10.6, *)
func vDSP_FFT16_copv(__Output: UnsafeMutablePointer<Float>, _ __Input: UnsafePointer<Float>, _ __Direction: FFTDirection)
@available(OSX 10.6, *)
func vDSP_FFT32_copv(__Output: UnsafeMutablePointer<Float>, _ __Input: UnsafePointer<Float>, _ __Direction: FFTDirection)
@available(OSX 10.6, *)
func vDSP_FFT16_zopv(__Or: UnsafeMutablePointer<Float>, _ __Oi: UnsafeMutablePointer<Float>, _ __Ir: UnsafePointer<Float>, _ __Ii: UnsafePointer<Float>, _ __Direction: FFTDirection)
@available(OSX 10.6, *)
func vDSP_FFT32_zopv(__Or: UnsafeMutablePointer<Float>, _ __Oi: UnsafeMutablePointer<Float>, _ __Ir: UnsafePointer<Float>, _ __Ii: UnsafePointer<Float>, _ __Direction: FFTDirection)
typealias vDSP_DFT_Setup = COpaquePointer
typealias vDSP_DFT_SetupD = COpaquePointer
enum vDSP_DFT_Direction : Int32 {
  init?(rawValue: Int32)
  var rawValue: Int32 { get }
  case FORWARD
  case INVERSE
}
@available(OSX 10.6, *)
func vDSP_DFT_CreateSetup(__Previous: vDSP_DFT_Setup, _ __Length: vDSP_Length) -> vDSP_DFT_Setup
@available(OSX 10.7, *)
func vDSP_DFT_zop_CreateSetup(__Previous: vDSP_DFT_Setup, _ __Length: vDSP_Length, _ __Direction: vDSP_DFT_Direction) -> vDSP_DFT_Setup
@available(OSX 10.9, *)
func vDSP_DFT_zop_CreateSetupD(__Previous: vDSP_DFT_SetupD, _ __Length: vDSP_Length, _ __Direction: vDSP_DFT_Direction) -> vDSP_DFT_SetupD
@available(OSX 10.7, *)
func vDSP_DFT_zrop_CreateSetup(__Previous: vDSP_DFT_Setup, _ __Length: vDSP_Length, _ __Direction: vDSP_DFT_Direction) -> vDSP_DFT_Setup
@available(OSX 10.9, *)
func vDSP_DFT_zrop_CreateSetupD(__Previous: vDSP_DFT_SetupD, _ __Length: vDSP_Length, _ __Direction: vDSP_DFT_Direction) -> vDSP_DFT_SetupD
@available(OSX 10.6, *)
func vDSP_DFT_DestroySetup(__Setup: vDSP_DFT_Setup)
@available(OSX 10.9, *)
func vDSP_DFT_DestroySetupD(__Setup: vDSP_DFT_SetupD)
@available(OSX 10.6, *)
func vDSP_DFT_zop(__Setup: COpaquePointer, _ __Ir: UnsafePointer<Float>, _ __Ii: UnsafePointer<Float>, _ __Is: vDSP_Stride, _ __Or: UnsafeMutablePointer<Float>, _ __Oi: UnsafeMutablePointer<Float>, _ __Os: vDSP_Stride, _ __Direction: vDSP_DFT_Direction)
@available(OSX 10.7, *)
func vDSP_DFT_Execute(__Setup: COpaquePointer, _ __Ir: UnsafePointer<Float>, _ __Ii: UnsafePointer<Float>, _ __Or: UnsafeMutablePointer<Float>, _ __Oi: UnsafeMutablePointer<Float>)
@available(OSX 10.9, *)
func vDSP_DFT_ExecuteD(__Setup: COpaquePointer, _ __Ir: UnsafePointer<Double>, _ __Ii: UnsafePointer<Double>, _ __Or: UnsafeMutablePointer<Double>, _ __Oi: UnsafeMutablePointer<Double>)
enum vDSP_DCT_Type : Int32 {
  init?(rawValue: Int32)
  var rawValue: Int32 { get }
  case II
  case III
  case IV
}
@available(OSX 10.9, *)
func vDSP_DCT_CreateSetup(__Previous: vDSP_DFT_Setup, _ __Length: vDSP_Length, _ __Type: vDSP_DCT_Type) -> vDSP_DFT_Setup
@available(OSX 10.9, *)
func vDSP_DCT_Execute(__Setup: COpaquePointer, _ __Input: UnsafePointer<Float>, _ __Output: UnsafeMutablePointer<Float>)
@available(OSX 10.6, *)
func vDSP_dotpr2(__A0: UnsafePointer<Float>, _ __A0Stride: vDSP_Stride, _ __A1: UnsafePointer<Float>, _ __A1Stride: vDSP_Stride, _ __B: UnsafePointer<Float>, _ __BStride: vDSP_Stride, _ __C0: UnsafeMutablePointer<Float>, _ __C1: UnsafeMutablePointer<Float>, _ __Length: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_dotpr2D(__A0: UnsafePointer<Double>, _ __A0Stride: vDSP_Stride, _ __A1: UnsafePointer<Double>, _ __A1Stride: vDSP_Stride, _ __B: UnsafePointer<Double>, _ __BStride: vDSP_Stride, _ __C0: UnsafeMutablePointer<Double>, _ __C1: UnsafeMutablePointer<Double>, _ __Length: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_dotpr_s1_15(__A: UnsafePointer<Int16>, _ __AStride: vDSP_Stride, _ __B: UnsafePointer<Int16>, _ __BStride: vDSP_Stride, _ __C: UnsafeMutablePointer<Int16>, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_dotpr2_s1_15(__A0: UnsafePointer<Int16>, _ __A0Stride: vDSP_Stride, _ __A1: UnsafePointer<Int16>, _ __A1Stride: vDSP_Stride, _ __B: UnsafePointer<Int16>, _ __BStride: vDSP_Stride, _ __C0: UnsafeMutablePointer<Int16>, _ __C1: UnsafeMutablePointer<Int16>, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_dotpr_s8_24(__A: UnsafePointer<Int32>, _ __AStride: vDSP_Stride, _ __B: UnsafePointer<Int32>, _ __BStride: vDSP_Stride, _ __C: UnsafeMutablePointer<Int32>, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_dotpr2_s8_24(__A0: UnsafePointer<Int32>, _ __A0Stride: vDSP_Stride, _ __A1: UnsafePointer<Int32>, _ __A1Stride: vDSP_Stride, _ __B: UnsafePointer<Int32>, _ __BStride: vDSP_Stride, _ __C0: UnsafeMutablePointer<Int32>, _ __C1: UnsafeMutablePointer<Int32>, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vaddsub(__I0: UnsafePointer<Float>, _ __I0S: vDSP_Stride, _ __I1: UnsafePointer<Float>, _ __I1S: vDSP_Stride, _ __O0: UnsafeMutablePointer<Float>, _ __O0S: vDSP_Stride, _ __O1: UnsafeMutablePointer<Float>, _ __O1S: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vaddsubD(__I0: UnsafePointer<Double>, _ __I0S: vDSP_Stride, _ __I1: UnsafePointer<Double>, _ __I1S: vDSP_Stride, _ __O0: UnsafeMutablePointer<Double>, _ __O0S: vDSP_Stride, _ __O1: UnsafeMutablePointer<Double>, _ __O1S: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmul(__I: UnsafePointer<Float>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Float>, _ __Step: UnsafePointer<Float>, _ __O: UnsafeMutablePointer<Float>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vrampmulD(__I: UnsafePointer<Double>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Double>, _ __Step: UnsafePointer<Double>, _ __O: UnsafeMutablePointer<Double>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmuladd(__I: UnsafePointer<Float>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Float>, _ __Step: UnsafePointer<Float>, _ __O: UnsafeMutablePointer<Float>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vrampmuladdD(__I: UnsafePointer<Double>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Double>, _ __Step: UnsafePointer<Double>, _ __O: UnsafeMutablePointer<Double>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmul2(__I0: UnsafePointer<Float>, _ __I1: UnsafePointer<Float>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Float>, _ __Step: UnsafePointer<Float>, _ __O0: UnsafeMutablePointer<Float>, _ __O1: UnsafeMutablePointer<Float>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vrampmul2D(__I0: UnsafePointer<Double>, _ __I1: UnsafePointer<Double>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Double>, _ __Step: UnsafePointer<Double>, _ __O0: UnsafeMutablePointer<Double>, _ __O1: UnsafeMutablePointer<Double>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmuladd2(__I0: UnsafePointer<Float>, _ __I1: UnsafePointer<Float>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Float>, _ __Step: UnsafePointer<Float>, _ __O0: UnsafeMutablePointer<Float>, _ __O1: UnsafeMutablePointer<Float>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.10, *)
func vDSP_vrampmuladd2D(__I0: UnsafePointer<Double>, _ __I1: UnsafePointer<Double>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Double>, _ __Step: UnsafePointer<Double>, _ __O0: UnsafeMutablePointer<Double>, _ __O1: UnsafeMutablePointer<Double>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmul_s1_15(__I: UnsafePointer<Int16>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Int16>, _ __Step: UnsafePointer<Int16>, _ __O: UnsafeMutablePointer<Int16>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmuladd_s1_15(__I: UnsafePointer<Int16>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Int16>, _ __Step: UnsafePointer<Int16>, _ __O: UnsafeMutablePointer<Int16>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmul2_s1_15(__I0: UnsafePointer<Int16>, _ __I1: UnsafePointer<Int16>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Int16>, _ __Step: UnsafePointer<Int16>, _ __O0: UnsafeMutablePointer<Int16>, _ __O1: UnsafeMutablePointer<Int16>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmuladd2_s1_15(__I0: UnsafePointer<Int16>, _ __I1: UnsafePointer<Int16>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Int16>, _ __Step: UnsafePointer<Int16>, _ __O0: UnsafeMutablePointer<Int16>, _ __O1: UnsafeMutablePointer<Int16>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmul_s8_24(__I: UnsafePointer<Int32>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Int32>, _ __Step: UnsafePointer<Int32>, _ __O: UnsafeMutablePointer<Int32>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmuladd_s8_24(__I: UnsafePointer<Int32>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Int32>, _ __Step: UnsafePointer<Int32>, _ __O: UnsafeMutablePointer<Int32>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmul2_s8_24(__I0: UnsafePointer<Int32>, _ __I1: UnsafePointer<Int32>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Int32>, _ __Step: UnsafePointer<Int32>, _ __O0: UnsafeMutablePointer<Int32>, _ __O1: UnsafeMutablePointer<Int32>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
@available(OSX 10.6, *)
func vDSP_vrampmuladd2_s8_24(__I0: UnsafePointer<Int32>, _ __I1: UnsafePointer<Int32>, _ __IS: vDSP_Stride, _ __Start: UnsafeMutablePointer<Int32>, _ __Step: UnsafePointer<Int32>, _ __O0: UnsafeMutablePointer<Int32>, _ __O1: UnsafeMutablePointer<Int32>, _ __OS: vDSP_Stride, _ __N: vDSP_Length)
var USE_NON_APPLE_STANDARD_DATATYPES: Int32 { get }
var FFT_FORWARD: Int { get }
var FFT_INVERSE: Int { get }
var FFT_RADIX2: Int { get }
var FFT_RADIX3: Int { get }
var FFT_RADIX5: Int { get }
typealias COMPLEX = DSPComplex
typealias COMPLEX_SPLIT = DSPSplitComplex
typealias DOUBLE_COMPLEX = DSPDoubleComplex
typealias DOUBLE_COMPLEX_SPLIT = DSPDoubleSplitComplex
@available(OSX 10.4, *)
func vvrecf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvrec(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvdivf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvdiv(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvsqrtf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvsqrt(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.10, *)
func vvcbrtf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.10, *)
func vvcbrt(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvrsqrtf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvrsqrt(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvexpf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvexp(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.5, *)
func vvexpm1f(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvexpm1(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvlogf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvlog(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvlog10f(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvlog10(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.5, *)
func vvlog1pf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvlog1p(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.5, *)
func vvlogbf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvlogb(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvfabsf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvfabs(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvpowf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvpow(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.9, *)
func vvpowsf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.9, *)
func vvpows(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvsinf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvsin(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvcosf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvcos(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvtanf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvtan(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvasinf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvasin(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvacosf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvacos(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvatanf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvatan(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvatan2f(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvatan2(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvsincosf(_: UnsafeMutablePointer<Float>, _: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvsincos(_: UnsafeMutablePointer<Double>, _: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvcosisinf(_: COpaquePointer, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvcosisin(_: COpaquePointer, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvsinhf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvsinh(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvcoshf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvcosh(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvtanhf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvtanh(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvasinhf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvasinh(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvacoshf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvacosh(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvatanhf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvatanh(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvintf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvint(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvnintf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvnint(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvceilf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvceil(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvfloorf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.4, *)
func vvfloor(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.5, *)
func vvfmodf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvfmod(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.5, *)
func vvremainderf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvremainder(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.5, *)
func vvcopysignf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvcopysign(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.5, *)
func vvnextafterf(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvnextafter(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvlog2f(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvlog2(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvexp2f(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvexp2(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvsinpif(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvsinpi(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvcospif(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvcospi(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvtanpif(_: UnsafeMutablePointer<Float>, _: UnsafePointer<Float>, _: UnsafePointer<Int32>)
@available(OSX 10.7, *)
func vvtanpi(_: UnsafeMutablePointer<Double>, _: UnsafePointer<Double>, _: UnsafePointer<Int32>)
typealias vFloat = float4
var __VECLIBTYPES_VDOUBLE__: Int32 { get }
typealias vSInt32 = int4
typealias vDouble = double2

/**************************************************
  vIsamax finds the position of the first vector
  element having the largest magnitude.         
     count  length of vector x (count is a      
            multiple of 4)                      
     x      array of floats                     
**************************************************/
@available(OSX 10.0, *)
func vIsamax(count: Int32, _ x: UnsafePointer<vFloat>) -> Int32

/**************************************************
  vIsamin finds the position of the first vector
  element having minimum absolute value.        
     count  length of vector x (count is a      
            multiple of 4)                      
     x      array of floats                     
**************************************************/
@available(OSX 10.0, *)
func vIsamin(count: Int32, _ x: UnsafePointer<vFloat>) -> Int32

/**************************************************
  vIsmax finds the position of the first vector 
  element having maximum value.                 
     count  length of vector x (count is a      
            multiple of 4)                      
     x      array of floats                     
**************************************************/
@available(OSX 10.0, *)
func vIsmax(count: Int32, _ x: UnsafePointer<vFloat>) -> Int32

/**************************************************
  vIsmin finds the position of the first vector 
  element having minimum value.                 
     count  length of vector x (count is a      
            multiple of 4)                      
     x      array of floats                     
**************************************************/
@available(OSX 10.0, *)
func vIsmin(count: Int32, _ x: UnsafePointer<vFloat>) -> Int32

/**************************************************
  vSasum finds the sum of the magnitudes of the 
  elements in a vector.                         
     count  length of vector x (count is a      
            multiple of 4)                      
     x      array of floats                     
**************************************************/
@available(OSX 10.0, *)
func vSasum(count: Int32, _ x: UnsafePointer<vFloat>) -> Float

/**************************************************
  vSsum is the vector version of sasum but without  
  the absolute value. It takes the value of each
  element of the array and adds them together.      
            multiple of 4)                      
     x      array of floats                     
**************************************************/
@available(OSX 10.0, *)
func vSsum(count: Int32, _ x: UnsafePointer<vFloat>) -> Float

/**************************************************
  vSaxpy multiplies a vector x, by a scalar and 
  adds it to a vector y and stores the result in y
     n      number of floats in x (n is a       
            multiple of 4)                      
     alpha  scalar number is single-precision   
            floating-point                      
     x      array of vFloats              
     y      array of vFloats, where the   
            the result is stored                
**************************************************/
@available(OSX 10.0, *)
func vSaxpy(n: Int32, _ alpha: Float, _ x: UnsafePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>)

/*************************************************************
  vScopy copies a vector x, into another vector y.  
     n      mumber of floats in x and y (n is a 
            multiple of 4)                      
     x      array of vFloats              
     y      array of vFloats              
*************************************************************/
@available(OSX 10.0, *)
func vScopy(n: Int32, _ x: UnsafePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSdot finds the dot product of two vectors.      
    n       mumber of floats in x and y (n is a 
                multiple of 4)                      
    x       array of vFloats              
    y       array of vFloats              
*************************************************************/
@available(OSX 10.0, *)
func vSdot(n: Int32, _ x: UnsafePointer<vFloat>, _ y: UnsafePointer<vFloat>) -> Float

/*************************************************************
 vSnaxpy computes saxpy "n" times.               
   n            number of saxpyV computations to be 
                performed and the number of elements
                in vector A (n is a multiple of 4)  
   m            number of floats in each vector x(i)
                or y(i)                             
   a            array of vFloats containing   
                scalars a(i)                        
   x            matrix containing arrays of vector- 
                floats x(i)                         
   y            matrix containing vectors y(i)      
*************************************************************/
@available(OSX 10.0, *)
func vSnaxpy(n: Int32, _ m: Int32, _ a: UnsafePointer<vFloat>, _ x: UnsafePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSndot computes the dot products "n" times.     
    n       number of dot product computations  
            to be performed and the number of   
                elements in vector S                
    m       number of elements in vectors x(i)  
                and y(i) for each dot product       
                computation (m is a multiple of 4)  
    s       array of floats. Depending on the   
                value of "isw" different computations/
                are performed and the results are   
                stored in the array S               
    isw     indicates the type of computation   
                to perform.                         
                if isw=1, S(i) <--   x(i)   y(i)    
                if isw=2, S(i) <-- - x(i)   y(i)    
                if isw=3, S(i) <-- S(i) + x(i)   y(i)/
                if isw=4, S(i) <-- S(i) - x(i)   y(i)/
    x       matrix containing arrays x(i)       
    y       matrix containing arrays y(i)       
*************************************************************/
@available(OSX 10.0, *)
func vSndot(n: Int32, _ m: Int32, _ s: UnsafeMutablePointer<Float>, _ isw: Int32, _ x: UnsafePointer<vFloat>, _ y: UnsafePointer<vFloat>)

/*************************************************************
 vSnrm2 finds the Euclidean length of a vector   
 with scaling of input to avoid destructive      
 underflow and overflow.                         
    count   length of vector (multiple of 4)    
    x       array of vFloats              
*************************************************************/
@available(OSX 10.0, *)
func vSnrm2(count: Int32, _ x: UnsafePointer<vFloat>) -> Float

/*************************************************************
 vSnorm2 finds the Euclidean length of a vector  
 with no scaling of input.                       
    count   length of vector (multiple of 4)    
    x       array of vFloats              
*************************************************************/
@available(OSX 10.0, *)
func vSnorm2(count: Int32, _ x: UnsafePointer<vFloat>) -> Float

/*************************************************************
 vSrot applies a plane rotation.                 
    n       number of points to be rotated, also
                number of elements in x and y (n is 
                a multiple of 4)                    
    x       array of vFloats. It is a     
                vector of length n, containing x(i) 
                coordinates of points to be rotated 
    y       array of vFloats. It is a     
                vector of length n, containing y(i) 
                coordinates of points to be rotated 
    c       cosine of angle of rotation         
    s       sine of angle of rotation           
*************************************************************/
@available(OSX 10.0, *)
func vSrot(n: Int32, _ x: UnsafeMutablePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>, _ c: Float, _ s: Float)

/*************************************************************
 vSscal multiplies a vector x, by a scalar and   
 stores the result in the vector x.              
    n       number of floats in x (n is a       
                multiple of 4)                      
    alpha   scalar number is single-precision   
                floating-point                      
    x       array of vFloats              
*************************************************************/
@available(OSX 10.0, *)
func vSscal(n: Int32, _ alpha: Float, _ x: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSswap interchanges the elements of vectors x   
 and y                                           
    n       number of floats in x and y (n is a 
                multiple of 4)                      
    x       array of vFloats              
    y       array of vFloats              
*************************************************************/
@available(OSX 10.0, *)
func vSswap(n: Int32, _ x: UnsafeMutablePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSyax multiplies a vector x, by a scalar and    
 stores the result in a vector y.                
    n       number of floats in x (n is a       
                multiple of 4)                      
    alpha   scalar number is single-precision   
                floating-point                      
    x       array of vFloats              
    y       array of vFloats              
*************************************************************/
@available(OSX 10.0, *)
func vSyax(n: Int32, _ alpha: Float, _ x: UnsafePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSzaxpy multiplies a vector x, by a scalar and  
 adds it to a vector y and stores the result in  
 vector Z.                                       
    n       number of floats in x (n is a       
                multiple of 4)                      
    alpha   scalar number is single-precision   
                floating-point                      
    x       array of vFloats              
    y       array of vFloats              
    Z       array of vFloats, where the   
                is stored                           
*************************************************************/
@available(OSX 10.0, *)
func vSzaxpy(n: Int32, _ alpha: Float, _ x: UnsafePointer<vFloat>, _ y: UnsafePointer<vFloat>, _ z: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgemv multiplies an array of vFloats y by
 a  scalar beta, and takes the result and adds it
 to the product of a scalar alpha multiplied by  
 a matrix A multiplied by a vector x. The above  
 result is stored in array y. Futhermore, the    
 same function also performs the above calculation/
 with the transpose of matrix A, instead of      
 matrix A. In this function argument "forma"     
 distinguishes between the above two cases.      
    forma   indicates the form of matrix A to   
                use in the computation, where:      
                If forma = "n", Matrix A is used    
                If forma = "T", Transpose of Matrix 
                 A is used                          
    m       number of rows in matrix A and      
                depending on value of forma         
                if forma = "n", it is the length of 
                 vector y                           
                if forma = "T", it is the length of 
                 vector x. m is a multiple of 4     
    n       number of columns in matrix A and   
                depending on value of forma         
                if forma = "n", it is the length of 
                 vector x                           
                if forma = "T", it is the length of 
                 vector y. m is a multiple of 4     
    alpha   is a scaling constant               
    A       is an m by n matrix. Its elements   
                are vFloats                   
    x       is an array of vFloats        
    beta        is a scaling constant               
    y       is an array of vFloats        
*************************************************************/
@available(OSX 10.0, *)
func vSgemv(forma: Int8, _ m: Int32, _ n: Int32, _ alpha: Float, _ a: UnsafePointer<vFloat>, _ x: UnsafePointer<vFloat>, _ beta: Float, _ y: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgemx adds an array of vFloats y to the  
 product of an scalar alpha by a mtrix A         
 multiplied by an array of vFloats x. It   
 then stores the result in the vector y.         
    m       number of rows in matrix A and      
                the length of vector y. m is a      
            multiple of 4                       
    n       number of columns in matrix A and   
                the length of vector x. m is a      
            multiple of 4                       
    alpha   is a scaling constant               
    a       is an m by n matrix. Its elements   
                are vFloats                   
    x       is an array of vFloats        
    y       is an array of vFloats        
*************************************************************/
@available(OSX 10.0, *)
func vSgemx(m: Int32, _ n: Int32, _ alpha: Float, _ a: UnsafePointer<vFloat>, _ x: UnsafePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgemtx takes the transpose of a mtrix A and    
 multiplies it by an array x. It then multiplies 
 the result by a scalar alpha. Finally adds the  
 above result to an array y and stores the result
 in array y.                                     
    m       number of rows in matrix A and      
                the length of vector x. m is a      
            multiple of 4                       
    n       number of columns in matrix A and   
                the length of vector y. m is a      
            multiple of 4                       
    alpha   is a scaling constant               
    a       is an m by n matrix. Its elements   
                are vFloats                   
    x       is an array of vFloats        
    y       is an array of vFloats        
*************************************************************/
@available(OSX 10.0, *)
func vSgemtx(m: Int32, _ n: Int32, _ alpha: Float, _ a: UnsafePointer<vFloat>, _ x: UnsafePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgeadd performs matrix addition for general    
 matrices or their transposes.                   
    height  height of the matrix (it is multiple
                of 4)                               
    width   width of the matrix (it is multiple 
                of 4)                               
    A       matrix A, and depending on forma:   
                if forma='N', A is used in  the     
                computation, and A has m rows and   
                n columns                           
                if forma='T', A(T) is used in the   
                computation, and A has n rows and   
                m columns                           
    forma   indicates the form of matrix A to   
                use in the computation, where:      
                if forma='N', A is used in  the     
                computation                         
                if forma='T', A(T) is used in  the  
                computation                         
    b       matrix b, and depending on formb:   
                if formb='N', b is used in  the     
                computation, and b has m rows and   
                n columns                           
                if formb='T', b(T) is used in the   
                computation, and b has n rows and   
                m columns                           
    formb   indicates the form of matrix b to   
                use in the computation, where:      
                if forma='N', b is used in  the     
                computation                         
                if forma='T', b(T) is used in  the  
                computation                         
    c       is an m by n matrix c, containing   
                the reults of the computation       
*************************************************************/
@available(OSX 10.0, *)
func vSgeadd(height: Int32, _ width: Int32, _ a: UnsafePointer<vFloat>, _ forma: Int8, _ b: UnsafePointer<vFloat>, _ formb: Int8, _ c: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgesub performs matrix subtraction for general 
 matrices or their transposes.                   
    height  height of the matrix (it is multiple
                of 4)                               
    width   width of the matrix (it is multiple 
                of 4)                               
    A       matrix A, and depending on forma:   
                if forma='N', A is used in  the     
                computation, and A has m rows and   
                n columns                           
                if forma='T', A(T) is used in the   
                computation, and A has n rows and   
                m columns                           
    forma   indicates the form of matrix A to   
                use in the computation, where:      
                if forma='N', A is used in  the     
                computation                         
                if forma='T', A(T) is used in  the  
                computation                         
    b       matrix b, and depending on formb:   
                if formb='N', b is used in  the     
                computation, and b has m rows and   
                n columns                           
                if formb='T', b(T) is used in the   
                computation, and b has n rows and   
                m columns                           
    formb   indicates the form of matrix b to   
                use in the computation, where:      
                if forma='N', b is used in  the     
                computation                         
                if forma='T', b(T) is used in  the  
                computation                         
    c       is an m by n matrix c, containing   
                the reults of the computation       
*************************************************************/
@available(OSX 10.0, *)
func vSgesub(height: Int32, _ width: Int32, _ a: UnsafePointer<vFloat>, _ forma: Int8, _ b: UnsafePointer<vFloat>, _ formb: Int8, _ c: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgemul performs matrix multiplication for      
 general matrices or their transposes.           
    l       height of the matrix A (it is       
                multiple of 4)                      
    m       width of  matrix A  (it is multiple 
                of 4)                               
    n       width of  matrix b  (it is multiple 
                of 4)                               
    A       matrix A, and depending on forma:   
                if forma='N', A is used in  the     
                computation, and A has l rows and   
                m columns                           
                if forma='T', A(T) is used in the   
                computation, and A has m rows and   
                l columns                           
    forma   indicates the form of matrix A to   
                use in the computation, where:      
                if forma='N', A is used in  the     
                computation                         
                if forma='T', A(T) is used in  the  
                computation                         
    b       matrix b, and depending on formb:   
                if formb='N', b is used in  the     
                computation, and b has m rows and   
                n columns                           
                if formb='T', b(T) is used in the   
                computation, and b has n rows and   
                m columns                           
    formb   indicates the form of matrix b to   
                use in the computation, where:      
                if forma='N', b is used in  the     
                computation                         
                if forma='T', b(T) is used in  the  
                computation                         
    matrix  is the matrix containing the     
                results of the computation           
*************************************************************/
@available(OSX 10.0, *)
func vSgemul(l: Int32, _ m: Int32, _ n: Int32, _ a: UnsafePointer<vFloat>, _ forma: Int8, _ b: UnsafePointer<vFloat>, _ formb: Int8, _ matrix: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgemm performs combined matrix multiplication  
 and addition for general matrices or their transposes.                                     
    l       number of rows in matrix c (it is   
                multiple of 4)                      
    m       has the following meaning:          
                if forma='N', it is the number of   
                columns in matrix A                 
                if forma='T', it is the number of   
                rows in matrix A. In addition       
                if formb='N', it is the number of   
                rows in matrix b                    
                if formb='T', it is the number of   
                columns in matrix b                 
    n       columns in  matrix c                
    A       matrix A, and depending on forma:   
                if forma='N', A is used in  the     
                computation, and A has l rows and   
                m columns                           
                if forma='T', A(T) is used in the   
                computation, and A has m rows and   
                l columns                           
    forma   indicates the form of matrix A to   
                use in the computation, where:      
                if forma='N', A is used in  the     
                computation                         
                if forma='T', A(T) is used in  the  
                computation                         
    b       matrix b, and depending on formb:   
                if formb='N', b is used in  the     
                computation, and b has m rows and   
                n columns                           
                if formb='T', b(T) is used in the   
                computation, and b has n rows and   
                m columns                           
    formb   indicates the form of matrix b to   
                use in the computation, where:      
                if forma='N', b is used in  the     
                computation                         
                if forma='T', b(T) is used in  the  
                computation                         
    alpha   is a scalar                         
    beta        is a scalar                         
    matrix      is the l by n matrix          
*************************************************************/
@available(OSX 10.0, *)
func vSgemm(l: Int32, _ m: Int32, _ n: Int32, _ a: UnsafePointer<vFloat>, _ forma: Int8, _ b: UnsafePointer<vFloat>, _ formb: Int8, _ c: UnsafeMutablePointer<vFloat>, _ alpha: Float, _ beta: Float, _ matrix: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgetmi performs general matrix transpose (in place).                                         
    size        is the number of rows and columns   
                in matrix x                         
*************************************************************/
@available(OSX 10.0, *)
func vSgetmi(size: Int32, _ x: UnsafeMutablePointer<vFloat>)

/*************************************************************
 vSgetmo performs general matrix transpose (out-of-place).                                      
    height  is the height of the matrix         
    width   is the width of the matrix          
    x       array of vFloats              
    y       array of vFloats              
*************************************************************/
@available(OSX 10.0, *)
func vSgetmo(height: Int32, _ width: Int32, _ x: UnsafePointer<vFloat>, _ y: UnsafeMutablePointer<vFloat>)
@available(OSX 10.0, *)
func vSgevv(l: Int32, _ n: Int32, _ A: UnsafePointer<vFloat>, _ B: UnsafePointer<vFloat>, _ M: UnsafeMutablePointer<vFloat>)
@available(OSX 10.5, *)
func vceilf(_: vFloat) -> vFloat
@available(OSX 10.5, *)
func vfloorf(_: vFloat) -> vFloat
@available(OSX 10.9, *)
func vtruncf(_: vFloat) -> vFloat
@available(OSX 10.5, *)
func vnintf(_: vFloat) -> vFloat
@available(OSX 10.5, *)
func vintf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vexpf(_: vFloat) -> vFloat
@available(OSX 10.9, *)
func vexp2f(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vexpm1f(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vlogf(_: vFloat) -> vFloat
@available(OSX 10.9, *)
func vlog2f(_: vFloat) -> vFloat
@available(OSX 10.5, *)
func vlog10f(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vlog1pf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vlogbf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vscalbf(_: vFloat, _: vSInt32) -> vFloat
@available(OSX 10.0, *)
func vpowf(_: vFloat, _: vFloat) -> vFloat
@available(OSX 10.0, *)
func vipowf(_: vFloat, _: vSInt32) -> vFloat
@available(OSX 10.0, *)
func vsinf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vcosf(_: vFloat) -> vFloat
@available(OSX 10.5, *)
func vsincosf(_: vFloat, _: UnsafeMutablePointer<vFloat>) -> vFloat
@available(OSX 10.0, *)
func vtanf(_: vFloat) -> vFloat
@available(OSX 10.9, *)
func vsinpif(_: vFloat) -> vFloat
@available(OSX 10.9, *)
func vcospif(_: vFloat) -> vFloat
@available(OSX 10.9, *)
func vtanpif(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vasinf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vacosf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vatanf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vatan2f(_: vFloat, _: vFloat) -> vFloat
@available(OSX 10.0, *)
func vsinhf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vcoshf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vtanhf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vasinhf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vacoshf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vatanhf(_: vFloat) -> vFloat
@available(OSX 10.5, *)
func vrecf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vsqrtf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vrsqrtf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vdivf(_: vFloat, _: vFloat) -> vFloat
@available(OSX 10.0, *)
func vfmodf(_: vFloat, _: vFloat) -> vFloat
@available(OSX 10.0, *)
func vremainderf(_: vFloat, _: vFloat) -> vFloat
@available(OSX 10.0, *)
func vremquof(_: vFloat, _: vFloat, _: COpaquePointer) -> vFloat
@available(OSX 10.9, *)
func vfabsf(_: vFloat) -> vFloat
@available(OSX 10.0, *)
func vcopysignf(_: vFloat, _: vFloat) -> vFloat
@available(OSX 10.0, *)
func vnextafterf(_: vFloat, _: vFloat) -> vFloat
@available(OSX 10.0, *)
func vfabf(_: vFloat) -> vFloat
